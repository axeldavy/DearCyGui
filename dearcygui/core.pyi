from typing import Any
from enum import IntEnum
from typing import Protocol, Sequence
from .types import *

Sender = TypeVar('Sender', baseHandler, uiItem, covariant=True)
Target = TypeVar('Target', baseItem, covariant=True)

class DCGCallable0(Protocol):
    def __call__(self, /) -> Any:
        ...

class DCGCallable1(Protocol):
    def __call__(self,
                 sender : Sender,
                 /) -> Any:
        ...

class DCGCallable2(Protocol):
    def __call__(self,
                 sender : Sender,
                 target : Target,
                 /) -> Any:
        ...

class DCGCallable3(Protocol):
    def __call__(self,
                 sender : Sender,
                 target : Target,
                 value : Any,
                 /) -> Any:
        ...

class DCGCallable0Kw(Protocol):    
    def __call__(self, /, **kwargs) -> Any:
        ...

class DCGCallable1Kw(Protocol):
    def __call__(self,
                 sender : Sender,
                 /,
                 **kwargs : Any) -> Any:
        ...

class DCGCallable2Kw(Protocol):
    def __call__(self,
                 sender : Sender,
                 target : Target,
                 /,
                 **kwargs : Any) -> Any:
        ...

class DCGCallable3Kw(Protocol):
    def __call__(self,
                 sender : Sender,
                 target : Target,
                 value : Any,
                 /,  
                 **kwargs : Any) -> Any:
        ...


DCGCallable = DCGCallable0 | DCGCallable1 | DCGCallable2 | DCGCallable3 | DCGCallable0Kw | DCGCallable1Kw | DCGCallable2Kw | DCGCallable3Kw

Color = int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] | Sequence[int] | Sequence[float]


class wrap_mutex:
    def __init__(self, target) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...
    


class wrap_this_and_parents_mutex:
    def __init__(self, target) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...

class ActivatedHandler(baseHandler):
    """
    Handler for when the target item turns from
    the non-active to the active state. For instance
    buttons turn active when the mouse is pressed on them.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ActivatedHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ActiveHandler(baseHandler):
    """
    Handler for when the target item is active.
    For instance buttons turn active when the mouse
    is pressed on them, and stop being active when
    the mouse is released.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ActiveHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class AutoFont(FontMultiScales):
    """
    A self-managing font container that automatically creates and caches fonts at different scales.
    
    Automatically creates new font sizes when needed to match global_scale changes.
    
    Parameters
    ----------
    context : Context
        The context this font belongs to
    base_size : float = 17.0
        Base font size before scaling
    font_creator : callable = None
        Function to create fonts. Takes size as first argument and optional kwargs.
        The output should be a GlyphSet.
        If None, uses make_extended_latin_font.
    **kwargs : 
        Additional arguments passed to font_creator
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = ..., children : list[baseItem] = [], fonts : list = ..., next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: Callbacks that get triggered when a new scale is stored.
            Each callback receives the new scale value that was added.
        callbacks: Callbacks that get triggered when a new scale is stored.
            Each callback receives the new scale value that was added.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        fonts: List of attached fonts. Each font should have a different scale.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def _create_font_at_scale(self, scale, no_fail):
        """
Create a new font at the given scale
        """
        ...


    def _on_new_scale(self, sender, target, scale) -> None:
        """
Called when a new global scale is encountered
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = ..., children : list[baseItem] = [], fonts : list = ..., next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: Callbacks that get triggered when a new scale is stored.
            Each callback receives the new scale value that was added.
        callbacks: Callbacks that get triggered when a new scale is stored.
            Each callback receives the new scale value that was added.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        fonts: List of attached fonts. Each font should have a different scale.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> AutoFont:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Callbacks that get triggered when a new scale is stored.
        Each callback receives the new scale value that was added.
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fonts(self) -> list:
        """
        List of attached fonts. Each font should have a different scale.
        
        """
        ...


    @fonts.setter
    def fonts(self, value : list):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def recent_scales(self) -> list:
        """
        List of up to 10 most recent global scales encountered during rendering.
        The scales are not in a particular order
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class AxesResizeHandler(baseHandler):
    """
    Handler that can only be bound to a plot,
    and that triggers the callback whenever the
    axes min/max OR the plot region box changes.
    Basically whenever the size
    of a pixel within plot coordinate has likely changed.

    The data field passed to the callback contains
    ((min, max, scale), (min, max, scale)) where
    scale = (max-min) / num_real_pixels
    and the first tuple is for the target X axis (default X1),
    and the second tuple for the target Y axis (default Y1)
    
    """
    def __init__(self, context : Context, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this handler.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this handler.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> AxesResizeHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this handler.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class AxisTag(baseItem):
    """
    Class for Axis tags. Can only be child
    of a plot Axis.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., bg_color : list = [0.0, 0.0, 0.0, 0.0], children : list[baseItem] = [], coord : float = 0.0, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, text : str = "", user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bg_color: Background color of the tag.
            0 means no background, in which case ImPlotCol_AxisText
            is used for the text color. Else Text is automatically
            set to white or black depending on the background color
        children: List of all the children of the item,
            from first rendered, to last rendered.
        coord: Coordinate of the tag.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
        text: Text of the tag.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., bg_color : list = [0.0, 0.0, 0.0, 0.0], children : list[baseItem] = [], coord : float = 0.0, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, text : str = "", user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bg_color: Background color of the tag.
            0 means no background, in which case ImPlotCol_AxisText
            is used for the text color. Else Text is automatically
            set to white or black depending on the background color
        children: List of all the children of the item,
            from first rendered, to last rendered.
        coord: Coordinate of the tag.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
        text: Text of the tag.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> AxisTag:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def bg_color(self) -> list:
        """
        Writable attribute: Background color of the tag.
        0 means no background, in which case ImPlotCol_AxisText
        is used for the text color. Else Text is automatically
        set to white or black depending on the background color

        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @bg_color.setter
    def bg_color(self, value : list):
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def coord(self) -> float:
        """
        Writable attribute: Coordinate of the tag.
        
        """
        ...


    @coord.setter
    def coord(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def text(self) -> str:
        """
        Writable attribute: Text of the tag.
        
        """
        ...


    @text.setter
    def text(self, value : str):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Button(uiItem):
    def __init__(self, context : Context, arrow : bool = False, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], direction : ButtonDirection = 2, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, repeat : bool = False, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, small : bool = False, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        arrow: Whether to display an arrow.
            Not compatible with small
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        direction: Direction of the arrow if any
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        repeat: Whether to generate many clicked events
            when the button is held repeatedly, instead of a single.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        small: Whether to display a small button
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, arrow : bool = False, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], direction : ButtonDirection = 2, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, repeat : bool = False, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, small : bool = False, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        arrow: Whether to display an arrow.
            Not compatible with small
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        direction: Direction of the arrow if any
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        repeat: Whether to generate many clicked events
            when the button is held repeatedly, instead of a single.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        small: Whether to display a small button
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Button:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def arrow(self) -> bool:
        """
        Writable attribute: Whether to display an arrow.
        Not compatible with small
        
        """
        ...


    @arrow.setter
    def arrow(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def direction(self) -> ButtonDirection:
        """
        Writable attribute: Direction of the arrow if any
        
        """
        ...


    @direction.setter
    def direction(self, value : ButtonDirection):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def repeat(self) -> bool:
        """
        Writable attribute: Whether to generate many clicked events
        when the button is held repeatedly, instead of a single.
        
        """
        ...


    @repeat.setter
    def repeat(self, value : bool):
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def small(self) -> bool:
        """
        Writable attribute: Whether to display a small button
        
        """
        ...


    @small.setter
    def small(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Callback(object):
    """
    Wrapper class that automatically encapsulate callbacks.

    Callbacks in DCG mode can take up to 3 arguments:
    - source_item: the item to which the callback was attached
    - target_item: the item for which the callback was raised.
        Is only different to source_item for handlers' callback.
    - call_info: If applicable information about the call (key button, etc)
    
    """
    def __init__(self, callback : DCGCallable):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


class Checkbox(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Checkbox:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ChildWindow(uiItem):
    """
A child window container that enables hierarchical UI layout.

    A child window creates a scrollable/clippable region within a parent window that can contain any UI elements 
    and apply its own visual styling.

    Key Features:
    - Independent scrolling/clipping region 
    - Optional borders and background
    - Can contain most UI elements including other child windows
    - Automatic size fitting to content or parent
    - Optional scrollbars (vertical & horizontal)
    - Optional menu bar
    - DPI-aware scaling

    Properties:
    -----------
    always_show_vertical_scrollvar : bool
        Always show vertical scrollbar even when content fits. Default is False.

    always_show_horizontal_scrollvar : bool
        Always show horizontal scrollbar when enabled. Default is False. 

    no_scrollbar : bool
        Hide scrollbars but still allow scrolling with mouse/keyboard. Default is False.

    no_scroll_with_mouse : bool
        If set, mouse wheel scrolls parent instead of this child (unless no_scrollbar is set). Default is False.

    horizontal_scrollbar : bool
        Enable horizontal scrollbar. Default is False.

    menubar : bool 
        Enable menu bar at top of window. Default is False.

    border : bool
        Show window border and enable padding. Default is True.

    flattened_navigation: bool
        Share focus scope and allow keyboard/gamepad navigation to cross between parent and child.
        Default is True.

    Notes:
    ------
    - Child windows provide independent scrolling regions within a parent window
    - Content is automatically clipped to the visible region
    - Content size can be fixed or dynamic based on settings
    - Can enable borders and backgrounds independently
    - Keyboard focus and navigation can be customized
    - Menu bar support allows structured layouts
    
    """
    def __init__(self, context : Context, always_auto_resize : bool = False, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, always_use_window_padding : bool = False, attach : Any = ..., auto_resize_x : bool = False, auto_resize_y : bool = False, before : Any = ..., border : bool = True, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, flattened_navigation : bool = True, focused : bool = False, font : Font = None, frame_style : bool = False, handlers : list = [], height : float = 0.0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", menubar : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, resizable_x : bool = False, resizable_y : bool = False, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        always_auto_resize: combined with AutoResizeX/AutoResizeY.
            Always measure size even when child is hidden,
            Note the item will render its children even if hidden.
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        always_use_window_padding: pad with style WindowPadding even if
            no border are drawn (no padding by default for non-bordered
            child windows)
        attach: Whether to attach the item to a parent. Default is None (auto)
        auto_resize_x: enable auto-resizing width based on the content
            Set instead width to 0 to use the remaining size of the parent
        auto_resize_y: enable auto-resizing height based on the content
            Set instead height to 0 to use the remaining size of the parent
        before: Attach the item just before the target item. Default is None (disabled)
        border: show an outer border and enable WindowPadding.
            Defaults to True.
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        flattened_navigation: share focus scope, allow gamepad/keyboard
            navigation to cross over parent border to this child or
            between sibling child windows.
            Defaults to True.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        frame_style: if set, style the child window like a framed item.
            That is: use FrameBg, FrameRounding, FrameBorderSize, FramePadding
            instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        menubar: Writable attribute to indicate whether the window has a menu bar.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: mouse wheel will be forwarded to the parent
            unless NoScrollbar is also set.
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resizable_x: allow resize from right border (layout direction).
        resizable_y: allow resize from bottom border (layout direction).
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_auto_resize : bool = False, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, always_use_window_padding : bool = False, attach : Any = ..., auto_resize_x : bool = False, auto_resize_y : bool = False, before : Any = ..., border : bool = True, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, flattened_navigation : bool = True, focused : bool = False, font : Font = None, frame_style : bool = False, handlers : list = [], height : float = 0.0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", menubar : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, resizable_x : bool = False, resizable_y : bool = False, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        always_auto_resize: combined with AutoResizeX/AutoResizeY.
            Always measure size even when child is hidden,
            Note the item will render its children even if hidden.
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        always_use_window_padding: pad with style WindowPadding even if
            no border are drawn (no padding by default for non-bordered
            child windows)
        attach: Whether to attach the item to a parent. Default is None (auto)
        auto_resize_x: enable auto-resizing width based on the content
            Set instead width to 0 to use the remaining size of the parent
        auto_resize_y: enable auto-resizing height based on the content
            Set instead height to 0 to use the remaining size of the parent
        before: Attach the item just before the target item. Default is None (disabled)
        border: show an outer border and enable WindowPadding.
            Defaults to True.
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        flattened_navigation: share focus scope, allow gamepad/keyboard
            navigation to cross over parent border to this child or
            between sibling child windows.
            Defaults to True.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        frame_style: if set, style the child window like a framed item.
            That is: use FrameBg, FrameRounding, FrameBorderSize, FramePadding
            instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        menubar: Writable attribute to indicate whether the window has a menu bar.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: mouse wheel will be forwarded to the parent
            unless NoScrollbar is also set.
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resizable_x: allow resize from right border (layout direction).
        resizable_y: allow resize from bottom border (layout direction).
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ChildWindow:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def always_auto_resize(self) -> bool:
        """
        Writable attribute: combined with AutoResizeX/AutoResizeY.
        Always measure size even when child is hidden,
        Note the item will render its children even if hidden.
        
        """
        ...


    @always_auto_resize.setter
    def always_auto_resize(self, value : bool):
        ...


    @property
    def always_show_horizontal_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a horizontal scrollbar
        even when the size does not require it (only if horizontal scrollbar
        are enabled)
        
        """
        ...


    @always_show_horizontal_scrollvar.setter
    def always_show_horizontal_scrollvar(self, value : bool):
        ...


    @property
    def always_show_vertical_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a vertical scrollbar
        even when the size does not require it
        
        """
        ...


    @always_show_vertical_scrollvar.setter
    def always_show_vertical_scrollvar(self, value : bool):
        ...


    @property
    def always_use_window_padding(self) -> bool:
        """
        Writable attribute: pad with style WindowPadding even if
        no border are drawn (no padding by default for non-bordered
        child windows)
        
        """
        ...


    @always_use_window_padding.setter
    def always_use_window_padding(self, value : bool):
        ...


    @property
    def auto_resize_x(self) -> bool:
        """
        Writable attribute: enable auto-resizing width based on the content
        Set instead width to 0 to use the remaining size of the parent
        
        """
        ...


    @auto_resize_x.setter
    def auto_resize_x(self, value : bool):
        ...


    @property
    def auto_resize_y(self) -> bool:
        """
        Writable attribute: enable auto-resizing height based on the content
        Set instead height to 0 to use the remaining size of the parent
        
        """
        ...


    @auto_resize_y.setter
    def auto_resize_y(self, value : bool):
        ...


    @property
    def border(self) -> bool:
        """
        Writable attribute: show an outer border and enable WindowPadding.
        Defaults to True.
        
        """
        ...


    @border.setter
    def border(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def flattened_navigation(self) -> bool:
        """
        Writable attribute: share focus scope, allow gamepad/keyboard
        navigation to cross over parent border to this child or
        between sibling child windows.
        Defaults to True.
        
        """
        ...


    @flattened_navigation.setter
    def flattened_navigation(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def frame_style(self) -> bool:
        """
        Writable attribute: if set, style the child window like a framed item.
        That is: use FrameBg, FrameRounding, FrameBorderSize, FramePadding
        instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
        
        """
        ...


    @frame_style.setter
    def frame_style(self, value : bool):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def horizontal_scrollbar(self) -> bool:
        """
        Writable attribute to enable having an horizontal scrollbar
        
        """
        ...


    @horizontal_scrollbar.setter
    def horizontal_scrollbar(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def menubar(self) -> bool:
        """
        Writable attribute to indicate whether the window has a menu bar.

        There will be menubar if either the user has asked for it,
        or there is a menubar child.
        
        """
        ...


    @menubar.setter
    def menubar(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_scroll_with_mouse(self) -> bool:
        """
        Writable attribute: mouse wheel will be forwarded to the parent
        unless NoScrollbar is also set.
        
        """
        ...


    @no_scroll_with_mouse.setter
    def no_scroll_with_mouse(self, value : bool):
        ...


    @property
    def no_scrollbar(self) -> bool:
        """Writable attribute to indicate the window should have no scrollbar
           Does not disable scrolling via mouse or keyboard
        
        """
        ...


    @no_scrollbar.setter
    def no_scrollbar(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resizable_x(self) -> bool:
        """
        Writable attribute: allow resize from right border (layout direction).
        
        """
        ...


    @resizable_x.setter
    def resizable_x(self, value : bool):
        ...


    @property
    def resizable_y(self) -> bool:
        """
        Writable attribute: allow resize from bottom border (layout direction).
        
        """
        ...


    @resizable_y.setter
    def resizable_y(self, value : bool):
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ClickedHandler(baseHandler):
    """
    Handler for when a hovered item is clicked on.
    The item doesn't have to be interactable,
    it can be Text for example.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        button: Target mouse button
            0: left click
            1: right click
            2: middle click
            3, 4: other buttons
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        button: Target mouse button
            0: left click
            1: right click
            2: middle click
            3, 4: other buttons
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ClickedHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        """
        Target mouse button
        0: left click
        1: right click
        2: middle click
        3, 4: other buttons
        
        """
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class CloseHandler(baseHandler):
    """
    Handler that triggers the callback when the
    item is in an closed state.
    *Warning*: Does not mean an item is un-shown
    by a user interaction (what we usually mean
    by closing a window).
    Here Close/Open refers to being in a
    reduced state when the full content is not
    shown, but could be if the user clicked on
    a specific button. The doesn't mean that
    the object is show or not shown.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> CloseHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class CollapsingHeader(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], closable : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", leaf : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, open_on_arrow : bool = False, open_on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bullet: Display a bullet instead of arrow.
            IMPORTANT: node can still be marked open/close if
            you don't set the _Leaf flag!
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closable: Display a close button
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leaf: No collapsing, no arrow (use as a convenience for leaf nodes).
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        open_on_arrow: Only open when clicking on the arrow part.
            If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
            single-click arrow or double-click all box to open.
        open_on_double_click: Need double-click to open node
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], closable : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", leaf : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, open_on_arrow : bool = False, open_on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bullet: Display a bullet instead of arrow.
            IMPORTANT: node can still be marked open/close if
            you don't set the _Leaf flag!
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closable: Display a close button
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leaf: No collapsing, no arrow (use as a convenience for leaf nodes).
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        open_on_arrow: Only open when clicking on the arrow part.
            If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
            single-click arrow or double-click all box to open.
        open_on_double_click: Need double-click to open node
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> CollapsingHeader:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def bullet(self) -> bool:
        """
        Writable attribute: Display a bullet instead of arrow.
        IMPORTANT: node can still be marked open/close if
        you don't set the _Leaf flag!
        
        """
        ...


    @bullet.setter
    def bullet(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def closable(self) -> bool:
        """
        Writable attribute: Display a close button
        
        """
        ...


    @closable.setter
    def closable(self, value : bool):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def leaf(self) -> bool:
        """
        Writable attribute: No collapsing, no arrow (use as a convenience for leaf nodes).
        
        """
        ...


    @leaf.setter
    def leaf(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def open_on_arrow(self) -> bool:
        """
        Writable attribute:  Only open when clicking on the arrow part.
        If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
        single-click arrow or double-click all box to open.
        
        """
        ...


    @open_on_arrow.setter
    def open_on_arrow(self, value : bool):
        ...


    @property
    def open_on_double_click(self) -> bool:
        """
        Writable attribute: Need double-click to open node
        
        """
        ...


    @open_on_double_click.setter
    def open_on_double_click(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ColorButton(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_border : bool = False, no_drag_drop : bool = False, no_newline : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedColor = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : int = 0, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_border: disable the default border
        no_drag_drop: disable drag and drop source
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_border : bool = False, no_drag_drop : bool = False, no_newline : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedColor = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : int = 0, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_border: disable the default border
        no_drag_drop: disable drag and drop source
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ColorButton:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_alpha(self) -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        
        """
        ...


    @no_alpha.setter
    def no_alpha(self, value : bool):
        ...


    @property
    def no_border(self) -> bool:
        """
        Writable attribute: disable the default border
        
        """
        ...


    @no_border.setter
    def no_border(self, value : bool):
        ...


    @property
    def no_drag_drop(self) -> bool:
        """
        Writable attribute: disable drag and drop source
        
        """
        ...


    @no_drag_drop.setter
    def no_drag_drop(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedColor:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedColor):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> int:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : int):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ColorEdit(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_drag_drop : bool = False, no_inputs : bool = False, no_label : bool = False, no_newline : bool = False, no_options : bool = False, no_picker : bool = False, no_scaling : bool = False, no_small_preview : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedColor = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : int = 0, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_drag_drop: disable drag and drop target
        no_inputs: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        no_label: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_options: disable toggling options menu when right-clicking on inputs/small preview.
        no_picker: disable picker when clicking on color square.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_small_preview: disable color square preview next to the inputs. (e.g. to show only the inputs)
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_drag_drop : bool = False, no_inputs : bool = False, no_label : bool = False, no_newline : bool = False, no_options : bool = False, no_picker : bool = False, no_scaling : bool = False, no_small_preview : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedColor = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : int = 0, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_drag_drop: disable drag and drop target
        no_inputs: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        no_label: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_options: disable toggling options menu when right-clicking on inputs/small preview.
        no_picker: disable picker when clicking on color square.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_small_preview: disable color square preview next to the inputs. (e.g. to show only the inputs)
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ColorEdit:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_alpha(self) -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        
        """
        ...


    @no_alpha.setter
    def no_alpha(self, value : bool):
        ...


    @property
    def no_drag_drop(self) -> bool:
        """
        Writable attribute: disable drag and drop target
        
        """
        ...


    @no_drag_drop.setter
    def no_drag_drop(self, value : bool):
        ...


    @property
    def no_inputs(self) -> bool:
        """
        Writable attribute: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        
        """
        ...


    @no_inputs.setter
    def no_inputs(self, value : bool):
        ...


    @property
    def no_label(self) -> bool:
        """
        Writable attribute: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        
        """
        ...


    @no_label.setter
    def no_label(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_options(self) -> bool:
        """
        Writable attribute: disable toggling options menu when right-clicking on inputs/small preview.
        
        """
        ...


    @no_options.setter
    def no_options(self, value : bool):
        ...


    @property
    def no_picker(self) -> bool:
        """
        Writable attribute: disable picker when clicking on color square.
        
        """
        ...


    @no_picker.setter
    def no_picker(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_small_preview(self) -> bool:
        """
        Writable attribute: disable color square preview next to the inputs. (e.g. to show only the inputs)
        
        """
        ...


    @no_small_preview.setter
    def no_small_preview(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedColor:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedColor):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> int:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : int):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ColorPicker(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_inputs : bool = False, no_label : bool = False, no_newline : bool = False, no_scaling : bool = False, no_side_preview : bool = False, no_small_preview : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedColor = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : int = 0, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_inputs: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        no_label: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_side_preview: disable bigger color preview on right side of the picker, use small color square preview instead.
        no_small_preview: disable color square preview next to the inputs. (e.g. to show only the inputs)
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_inputs : bool = False, no_label : bool = False, no_newline : bool = False, no_scaling : bool = False, no_side_preview : bool = False, no_small_preview : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedColor = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : int = 0, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_inputs: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        no_label: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_side_preview: disable bigger color preview on right side of the picker, use small color square preview instead.
        no_small_preview: disable color square preview next to the inputs. (e.g. to show only the inputs)
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ColorPicker:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_alpha(self) -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        
        """
        ...


    @no_alpha.setter
    def no_alpha(self, value : bool):
        ...


    @property
    def no_inputs(self) -> bool:
        """
        Writable attribute: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        
        """
        ...


    @no_inputs.setter
    def no_inputs(self, value : bool):
        ...


    @property
    def no_label(self) -> bool:
        """
        Writable attribute: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        
        """
        ...


    @no_label.setter
    def no_label(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_side_preview(self) -> bool:
        """
        Writable attribute: disable bigger color preview on right side of the picker, use small color square preview instead.
        
        """
        ...


    @no_side_preview.setter
    def no_side_preview(self, value : bool):
        ...


    @property
    def no_small_preview(self) -> bool:
        """
        Writable attribute: disable color square preview next to the inputs. (e.g. to show only the inputs)
        
        """
        ...


    @no_small_preview.setter
    def no_small_preview(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedColor:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedColor):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> int:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : int):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Combo(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, fit_width : bool = False, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, height_mode : str = "regular", indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_arrow_button : bool = False, no_newline : bool = False, no_preview : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, popup_align_left : bool = False, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedStr = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : str = "", width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        fit_width: Whether the combo should fit available width
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        height_mode: height mode of the combo.
            Supported values are
            "small"
            "regular"
            "large"
            "largest"
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_arrow_button: Whether the combo should not display an arrow on top
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_preview: Whether the preview should be disabled
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        popup_align_left: Whether to align left
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, fit_width : bool = False, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, height_mode : str = "regular", indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_arrow_button : bool = False, no_newline : bool = False, no_preview : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, popup_align_left : bool = False, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedStr = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : str = "", width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        fit_width: Whether the combo should fit available width
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        height_mode: height mode of the combo.
            Supported values are
            "small"
            "regular"
            "large"
            "largest"
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_arrow_button: Whether the combo should not display an arrow on top
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_preview: Whether the preview should be disabled
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        popup_align_left: Whether to align left
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Combo:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def fit_width(self) -> bool:
        """
        Writable attribute: Whether the combo should fit available width
        
        """
        ...


    @fit_width.setter
    def fit_width(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def height_mode(self) -> str:
        """
        Writable attribute: height mode of the combo.
        Supported values are
        "small"
        "regular"
        "large"
        "largest"
        
        """
        ...


    @height_mode.setter
    def height_mode(self, value : str):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def items(self) -> list:
        """
        Writable attribute: List of text values to select
        
        """
        ...


    @items.setter
    def items(self, value : list):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_arrow_button(self) -> bool:
        """
        Writable attribute: Whether the combo should not display an arrow on top
        
        """
        ...


    @no_arrow_button.setter
    def no_arrow_button(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_preview(self) -> bool:
        """
        Writable attribute: Whether the preview should be disabled
        
        """
        ...


    @no_preview.setter
    def no_preview(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def popup_align_left(self) -> bool:
        """
        Writable attribute: Whether to align left
        
        """
        ...


    @popup_align_left.setter
    def popup_align_left(self, value : bool):
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ConditionalHandler(baseHandler):
    """
    A handler that runs the FIRST handler child if all other handler children conditions are met.

    Unlike HandlerList, this handler:
    1. Only executes the first handler when conditions are met
    2. Uses other handlers only for condition checking (their callbacks are not called)

    One interest of this handler is to tests conditions immediately, rather than in a callback,
    avoiding timing issues with callback queues

    Useful for combining conditions, such as detecting clicks when specific keys are pressed.

    Skipping heavy CustomHandlers:
        One use case is to skip expensive run() calls from CustomHandlers.

    Note:
        Only the first handler's callback is executed when all conditions are met.
        Other handlers are used purely for their state conditions.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ConditionalHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> list[baseHandler]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseHandler]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ContentResizeHandler(baseHandler):
    """
    Handler for item containers (windows, etc)
    that triggers the callback
    whenever the item's content region box (the
    area available to the children) changes size.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ContentResizeHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Context(object):
    """
Main class managing the DearCyGui items and imgui context.

    The Context class serves as the central manager for the DearCyGui application, handling:
    - GUI rendering and event processing
    - Item creation and lifecycle management
    - Thread-safe callback execution
    - Global viewport management
    - ImGui/ImPlot/ImNodes context management

    There is exactly one viewport per context. The last created context can be accessed 
    as dearcygui.C.

    Attributes
    ----------
    queue : Executor
        Executor for managing thread-pooled callbacks. Defaults to ThreadPoolExecutor with max_workers=1.
    
    item_creation_callback : callable, optional
        Callback function called when any new item is created, before configuration.
        Signature: func(item)
    
    item_unused_configure_args_callback : callable, optional  
        Callback function called when unused configuration arguments are found.
        Signature: func(item, unused_args_dict)
    
    item_deletion_callback : callable, optional
        Callback function called when any item is deleted.
        Signature: func(item)
        Note: May not be called if item is garbage collected without holding context reference.

    viewport : Viewport
        Root item from where rendering starts. Read-only attribute.

    running : bool
        Whether the context is currently running and processing frames.
        
    clipboard : str
        Content of the system clipboard. Can be read/written.

    Implementation Notes
    -------------------
    - Thread safety is achieved through recursive mutexes on items and ImGui context
    - Callbacks are executed in a separate thread pool to prevent blocking the render loop
    - References between items form a tree structure with viewport as root
    - ImGui/ImPlot/ImNodes contexts are managed to support multiple contexts
    
    """
    def fetch_parent_queue_back(self):
        """
        Retrieve the last item from the potential parent list.

        Returns:
        object
            The last item from the potential parent list.
        
        """
        ...


    def fetch_parent_queue_front(self):
        """
        Retrieve the top item from the potential parent list.

        Returns:
        object
            The top item from the potential parent list.
        
        """
        ...


    def get_mouse_clicked_count(self, button):
        """
        Get the number of times a mouse button is clicked in a row.

        Parameters:
        button : MouseButton
            Mouse button constant.

        Returns:
        int
            Number of times the mouse button is clicked in a row.
        
        """
        ...


    def get_mouse_drag_delta(self, button, lock_threshold=-1.0):
        """
        Return the delta (dx, dy) from the initial clicking position while the mouse button is pressed or was just released.

        Parameters:
        button : MouseButton
            Mouse button constant.
        lock_threshold : float, optional
            Distance threshold for locking the drag. Uses default distance if lock_threshold < 0.0f. Defaults to -1.

        Returns:
        tuple
            Tuple containing the drag delta (dx, dy).
        
        """
        ...


    def get_mouse_position(self):
        """
        Retrieve the mouse position (x, y).

        Returns:
        tuple
            Coord containing the mouse position (x, y).

        Raises:
        KeyError
            If there is no mouse.
        
        """
        ...


    def is_key_down(self, key: 'Key', keymod: 'KeyMod' = None):
        """
        Check if a key is being held down.

        Parameters:
        key : Key
            Key constant.
        keymod : KeyMod, optional
            Key modifier mask (ctrl, shift, alt, super). If None, ignores any key modifiers.

        Returns:
        bool
            True if the key is down, False otherwise.
        
        """
        ...


    def is_key_pressed(self, key: 'Key', keymod: 'KeyMod' = None, repeat=True):
        """
        Check if a key was pressed (went from !Down to Down).

        Parameters:
        key : Key
            Key constant.
        keymod : KeyMod, optional
            Key modifier mask (ctrl, shift, alt, super). If None, ignores any key modifiers.
        repeat : bool, optional
            If True, the pressed state is repeated if the user continues pressing the key. Defaults to True.

        Returns:
        bool
            True if the key was pressed, False otherwise.
        
        """
        ...


    def is_key_released(self, key: 'Key', keymod: 'KeyMod' = None):
        """
        Check if a key was released (went from Down to !Down).

        Parameters:
        key : Key
            Key constant.
        keymod : KeyMod, optional
            Key modifier mask (ctrl, shift, alt, super). If None, ignores any key modifiers.

        Returns:
        bool
            True if the key was released, False otherwise.
        
        """
        ...


    def is_mouse_clicked(self, button, repeat=False):
        """
        Check if a mouse button was clicked (went from !Down to Down).

        Parameters:
        button : MouseButton
            Mouse button constant.
        repeat : bool, optional
            If True, the clicked state is repeated if the user continues pressing the button. Defaults to False.

        Returns:
        bool
            True if the mouse button was clicked, False otherwise.
        
        """
        ...


    def is_mouse_double_clicked(self, button):
        """
        Check if a mouse button was double-clicked.

        Parameters:
        button : MouseButton
            Mouse button constant.

        Returns:
        bool
            True if the mouse button was double-clicked, False otherwise.
        
        """
        ...


    def is_mouse_down(self, button):
        """
        Check if a mouse button is held down.

        Parameters:
        button : MouseButton
            Mouse button constant.

        Returns:
        bool
            True if the mouse button is down, False otherwise.
        
        """
        ...


    def is_mouse_dragging(self, button, lock_threshold=-1.0):
        """
        Check if the mouse is dragging.

        Parameters:
        button : MouseButton
            Mouse button constant.
        lock_threshold : float, optional
            Distance threshold for locking the drag. Uses default distance if lock_threshold < 0.0f. Defaults to -1.

        Returns:
        bool
            True if the mouse is dragging, False otherwise.
        
        """
        ...


    def is_mouse_released(self, button):
        """
        Check if a mouse button was released (went from Down to !Down).

        Parameters:
        button : MouseButton
            Mouse button constant.

        Returns:
        bool
            True if the mouse button was released, False otherwise.
        
        """
        ...


    def pop_next_parent(self):
        """
        Remove an item from the potential parent list.
        
        """
        ...


    def push_next_parent(self, next_parent):
        """
        Each time 'with' is used on an item, it is pushed
        to the list of potential parents to use if
        no parent (or before) is set when an item is created.
        If the list is empty, items are left unattached and
        can be attached later.

        In order to enable multiple threads to use
        the 'with' syntax, thread local storage is used,
        such that each thread has its own list.
        
        """
        ...


    def reset_mouse_drag_delta(self, button):
        """
        Reset the drag delta for the target button to 0.

        Parameters:
        button : MouseButton
            Mouse button constant.
        
        """
        ...


    @property
    def clipboard(self) -> str:
        """Content of the system clipboard.

        The clipboard can be read and written to interact with the system clipboard.
        Reading returns an empty string if the viewport is not yet initialized.

        Returns
        -------
        str
            Current content of the system clipboard
        
        """
        ...


    @clipboard.setter
    def clipboard(self, value : str):
        ...


    @property
    def item_creation_callback(self):
        """
        Callback called during item creation before configuration.
        
        """
        ...


    @property
    def item_deletion_callback(self):
        """
        Callback called during item deletion.

        If the item is released by the garbage collector, it is not guaranteed that
        this callback is called, as the item might have lost its
        pointer on the context.
        
        """
        ...


    @property
    def item_unused_configure_args_callback(self):
        """
        Callback called during item creation before configuration.
        
        """
        ...


    @property
    def running(self) -> bool:
        """Whether the context is currently running and processing frames.
        
        Returns
        -------
        bool
            True if the context is running, False otherwise.
        
        """
        ...


    @running.setter
    def running(self, value : bool):
        ...


    @property
    def viewport(self) -> Viewport:
        """
        Readonly attribute: root item from where rendering starts.
        
        """
        ...


class CustomHandler(baseHandler):
    """
    A base class to be subclassed in python for custom state checking.

    This class provides a framework for implementing custom handlers that can monitor
    and respond to specific item states. As this is called every frame rendered,
    and locks the GIL, be careful not to perform anything computationally heavy.

    Required Methods:
        check_can_bind(self, item): 
            Must return a boolean indicating if this handler can be bound to the target item.
            Use isinstance() to check item types.
        
        check_status(self, item):
            Must return a boolean indicating if the watched condition is met.
            Should only check state, not perform actions.
        
        run(self, item) (Optional):
            If implemented, handles the response when conditions are met.
            Even with run() implemented, check_status() is still required.

    Warning:
        DO NOT modify item parent/sibling/child relationships during rendering.
        Changes to values or status are allowed except for parent modifications.
        For tree structure changes, delay until outside render_frame() or queue 
        for execution in another thread.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> CustomHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DPGCallback(Callback):
    """
    Used to run callbacks created for DPG.
    
    """
    def __init__(self, callback : DCGCallable):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


class DeactivatedAfterEditHandler(baseHandler):
    """
    However for editable items when the item loses
    activation after having been edited.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DeactivatedAfterEditHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DeactivatedHandler(baseHandler):
    """
    Handler for when an active item loses activation.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DeactivatedHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DoubleClickedHandler(baseHandler):
    """
    Handler for when a hovered item is double clicked on.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DoubleClickedHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DraggedHandler(baseHandler):
    """
    Same as DraggingHandler, but only
    triggers the callback when the dragging
    has ended, instead of every frame during
    the dragging.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DraggedHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DraggingHandler(baseHandler):
    """
    Handler to catch when the item is hovered
    and the mouse is dragging (click + motion) ?
    Note that if the item is not a button configured
    to catch the target button, it will not be
    considered being dragged as soon as it is not
    hovered anymore.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DraggingHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawArrow(drawingItem):
    """
    Draws an arrow in coordinate space.

    The arrow consists of a line with a triangle at one end.

    Attributes:
        p1 (tuple): End point coordinates (x, y) 
        p2 (tuple): Start point coordinates (x, y)
        color (list): RGBA color of the arrow
        thickness (float): Line thickness
        size (float): Size of the arrow head
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, size : float = 4.0, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, size : float = 4.0, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawArrow:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> Coord:
        ...


    @p1.setter
    def p1(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p2(self) -> Coord:
        ...


    @p2.setter
    def p2(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def size(self) -> float:
        ...


    @size.setter
    def size(self, value : float):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawBezierCubic(drawingItem):
    """
    Draws a cubic Bezier curve in coordinate space.

    The curve is defined by four control points.

    Attributes:
        p1 (tuple): First control point coordinates (x, y)
        p2 (tuple): Second control point coordinates (x, y)
        p3 (tuple): Third control point coordinates (x, y)
        p4 (tuple): Fourth control point coordinates (x, y)
        color (list): RGBA color of the curve
        thickness (float): Line thickness
        segments (int): Number of line segments used to approximate the curve
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p4 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, thickness : float = 0.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p4 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, thickness : float = 0.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawBezierCubic:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> Coord:
        ...


    @p1.setter
    def p1(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p2(self) -> Coord:
        ...


    @p2.setter
    def p2(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p3(self) -> Coord:
        ...


    @p3.setter
    def p3(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p4(self) -> Coord:
        ...


    @p4.setter
    def p4(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def segments(self) -> int:
        ...


    @segments.setter
    def segments(self, value : int):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawBezierQuadratic(drawingItem):
    """
    Draws a quadratic Bezier curve in coordinate space.

    The curve is defined by three control points.

    Attributes:
        p1 (tuple): First control point coordinates (x, y)
        p2 (tuple): Second control point coordinates (x, y)
        p3 (tuple): Third control point coordinates (x, y)
        color (list): RGBA color of the curve
        thickness (float): Line thickness
        segments (int): Number of line segments used to approximate the curve
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, thickness : float = 0.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, thickness : float = 0.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawBezierQuadratic:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> Coord:
        ...


    @p1.setter
    def p1(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p2(self) -> Coord:
        ...


    @p2.setter
    def p2(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p3(self) -> Coord:
        ...


    @p3.setter
    def p3(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def segments(self) -> int:
        ...


    @segments.setter
    def segments(self, value : int):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawCircle(drawingItem):
    """
    Draws a circle in coordinate space.

    The circle can be filled and/or outlined.

    Attributes:
        center (tuple): Center coordinates (x, y)
        radius (float): Circle radius
        color (list): RGBA color of the outline
        fill (list): RGBA color of the fill
        thickness (float): Outline thickness
        segments (int): Number of segments used to approximate the circle
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : float = 1.0, segments : int = 0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : float = 1.0, segments : int = 0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawCircle:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def center(self) -> Coord:
        ...


    @center.setter
    def center(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> Color:
        ...


    @fill.setter
    def fill(self, value : Color):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def radius(self) -> float:
        ...


    @radius.setter
    def radius(self, value : float):
        ...


    @property
    def segments(self) -> int:
        ...


    @segments.setter
    def segments(self, value : int):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawEllipse(drawingItem):
    """
    Draws an ellipse in coordinate space.

    The ellipse is defined by its bounding box and can be filled and/or outlined.

    Attributes:
        pmin (tuple): Top-left corner coordinates (x, y)
        pmax (tuple): Bottom-right corner coordinates (x, y)
        color (list): RGBA color of the outline
        fill (list): RGBA color of the fill
        thickness (float): Outline thickness
        segments (int): Number of segments used to approximate the ellipse
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pmin : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        pmax: Bottom-right corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        pmin: Top-left corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        segments: Number of segments used to approximate the ellipse.
            
            Returns:
                int: Number of segments
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pmin : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        pmax: Bottom-right corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        pmin: Top-left corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        segments: Number of segments used to approximate the ellipse.
            
            Returns:
                int: Number of segments
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawEllipse:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        """
        Color of the drawing outline.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> Color:
        """
        Fill color of the drawing.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill.setter
    def fill(self, value : Color):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pmax(self) -> Coord:
        """
        Bottom-right corner position of the drawing in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @pmax.setter
    def pmax(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pmin(self) -> Coord:
        """
        Top-left corner position of the drawing in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @pmin.setter
    def pmin(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def segments(self) -> int:
        """
        Number of segments used to approximate the ellipse.
        
        Returns:
            int: Number of segments
        
        """
        ...


    @segments.setter
    def segments(self, value : int):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        """
        Line thickness of the drawing outline.
        
        Returns:
            float: Thickness value in pixels
        
        """
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawImage(drawingItem):
    """
    Draw an image in coordinate space.

    DrawImage supports three ways to express its position in space:
    - p1, p2, p3, p4, the positions of the corners of the image, in
       a clockwise order
    - pmin and pmax, where pmin = p1, and pmax = p3, and p2/p4
        are automatically set such that the image is parallel
        to the axes.
    - center, direction, width, height for the coordinate of the center,
        the angle of (center, middle of p2 and p3) against the x horizontal axis,
        and the width/height of the image at direction 0.

    uv1/uv2/uv3/uv4 are the normalized texture coordinates at p1/p2/p3/p4

    The systems are similar, but writing to p1/p2/p3/p4 is more expressive
    as it allows to have non-rectangular shapes.
    The last system enables to indicate a size in screen space rather
    than in coordinate space by passing negative values to width and height.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], direction : float = 0.0, height : float = 0.0, next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p4 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pmin : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, rounding : float = 0.0, show : bool = True, texture : Texture | None = None, user_data : Any = ..., uv1 : list = [0.0, 0.0], uv2 : list = [1.0, 0.0], uv3 : list = [1.0, 1.0], uv4 : list = [0.0, 1.0], uv_max : list = [1.0, 1.0], uv_min : list = [0.0, 0.0], width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        center: Center of pmin/pmax
            
            Returns:
                tuple: (x, y) coordinates
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color_multiplier: The image is mixed with this color.
            
            Returns:
                list: RGBA values in [0,1] range
        direction: Angle of (center, middle of p2/p3) with the horizontal axis
            
            Returns:
                float: Angle in radians
        height: Height of the shape. Negative means screen space.
            
            Returns:
                float: Height value
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        p1: Top left corner
            
            Returns:
                tuple: (x, y) coordinates
        p2: Top right corner
            
            Returns:
                tuple: (x, y) coordinates
        p3: Bottom right corner
            
            Returns:
                tuple: (x, y) coordinates
        p4: 
            Bottom left corner
            
            Returns:
                tuple: (x, y) coordinates
        parent: parent of the item in the rendering tree.
        pmax: Bottom-right corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        pmin: Top-left corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        rounding: Rounding of the corners of the shape.
            
            If non-zero, the renderered image will be rectangular
            and parallel to the axes.
            (p1/p2/p3/p4 will behave like pmin/pmax)
            
            Returns:
                float: Rounding radius
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        texture: Image content
        user_data: User data of any type.
        uv1: Texture coordinate for p1
            
            Returns:
                list: UV coordinates
        uv2: Texture coordinate for p2
            
            Returns:
                list: UV coordinates
        uv3: Texture coordinate for p3
            
            Returns:
                list: UV coordinates
        uv4: Texture coordinate for p4
            
            Returns:
                list: UV coordinates
        uv_max: Texture coordinate for pmax. Writes to uv2/3/4.
            
            Returns:
                list: UV coordinates
        uv_min: Texture coordinate for pmin. Writes to uv1/2/4.
            
            Returns:
                list: UV coordinates
        width: Width of the shape. Negative means screen space.
            
            Returns:
                float: Width value
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], direction : float = 0.0, height : float = 0.0, next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p4 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pmin : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, rounding : float = 0.0, show : bool = True, texture : Texture | None = None, user_data : Any = ..., uv1 : list = [0.0, 0.0], uv2 : list = [1.0, 0.0], uv3 : list = [1.0, 1.0], uv4 : list = [0.0, 1.0], uv_max : list = [1.0, 1.0], uv_min : list = [0.0, 0.0], width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        center: Center of pmin/pmax
            
            Returns:
                tuple: (x, y) coordinates
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color_multiplier: The image is mixed with this color.
            
            Returns:
                list: RGBA values in [0,1] range
        direction: Angle of (center, middle of p2/p3) with the horizontal axis
            
            Returns:
                float: Angle in radians
        height: Height of the shape. Negative means screen space.
            
            Returns:
                float: Height value
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        p1: Top left corner
            
            Returns:
                tuple: (x, y) coordinates
        p2: Top right corner
            
            Returns:
                tuple: (x, y) coordinates
        p3: Bottom right corner
            
            Returns:
                tuple: (x, y) coordinates
        p4: 
            Bottom left corner
            
            Returns:
                tuple: (x, y) coordinates
        parent: parent of the item in the rendering tree.
        pmax: Bottom-right corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        pmin: Top-left corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        rounding: Rounding of the corners of the shape.
            
            If non-zero, the renderered image will be rectangular
            and parallel to the axes.
            (p1/p2/p3/p4 will behave like pmin/pmax)
            
            Returns:
                float: Rounding radius
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        texture: Image content
        user_data: User data of any type.
        uv1: Texture coordinate for p1
            
            Returns:
                list: UV coordinates
        uv2: Texture coordinate for p2
            
            Returns:
                list: UV coordinates
        uv3: Texture coordinate for p3
            
            Returns:
                list: UV coordinates
        uv4: Texture coordinate for p4
            
            Returns:
                list: UV coordinates
        uv_max: Texture coordinate for pmax. Writes to uv2/3/4.
            
            Returns:
                list: UV coordinates
        uv_min: Texture coordinate for pmin. Writes to uv1/2/4.
            
            Returns:
                list: UV coordinates
        width: Width of the shape. Negative means screen space.
            
            Returns:
                float: Width value
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawImage:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def center(self) -> Coord:
        """
        Center of pmin/pmax
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @center.setter
    def center(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color_multiplier(self) -> list:
        """
        The image is mixed with this color.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color_multiplier.setter
    def color_multiplier(self, value : list):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def direction(self) -> float:
        """
        Angle of (center, middle of p2/p3) with the horizontal axis
        
        Returns:
            float: Angle in radians
        
        """
        ...


    @direction.setter
    def direction(self, value : float):
        ...


    @property
    def height(self) -> float:
        """
        Height of the shape. Negative means screen space.
        
        Returns:
            float: Height value
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> Coord:
        """
        Top left corner
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p1.setter
    def p1(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p2(self) -> Coord:
        """
        Top right corner
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p2.setter
    def p2(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p3(self) -> Coord:
        """
        Bottom right corner
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p3.setter
    def p3(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p4(self) -> Coord:
        """
 
        Bottom left corner
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p4.setter
    def p4(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pmax(self) -> Coord:
        """
        Bottom-right corner position of the drawing in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @pmax.setter
    def pmax(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pmin(self) -> Coord:
        """
        Top-left corner position of the drawing in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @pmin.setter
    def pmin(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rounding(self) -> float:
        """
        Rounding of the corners of the shape.
        
        If non-zero, the renderered image will be rectangular
        and parallel to the axes.
        (p1/p2/p3/p4 will behave like pmin/pmax)
        
        Returns:
            float: Rounding radius
        
        """
        ...


    @rounding.setter
    def rounding(self, value : float):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def texture(self) -> Texture | None:
        """Image content
        """
        ...


    @texture.setter
    def texture(self, value : Texture | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def uv1(self) -> list:
        """
        Texture coordinate for p1
        
        Returns:
            list: UV coordinates
        
        """
        ...


    @uv1.setter
    def uv1(self, value : list):
        ...


    @property
    def uv2(self) -> list:
        """
        Texture coordinate for p2
        
        Returns:
            list: UV coordinates
        
        """
        ...


    @uv2.setter
    def uv2(self, value : list):
        ...


    @property
    def uv3(self) -> list:
        """
        Texture coordinate for p3
        
        Returns:
            list: UV coordinates
        
        """
        ...


    @uv3.setter
    def uv3(self, value : list):
        ...


    @property
    def uv4(self) -> list:
        """
        Texture coordinate for p4
        
        Returns:
            list: UV coordinates
        
        """
        ...


    @uv4.setter
    def uv4(self, value : list):
        ...


    @property
    def uv_max(self) -> list:
        """
        Texture coordinate for pmax. Writes to uv2/3/4.
        
        Returns:
            list: UV coordinates
        
        """
        ...


    @uv_max.setter
    def uv_max(self, value : list):
        ...


    @property
    def uv_min(self) -> list:
        """
        Texture coordinate for pmin. Writes to uv1/2/4.
        
        Returns:
            list: UV coordinates
        
        """
        ...


    @uv_min.setter
    def uv_min(self, value : list):
        ...


    @property
    def width(self) -> float:
        """
        Width of the shape. Negative means screen space.
        
        Returns:
            float: Width value
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class DrawInPlot(plotElementWithLegend):
    """
    A plot element that enables to insert Draw* items
    inside a plot in plot coordinates.

    defaults to no_legend = True
    
    """
    def __init__(self, context : Context, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[drawingItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = True, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[drawingItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = True, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawInPlot:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawInWindow(uiItem):
    """
    An UI item that contains a region for Draw* elements.
    Enables to insert Draw* Elements inside a window.

    Inside a DrawInWindow elements, the (0, 0) coordinate
    starts at the top left of the DrawWindow and y increases
    when going down.
    The drawing region is clipped by the available width/height
    of the item (set manually, or deduced).

    An invisible button is created to span the entire drawing
    area, which is used to retrieve button states on the area
    (hovering, active, etc). If set, the callback is called when
    the mouse is pressed inside the area with any of the left,
    middle or right button.
    In addition, the use of an invisible button enables the drag
    and drop behaviour proposed by imgui.

    If you intend on dragging elements inside the drawing area,
    you can either implement yourself a hovering test for your
    specific items and use the context's is_mouse_dragging, or
    add invisible buttons on top of the elements you want to
    interact with, and combine the active and mouse dragging
    handlers. Note if you intend to make an element draggable
    that way, you must not make the element source of a Drag
    and Drop, as it impacts the hovering tests.

    Note that Drawing items do not have any hovering/clicked/
    visible/etc tests maintained and thus do not have a callback.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[drawingItem] = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[drawingItem] = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawInWindow:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class DrawInvisibleButton(drawingItem):
    """
    Invisible rectangular area, parallel to axes, behaving
    like a button (using imgui default handling of buttons).

    Unlike other Draw items, this item accepts handlers and callbacks.

    DrawInvisibleButton can be overlapped on top of each other. In that
    case only one will be considered hovered. This one corresponds to the
    last one of the rendering tree that is hovered. If the button is
    considered active (see below), it retains the hover status to itself.
    Thus if you drag an invisible button on top of items later in the
    rendering tree, they will not be considered hovered.

    Note that only the mouse button(s) that trigger activation will
    have the above described behaviour for hover tests. If the mouse
    doesn't hover anymore the item, it will remain active as long
    as the configured buttons are pressed.

    When inside a plot, drag deltas are returned in plot coordinates,
    that is the deltas correspond to the deltas you must apply
    to your drawing coordinates compared to their original position
    to apply the dragging. When not in a plot, the drag deltas are
    in screen coordinates, and you must convert yourself to drawing
    coordinates if you are applying matrix transforms to your data.
    Generally matrix transforms are not well supported by
    DrawInvisibleButtons, and the shifted position that is updated
    during dragging might be invalid.

    Dragging handlers will not be triggered if the item is not active
    (unlike normal imgui items).

    If you create a DrawInvisibleButton in front of the mouse while
    the mouse is clicked with one of the activation buttons, it will
    steal hovering and activation tests. This is not the case of other
    gui items (except modal windows).

    If your Draw Button is not part of a window (ViewportDrawList),
    the hovering test might not be reliable (except specific case above).

    DrawInvisibleButton accepts children. In that case, the children
    are drawn relative to the coordinates of the DrawInvisibleButton,
    where top left is (0, 0) and bottom right is (1, 1).
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : Any = ..., capture_mouse : bool = True, children : list[drawingItem] = [], handlers : list = [], max_side : float = inf, min_side : float = 0.0, next_sibling : baseItem | None = None, no_input : bool = False, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        button: Mouse button mask that makes the invisible button
            active and triggers the item's callback.
        capture_mouse: If set, the item will
            capture the mouse if hovered even if another
            item was already active.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        max_side: If the rectangle width or height after
            coordinate transform is higher than this,
            resize the screen space transformed coordinates
            such that the width/height are at max max_side.
            Retains original ratio.
        min_side: If the rectangle width or height after
            coordinate transform is lower than this,
            resize the screen space transformed coordinates
            such that the width/height are at least min_side.
            Retains original ratio.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: If enabled, this item will not
            detect hovering or activation, thus letting other
            items taking the inputs.
        p1: Corner of the invisible button in plot/drawing
            space
        p2: Opposite corner of the invisible button in plot/drawing
            space
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : Any = ..., capture_mouse : bool = True, children : list[drawingItem] = [], handlers : list = [], max_side : float = inf, min_side : float = 0.0, next_sibling : baseItem | None = None, no_input : bool = False, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        button: Mouse button mask that makes the invisible button
            active and triggers the item's callback.
        capture_mouse: If set, the item will
            capture the mouse if hovered even if another
            item was already active.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        max_side: If the rectangle width or height after
            coordinate transform is higher than this,
            resize the screen space transformed coordinates
            such that the width/height are at max max_side.
            Retains original ratio.
        min_side: If the rectangle width or height after
            coordinate transform is lower than this,
            resize the screen space transformed coordinates
            such that the width/height are at least min_side.
            Retains original ratio.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: If enabled, this item will not
            detect hovering or activation, thus letting other
            items taking the inputs.
        p1: Corner of the invisible button in plot/drawing
            space
        p2: Opposite corner of the invisible button in plot/drawing
            space
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawInvisibleButton:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the button just been pressed
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the button held
        
        """
        ...


    @property
    def button(self):
        """
        Mouse button mask that makes the invisible button
        active and triggers the item's callback.

        Default is all buttons

        The mask is an (OR) combination of
        1: left button
        2: right button
        4: middle button
        8: X1
        16: X2
        (See also MouseButtonMask)
        
        """
        ...


    @button.setter
    def button(self, value):
        ...


    @property
    def capture_mouse(self) -> bool:
        """
        Writable attribute: If set, the item will
        capture the mouse if hovered even if another
        item was already active.

        As it is not in general a good behaviour (and
        will not behave well if several items with this
        state are overlapping),
        this is reset to False every frame.

        Default is True on creation. Thus creating an item
        in front of the mouse will capture it.
        
        """
        ...


    @capture_mouse.setter
    def capture_mouse(self, value : bool):
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the button just been unpressed
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside area
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def max_side(self) -> float:
        """
        If the rectangle width or height after
        coordinate transform is higher than this,
        resize the screen space transformed coordinates
        such that the width/height are at max max_side.
        Retains original ratio.
        
        """
        ...


    @max_side.setter
    def max_side(self, value : float):
        ...


    @property
    def min_side(self) -> float:
        """
        If the rectangle width or height after
        coordinate transform is lower than this,
        resize the screen space transformed coordinates
        such that the width/height are at least min_side.
        Retains original ratio.
        
        """
        ...


    @min_side.setter
    def min_side(self, value : float):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_input(self) -> bool:
        """
        Writable attribute: If enabled, this item will not
        detect hovering or activation, thus letting other
        items taking the inputs.

        This is useful to use no_input - rather than show=False,
        if you want to still have handlers run if the item
        is in the visible region.
        
        """
        ...


    @no_input.setter
    def no_input(self, value : bool):
        ...


    @property
    def p1(self) -> Coord:
        """
        Corner of the invisible button in plot/drawing
        space
        
        """
        ...


    @p1.setter
    def p1(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p2(self) -> Coord:
        """
        Opposite corner of the invisible button in plot/drawing
        space
        
        """
        ...


    @p2.setter
    def p2(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Readonly attribute:
        Relative position to latest non-drawing parent
        
        """
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Readonly attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.
        
        """
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Readonly attribute:
        Relative position to the window's starting inner
        content area.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) in pixels of the item on screen
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawLine(drawingItem):
    """
    A line segment is coordinate space.

    DrawLine supports two ways to express its position in space:
    - p1 and p2 for the coordinate of its extremities
    - center, direction, length for the coordinate of the center,
        the angle of (center, p2) against the x horizontal axis,
        and the segment length.

    Both systems are equivalent and the related fields are always valid.
    The main difference is that length can be set to a negative value,
    to indicate a length in screen space rather than in coordinate space.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], direction : float = 0.0, length : float = 0.0, next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        direction: Angle (rad) of the line segment relative to the horizontal axis.
            
            Returns:
                float: Angle in radians
        length: Length of the line segment. Negatives mean screen space.
            
            Returns:
                float: Length value
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        p2: Coordinates of one of the extremities of the line segment
            
            Returns:
                tuple: (x, y) coordinates
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], direction : float = 0.0, length : float = 0.0, next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        direction: Angle (rad) of the line segment relative to the horizontal axis.
            
            Returns:
                float: Angle in radians
        length: Length of the line segment. Negatives mean screen space.
            
            Returns:
                float: Length value
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        p2: Coordinates of one of the extremities of the line segment
            
            Returns:
                tuple: (x, y) coordinates
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawLine:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def center(self) -> Coord:
        ...


    @center.setter
    def center(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def direction(self) -> float:
        """
        Angle (rad) of the line segment relative to the horizontal axis.
        
        Returns:
            float: Angle in radians
        
        """
        ...


    @direction.setter
    def direction(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def length(self) -> float:
        """
        Length of the line segment. Negatives mean screen space.
        
        Returns:
            float: Length value
        
        """
        ...


    @length.setter
    def length(self, value : float):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> Coord:
        ...


    @p1.setter
    def p1(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p2(self) -> Coord:
        """
        Coordinates of one of the extremities of the line segment
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p2.setter
    def p2(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawPolygon(drawingItem):
    """
    Draws a filled polygon in coordinate space.

    The polygon is defined by a sequence of points that form its vertices.
    Can be filled and/or outlined. Non-convex polygons are automatically
    triangulated for proper filling.

    Attributes:
        points (list): List of (x,y) coordinates defining the vertices 
        color (list): RGBA color of the outline
        fill (list): RGBA color of the fill
        thickness (float): Outline thickness
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, points : list = [], previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        points: List of vertex positions defining the shape.
            
            Returns:
                list: List of (x,y) coordinate tuples
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, points : list = [], previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        points: List of vertex positions defining the shape.
            
            Returns:
                list: List of (x,y) coordinate tuples
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawPolygon:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        """
        Color of the drawing outline.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> Color:
        """
        Fill color of the drawing.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill.setter
    def fill(self, value : Color):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def points(self) -> list:
        """
        List of vertex positions defining the shape.
        
        Returns:
            list: List of (x,y) coordinate tuples
        
        """
        ...


    @points.setter
    def points(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        """
        Line thickness of the drawing outline.
        
        Returns:
            float: Thickness value in pixels
        
        """
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawPolyline(drawingItem):
    """
    Draws a sequence of connected line segments in coordinate space.

    The line segments connect consecutive points in the given sequence.
    Can optionally be closed to form a complete loop.

    Attributes:
        points (list): List of (x,y) coordinates defining the vertices
        color (list): RGBA color of the lines
        thickness (float): Line thickness
        closed (bool): Whether to connect the last point back to the first
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], closed : bool = False, color : Color = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, points : list = [], previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closed: Whether the shape is closed by connecting first and last points.
            
            Returns:
                bool: True if shape is closed
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        points: List of vertex positions defining the shape.
            
            Returns:
                list: List of (x,y) coordinate tuples
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], closed : bool = False, color : Color = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, points : list = [], previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closed: Whether the shape is closed by connecting first and last points.
            
            Returns:
                bool: True if shape is closed
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        points: List of vertex positions defining the shape.
            
            Returns:
                list: List of (x,y) coordinate tuples
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawPolyline:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def closed(self) -> bool:
        """
        Whether the shape is closed by connecting first and last points.
        
        Returns:
            bool: True if shape is closed
        
        """
        ...


    @closed.setter
    def closed(self, value : bool):
        ...


    @property
    def color(self) -> Color:
        """
        Color of the drawing outline.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def points(self) -> list:
        """
        List of vertex positions defining the shape.
        
        Returns:
            list: List of (x,y) coordinate tuples
        
        """
        ...


    @points.setter
    def points(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        """
        Line thickness of the drawing outline.
        
        Returns:
            float: Thickness value in pixels
        
        """
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawQuad(drawingItem):
    """
    Draws a quadrilateral in coordinate space.

    The quad is defined by four corner points in clockwise order.
    Can be filled and/or outlined.

    Attributes:
        p1 (tuple): First corner coordinates (x,y)
        p2 (tuple): Second corner coordinates (x,y)
        p3 (tuple): Third corner coordinates (x,y) 
        p4 (tuple): Fourth corner coordinates (x,y)
        color (list): RGBA color of the outline
        fill (list): RGBA color of the fill
        thickness (float): Outline thickness
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p4 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        p1: First vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p2: Second vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p3: Third vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p4: 
            Fourth vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p4 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        p1: First vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p2: Second vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p3: Third vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p4: 
            Fourth vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawQuad:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        """
        Color of the drawing outline.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> Color:
        """
        Fill color of the drawing.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill.setter
    def fill(self, value : Color):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> Coord:
        """
        First vertex position in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p1.setter
    def p1(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p2(self) -> Coord:
        """
        Second vertex position in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p2.setter
    def p2(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p3(self) -> Coord:
        """
        Third vertex position in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p3.setter
    def p3(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p4(self) -> Coord:
        """
 
        Fourth vertex position in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p4.setter
    def p4(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        """
        Line thickness of the drawing outline.
        
        Returns:
            float: Thickness value in pixels
        
        """
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawRect(drawingItem):
    """
    Draws a rectangle in coordinate space.

    The rectangle is defined by its min/max corners.
    Can be filled with a solid color, a color gradient, and/or outlined.
    Corners can be rounded.

    Attributes:
        pmin (tuple): Top-left corner coordinates (x,y)
        pmax (tuple): Bottom-right corner coordinates (x,y)
        color (list): RGBA color of the outline
        fill (list): RGBA color for solid fill
        fill_p1/p2/p3/p4 (list): RGBA colors for gradient fill at each corner
        thickness (float): Outline thickness
        rounding (float): Radius of rounded corners
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], fill_p1 : list = [0.0, 0.0, 0.0, 0.0], fill_p2 : list = [0.0, 0.0, 0.0, 0.0], fill_p3 : list = [0.0, 0.0, 0.0, 0.0], fill_p4 : list = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : Sequence[float] | tuple[float, float] | Coord = (1.0, 1.0), pmin : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, rounding : float = 0.0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        fill_p1: Fill color at point p1 for gradient fills.
            
            Returns:
                list: RGBA values in [0,1] range
        fill_p2: Fill color at point p2 for gradient fills.
            
            Returns:
                list: RGBA values in [0,1] range
        fill_p3: Fill color at point p3 for gradient fills.
            
            Returns:
                list: RGBA values in [0,1] range
        fill_p4: Fill color at point p4 for gradient fills.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        pmax: Bottom-right corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        pmin: Top-left corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        rounding: Rounding of the corners of the shape.
            
            Returns:
                float: Rounding radius
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], fill_p1 : list = [0.0, 0.0, 0.0, 0.0], fill_p2 : list = [0.0, 0.0, 0.0, 0.0], fill_p3 : list = [0.0, 0.0, 0.0, 0.0], fill_p4 : list = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : Sequence[float] | tuple[float, float] | Coord = (1.0, 1.0), pmin : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, rounding : float = 0.0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        fill_p1: Fill color at point p1 for gradient fills.
            
            Returns:
                list: RGBA values in [0,1] range
        fill_p2: Fill color at point p2 for gradient fills.
            
            Returns:
                list: RGBA values in [0,1] range
        fill_p3: Fill color at point p3 for gradient fills.
            
            Returns:
                list: RGBA values in [0,1] range
        fill_p4: Fill color at point p4 for gradient fills.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        pmax: Bottom-right corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        pmin: Top-left corner position of the drawing in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        rounding: Rounding of the corners of the shape.
            
            Returns:
                float: Rounding radius
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawRect:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        """
        Color of the drawing outline.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> Color:
        """
        Fill color of the drawing.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill.setter
    def fill(self, value : Color):
        ...


    @property
    def fill_p1(self) -> list:
        """
        Fill color at point p1 for gradient fills.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill_p1.setter
    def fill_p1(self, value : list):
        ...


    @property
    def fill_p2(self) -> list:
        """
        Fill color at point p2 for gradient fills.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill_p2.setter
    def fill_p2(self, value : list):
        ...


    @property
    def fill_p3(self) -> list:
        """
        Fill color at point p3 for gradient fills.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill_p3.setter
    def fill_p3(self, value : list):
        ...


    @property
    def fill_p4(self) -> list:
        """
        Fill color at point p4 for gradient fills.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill_p4.setter
    def fill_p4(self, value : list):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pmax(self) -> Coord:
        """
        Bottom-right corner position of the drawing in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @pmax.setter
    def pmax(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pmin(self) -> Coord:
        """
        Top-left corner position of the drawing in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @pmin.setter
    def pmin(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rounding(self) -> float:
        """
        Rounding of the corners of the shape.
        
        Returns:
            float: Rounding radius
        
        """
        ...


    @rounding.setter
    def rounding(self, value : float):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        """
        Line thickness of the drawing outline.
        
        Returns:
            float: Thickness value in pixels
        
        """
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawRegularPolygon(drawingItem):
    """
    Draws a regular polygon with n points

    The polygon is defined by the center,
    the direction of the first point, and
    the radius.

    Radius can be negative to mean screen space.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], direction : float = 0.0, fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, num_points : int = 1, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : float = 0.0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        direction: Angle (rad) of the first point of the shape.
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        num_points: Number of points in the shape.
            num_points=1 gives a circle.
            
            Returns:
                int: Number of points
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        radius: Radius of the shape. Negative means screen space.
            
            Returns:
                float: Radius value
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], direction : float = 0.0, fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, num_points : int = 1, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : float = 0.0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        direction: Angle (rad) of the first point of the shape.
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        num_points: Number of points in the shape.
            num_points=1 gives a circle.
            
            Returns:
                int: Number of points
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        radius: Radius of the shape. Negative means screen space.
            
            Returns:
                float: Radius value
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawRegularPolygon:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def center(self) -> Coord:
        ...


    @center.setter
    def center(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        """
        Color of the drawing outline.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def direction(self) -> float:
        """
        Angle (rad) of the first point of the shape.

        The angle is relative to the horizontal axis.
        
        Returns:
            float: Angle in radians
        
        """
        ...


    @direction.setter
    def direction(self, value : float):
        ...


    @property
    def fill(self) -> Color:
        """
        Fill color of the drawing.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill.setter
    def fill(self, value : Color):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def num_points(self) -> int:
        """
        Number of points in the shape.
        num_points=1 gives a circle.
        
        Returns:
            int: Number of points
        
        """
        ...


    @num_points.setter
    def num_points(self, value : int):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def radius(self) -> float:
        """
        Radius of the shape. Negative means screen space.
        
        Returns:
            float: Radius value
        
        """
        ...


    @radius.setter
    def radius(self, value : float):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        """
        Line thickness of the drawing outline.
        
        Returns:
            float: Thickness value in pixels
        
        """
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawSplitBatch(drawingItem):
    """
    By default the rendering algorithms tries
    to batch drawing primitives together as much
    as possible. It detects when items need to be
    drawn in separate batches (for instance UI rendering,
    or drawing an image), but it is not always enough.

    When you need to force some items to be
    drawn after others, for instance to have a line
    overlap another, this item will force later items
    to be drawn in separate batches to the previous one.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawSplitBatch:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawStar(drawingItem):
    """
    Draws a star shaped polygon with n points
    on the exterior circle.

    The polygon is defined by the center,
    the direction of the first point, the radius
    of the exterior circle and the inner radius.

    Crosses, astrisks, etc can be obtained using
    a radius of 0.

    Radius can be negative to mean screen space.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], direction : float = 0.0, fill : Color = [0.0, 0.0, 0.0, 0.0], inner_radius : float = 0.0, next_sibling : baseItem | None = None, num_points : int = 5, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : float = 0.0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        direction: Angle (rad) of the first point of the shape.
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        inner_radius: Radius of the inner shape.
            
            Returns:
                float: Inner radius value
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        num_points: Number of points in the shape.
            Must be >= 3.
            
            Returns:
                int: Number of points
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        radius: Radius of the shape. Negative means screen space.
            
            Returns:
                float: Radius value
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., center : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], direction : float = 0.0, fill : Color = [0.0, 0.0, 0.0, 0.0], inner_radius : float = 0.0, next_sibling : baseItem | None = None, num_points : int = 5, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : float = 0.0, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        direction: Angle (rad) of the first point of the shape.
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        inner_radius: Radius of the inner shape.
            
            Returns:
                float: Inner radius value
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        num_points: Number of points in the shape.
            Must be >= 3.
            
            Returns:
                int: Number of points
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        radius: Radius of the shape. Negative means screen space.
            
            Returns:
                float: Radius value
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawStar:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def center(self) -> Coord:
        ...


    @center.setter
    def center(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        """
        Color of the drawing outline.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def direction(self) -> float:
        """
        Angle (rad) of the first point of the shape.

        The angle is relative to the horizontal axis.
        
        Returns:
            float: Angle in radians
        
        """
        ...


    @direction.setter
    def direction(self, value : float):
        ...


    @property
    def fill(self) -> Color:
        """
        Fill color of the drawing.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill.setter
    def fill(self, value : Color):
        ...


    @property
    def inner_radius(self) -> float:
        """
        Radius of the inner shape.
        
        Returns:
            float: Inner radius value
        
        """
        ...


    @inner_radius.setter
    def inner_radius(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def num_points(self) -> int:
        """
        Number of points in the shape.
        Must be >= 3.
        
        Returns:
            int: Number of points
        
        """
        ...


    @num_points.setter
    def num_points(self, value : int):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def radius(self) -> float:
        """
        Radius of the shape. Negative means screen space.
        
        Returns:
            float: Radius value
        
        """
        ...


    @radius.setter
    def radius(self, value : float):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        """
        Line thickness of the drawing outline.
        
        Returns:
            float: Thickness value in pixels
        
        """
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawText(drawingItem):
    """
    Draws text in coordinate space.

    The text is positioned at a specific point and can use a custom font and size.
    The size can be specified in coordinate space (positive values) or screen space (negative values).

    Attributes:
        pos (tuple): Position coordinates (x,y) of the text
        text (str): The text string to display
        color (list): RGBA color of the text
        font (Font): Optional custom font to use
        size (float): Text size. Negative means screen space units.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], font : Font = None, next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pos : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, show : bool = True, size : float = 0.0, text : str = "", user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the text.
            
            Returns:
                list: RGBA values in [0,1] range
        font: font used for the text rendered
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        pos: Position of the drawing element in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Text size. Negative means screen space units.
            
            Returns:
                float: Size value
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], font : Font = None, next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pos : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, show : bool = True, size : float = 0.0, text : str = "", user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the text.
            
            Returns:
                list: RGBA values in [0,1] range
        font: font used for the text rendered
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        pos: Position of the drawing element in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Text size. Negative means screen space units.
            
            Returns:
                float: Size value
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawText:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        """
        Color of the text.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos(self) -> Coord:
        """
        Position of the drawing element in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @pos.setter
    def pos(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def size(self) -> float:
        """
        Text size. Negative means screen space units.
        
        Returns:
            float: Size value
        
        """
        ...


    @size.setter
    def size(self, value : float):
        ...


    @property
    def text(self) -> str:
        ...


    @text.setter
    def text(self, value : str):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawTriangle(drawingItem):
    """
    Draws a triangle in coordinate space.

    The triangle is defined by three points.
    Can be filled and/or outlined.

    Attributes:
        p1 (tuple): First vertex coordinates (x,y)
        p2 (tuple): Second vertex coordinates (x,y)
        p3 (tuple): Third vertex coordinates (x,y)
        color (list): RGBA color of the outline
        fill (list): RGBA color of the fill
        thickness (float): Outline thickness 
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        p1: First vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p2: Second vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p3: Third vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], color : Color = [1.0, 1.0, 1.0, 1.0], fill : Color = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, p1 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p2 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), p3 : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, thickness : float = 1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: Color of the drawing outline.
            
            Returns:
                list: RGBA values in [0,1] range
        fill: Fill color of the drawing.
            
            Returns:
                list: RGBA values in [0,1] range
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        p1: First vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p2: Second vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        p3: Third vertex position in coordinate space.
            
            Returns:
                tuple: (x, y) coordinates
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        thickness: Line thickness of the drawing outline.
            
            Returns:
                float: Thickness value in pixels
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawTriangle:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def color(self) -> Color:
        """
        Color of the drawing outline.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> Color:
        """
        Fill color of the drawing.
        
        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @fill.setter
    def fill(self, value : Color):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> Coord:
        """
        First vertex position in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p1.setter
    def p1(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p2(self) -> Coord:
        """
        Second vertex position in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p2.setter
    def p2(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def p3(self) -> Coord:
        """
        Third vertex position in coordinate space.
        
        Returns:
            tuple: (x, y) coordinates
        
        """
        ...


    @p3.setter
    def p3(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def thickness(self) -> float:
        """
        Line thickness of the drawing outline.
        
        Returns:
            float: Thickness value in pixels
        
        """
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawingClip(drawingItem):
    """
    A DrawingList, but with clipping.

    By default, all items are submitted to the GPU.
    The GPU handles efficiently clipping items that are outside
    the clipping regions.

    In most cases, that's enough and you don't need
    this item.

    However if you have a really huge amount of drawing
    primitives, the submission can be CPU intensive.
    In this case you might want to skip submitting
    groups of drawing primitives that are known to be
    outside the visible region.

    Another use case, is when you want to have a different
    density of items depending on the zoom level.

    Both the above use-cases can be done manually
    using a DrawingList and setting the show
    attribute programmatically.

    This item enables to do this automatically.

    This item defines a clipping rectangle space-wise
    and zoom-wise. If this clipping rectangle is not
    in the visible space, the children are not rendered.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[drawingItem] = [], next_sibling : baseItem | None = None, no_global_scaling : bool = False, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : Sequence[float] | tuple[float, float] | Coord = (1e+300, 1e+300), pmin : Sequence[float] | tuple[float, float] | Coord = (-1e+300, -1e+300), previous_sibling : baseItem | None = None, scale_max : float = inf, scale_min : float = 0.0, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_global_scaling: By default, the pixel size of scale_min/max
            is multiplied by the global scale in order
            to have the same behaviour of various screens.
        parent: parent of the item in the rendering tree.
        pmax: (xmax, ymax) corner of the rect that
            must be on screen for the children to be rendered.
        pmin: (xmin, ymin) corner of the rect that
            must be on screen for the children to be rendered.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scale_max: The coordinate space to screen space scaling
            must be lower or equal to this amount (measured pixel size
            between the coordinate (x=0, y=0) and (x=1, y=0))
            for the children to be rendered.
        scale_min: The coordinate space to screen space scaling
            must be strictly above this amount (measured pixel size
            between the coordinate (x=0, y=0) and (x=1, y=0))
            for the children to be rendered.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[drawingItem] = [], next_sibling : baseItem | None = None, no_global_scaling : bool = False, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : Sequence[float] | tuple[float, float] | Coord = (1e+300, 1e+300), pmin : Sequence[float] | tuple[float, float] | Coord = (-1e+300, -1e+300), previous_sibling : baseItem | None = None, scale_max : float = inf, scale_min : float = 0.0, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_global_scaling: By default, the pixel size of scale_min/max
            is multiplied by the global scale in order
            to have the same behaviour of various screens.
        parent: parent of the item in the rendering tree.
        pmax: (xmax, ymax) corner of the rect that
            must be on screen for the children to be rendered.
        pmin: (xmin, ymin) corner of the rect that
            must be on screen for the children to be rendered.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scale_max: The coordinate space to screen space scaling
            must be lower or equal to this amount (measured pixel size
            between the coordinate (x=0, y=0) and (x=1, y=0))
            for the children to be rendered.
        scale_min: The coordinate space to screen space scaling
            must be strictly above this amount (measured pixel size
            between the coordinate (x=0, y=0) and (x=1, y=0))
            for the children to be rendered.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawingClip:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_global_scaling(self) -> bool:
        """
        By default, the pixel size of scale_min/max
        is multiplied by the global scale in order
        to have the same behaviour of various screens.

        Setting to True this field disables that.
        
        """
        ...


    @no_global_scaling.setter
    def no_global_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pmax(self) -> Coord:
        """
        (xmax, ymax) corner of the rect that
        must be on screen for the children to be rendered.
        
        """
        ...


    @pmax.setter
    def pmax(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pmin(self) -> Coord:
        """
        (xmin, ymin) corner of the rect that
        must be on screen for the children to be rendered.
        
        """
        ...


    @pmin.setter
    def pmin(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def scale_max(self) -> float:
        """
        The coordinate space to screen space scaling
        must be lower or equal to this amount (measured pixel size
        between the coordinate (x=0, y=0) and (x=1, y=0))
        for the children to be rendered.
        
        """
        ...


    @scale_max.setter
    def scale_max(self, value : float):
        ...


    @property
    def scale_min(self) -> float:
        """
        The coordinate space to screen space scaling
        must be strictly above this amount (measured pixel size
        between the coordinate (x=0, y=0) and (x=1, y=0))
        for the children to be rendered.
        
        """
        ...


    @scale_min.setter
    def scale_min(self, value : float):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawingList(drawingItem):
    """
    A simple drawing item that renders its children.

    Useful to arrange your items and quickly
    hide/show/delete them by manipulating the list.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[drawingItem] = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[drawingItem] = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawingList:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawingScale(drawingItem):
    """
    A DrawingList, with a change in origin and scaling.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[drawingItem] = [], next_sibling : baseItem | None = None, no_global_scaling : bool = False, no_parent_scaling : bool = False, origin : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, scales : Sequence[float] | tuple[float, float] | Coord = (1.0, 1.0), show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_global_scaling: Disables the global scale when no_parent_scaling is True.
        no_parent_scaling: Resets any previous scaling to screen space.
        origin: Position in coordinate space of the
            new origin for the children.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scales: Scales applied to the x and y axes
            for the children.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[drawingItem] = [], next_sibling : baseItem | None = None, no_global_scaling : bool = False, no_parent_scaling : bool = False, origin : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, scales : Sequence[float] | tuple[float, float] | Coord = (1.0, 1.0), show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_global_scaling: Disables the global scale when no_parent_scaling is True.
        no_parent_scaling: Resets any previous scaling to screen space.
        origin: Position in coordinate space of the
            new origin for the children.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scales: Scales applied to the x and y axes
            for the children.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawingScale:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_global_scaling(self) -> bool:
        """
        Disables the global scale when no_parent_scaling is True.
        
        """
        ...


    @no_global_scaling.setter
    def no_global_scaling(self, value : bool):
        ...


    @property
    def no_parent_scaling(self) -> bool:
        """
        Resets any previous scaling to screen space.

        Note origin is still transformed to screen space
        using the parent transform.

        When set to True, the global scale still
        impacts the scaling. Use no_global_scaling to
        disable this behaviour.
        
        """
        ...


    @no_parent_scaling.setter
    def no_parent_scaling(self, value : bool):
        ...


    @property
    def origin(self) -> Coord:
        """
        Position in coordinate space of the
        new origin for the children.

        Default is (0., 0.)
        
        """
        ...


    @origin.setter
    def origin(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def scales(self) -> Coord:
        """
        Scales applied to the x and y axes
        for the children.

        Default is (1., 1.).

        Unless no_parent_scale is True,
        when applied, scales multiplies any previous
        scales already set (including plot scales).
        
        """
        ...


    @scales.setter
    def scales(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class EditedHandler(baseHandler):
    """
    Handler to catch when a field is edited.
    Only the frames when a field is changed
    triggers the callback.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> EditedHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class FocusHandler(baseHandler):
    """
    Handler for windows or sub-windows that is called
    when they have focus, or for items when they
    have focus (for instance keyboard navigation,
    or editing a field).
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> FocusHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Font(baseFont):
    """
    Represents a font that can be used in the UI.

    Attributes:
    - texture: Texture for the font.
    - size: Size of the font.
    - scale: Scale of the font.
    - no_scaling: Boolean indicating if scaling should be disabled for the font.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, no_scaling : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, scale : float = 1.0, size : Any = ..., user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this font.
            The manual user-set scale is still applied.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        size: native height of characters
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, no_scaling : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, scale : float = 1.0, size : Any = ..., user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this font.
            The manual user-set scale is still applied.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        size: native height of characters
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Font:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this font.
        The manual user-set scale is still applied.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def scale(self) -> float:
        ...


    @scale.setter
    def scale(self, value : float):
        ...


    @property
    def size(self):
        """Readonly attribute: native height of characters
        """
        ...


    @size.setter
    def size(self, value):
        ...


    @property
    def texture(self) -> Texture | None:
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class FontMultiScales(baseFont):
    """
    A font container that can hold multiple Font objects at different scales.
    When used, it automatically selects and pushes the font with the 
    invert scale closest to the current global scale.
    The purpose is to automatically select the Font that when
    scaled by global_scale will be stretched the least.

    This is useful for having sharp fonts at different DPI scales without
    having to manually manage font switching.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[baseItem] = [], fonts : list = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: Callbacks that get triggered when a new scale is stored.
            Each callback receives the new scale value that was added.
        callbacks: Callbacks that get triggered when a new scale is stored.
            Each callback receives the new scale value that was added.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        fonts: List of attached fonts. Each font should have a different scale.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[baseItem] = [], fonts : list = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: Callbacks that get triggered when a new scale is stored.
            Each callback receives the new scale value that was added.
        callbacks: Callbacks that get triggered when a new scale is stored.
            Each callback receives the new scale value that was added.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        fonts: List of attached fonts. Each font should have a different scale.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> FontMultiScales:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Callbacks that get triggered when a new scale is stored.
        Each callback receives the new scale value that was added.
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fonts(self) -> list:
        """
        List of attached fonts. Each font should have a different scale.
        
        """
        ...


    @fonts.setter
    def fonts(self, value : list):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def recent_scales(self) -> list:
        """
        List of up to 10 most recent global scales encountered during rendering.
        The scales are not in a particular order
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class FontTexture(baseItem):
    """
    Packs one or several fonts into
    a texture for internal use by ImGui.

    In order to have sharp fonts with various screen
    dpi scalings, two options are available:
    1) Handle scaling yourself:
        Whenever the global scale changes, make
        a new font using a scaled size, and
        set no_scaling to True
    2) Handle scaling yourself at init only:
        In most cases it is reasonnable to
        assume the dpi scale will not change.
        In that case the easiest is to check
        the viewport dpi scale after initialization,
        load the scaled font size, and then set
        font.scale to the inverse of the dpi scale.
        This will render at the intended size
        as long as the dpi scale is not changed,
        and will scale if it changes (but will be
        slightly blurry).

    Currently the default font uses option 2). Call
    fonts.make_extended_latin_font(your_size) and
    add_custom_font to get the default font at a different
    scale, and implement 1) or 2) yourself.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, texture : Texture | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        texture: Readonly texture containing the font data.
            build() must be called first
        user_data: User data of any type.
        """
        ...


    def add_custom_font(self, glyph_set):
        """
        See fonts.py for a detailed explanation of
        the input arguments.

        Currently add_custom_font calls build()
        and thus prevents adding new fonts, but
        this might not be true in the future, thus
        you should still call build().
        
        """
        ...


    def add_font_file(self, path, size=13.0, index_in_file=0, density_scale=1.0, align_to_pixel=False):
        """
        Prepare the target font file to be added to the FontTexture,
        using ImGui's font loader.

        path: path to the input font file (ttf, otf, etc).
        size: Target pixel size at which the font will be rendered by default.
        index_in_file: index of the target font in the font file.
        density_scale: rasterizer oversampling to better render when
            the font scale is not 1. Not a miracle solution though,
            as it causes blurry inputs if the actual scale used
            during rendering is less than density_scale.
        align_to_pixel: For sharp fonts, will prevent blur by
            aligning font rendering to the pixel. The spacing
            between characters might appear slightly odd as
            a result, so don't enable when not needed.
        
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def build(self):
        """
        Packs all the fonts appended with add_font_file
        into a readonly texture. 
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, texture : Texture | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        texture: Readonly texture containing the font data.
            build() must be called first
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> FontTexture:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def built(self) -> bool:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def texture(self) -> Texture | None:
        """
        Readonly texture containing the font data.
        build() must be called first
        
        """
        ...


    @texture.setter
    def texture(self, value : Texture | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class GotFocusHandler(baseHandler):
    """
    Handler for when windows or sub-windows get
    focus.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> GotFocusHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class GotHoverHandler(baseHandler):
    """
    Handler that calls the callback when
    the target item has just been hovered.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> GotHoverHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class GotMouseOverHandler(baseHandler):
    """
Prefer GotHoverHandler unless you really need to (see MouseOverHandler)
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> GotMouseOverHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class GotRenderHandler(baseHandler):
    """
    Same as RenderHandler, but only calls the
    callback when the item switches from a
    non-rendered to a rendered state.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> GotRenderHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class HandlerList(baseHandler):
    """
    A container for multiple handlers that can be attached to an item.

    This handler allows grouping multiple handlers together and optionally 
    executing a callback based on the combined state of all child handlers.

    The callback can be triggered based on three conditions:
    - ALL: All child handlers' states must be true (default)
    - ANY: At least one child handler's state must be true
    - NONE: No child handler's states are true

    Skipping heavy CustomHandlers:
        One use case is to skip expensive check_status() calls from CustomHandlers.
        If the status of the first children is incompatible with the checked condition,
        the status of further children is not checked.

    Note:
        Handlers are not checked if their parent item is not rendered.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, op : HandlerListOP = 0, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        op: HandlerListOP that defines which condition
            is required to trigger the callback of this
            handler.
            Default is ALL
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, op : HandlerListOP = 0, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        op: HandlerListOP that defines which condition
            is required to trigger the callback of this
            handler.
            Default is ALL
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> HandlerList:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> list[baseHandler]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseHandler]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def op(self) -> HandlerListOP:
        """
        HandlerListOP that defines which condition
        is required to trigger the callback of this
        handler.
        Default is ALL
        
        """
        ...


    @op.setter
    def op(self, value : HandlerListOP):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class HorizontalLayout(Layout):
    """
    A basic layout to organize the items
    horizontally.
    
    """
    def __init__(self, context : Context, alignment_mode : Alignment = 0, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, no_wrap : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), positions : list = [], previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0, wrap_x : float = 0.0):
        """

        alignment_mode: Horizontal alignment mode of the items.
            LEFT: items are appended from the left
            RIGHT: items are appended from the right
            CENTER: items are centered
            JUSTIFIED: spacing is organized such
            that items start at the left and end
            at the right.
            MANUAL: items are positionned at the requested
            positions
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_wrap: Disable wrapping to the next row when the
            elements cannot fit in the available region.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the x position starting
            from the top left of this item at which to
            place the children items.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        wrap_x: When wrapping, on the second row and later rows,
            start from the wrap_x position relative to the
            starting position. Note the value is in pixel value
            and you must scale it if needed. The wrapping position
            is clamped such that you always start at a position >= 0
            relative to the window content area, thus passing
            a significant negative value will bring back to
            the start of the window.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, alignment_mode : Alignment = 0, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, no_wrap : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), positions : list = [], previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0, wrap_x : float = 0.0):
        """
        alignment_mode: Horizontal alignment mode of the items.
            LEFT: items are appended from the left
            RIGHT: items are appended from the right
            CENTER: items are centered
            JUSTIFIED: spacing is organized such
            that items start at the left and end
            at the right.
            MANUAL: items are positionned at the requested
            positions
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_wrap: Disable wrapping to the next row when the
            elements cannot fit in the available region.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the x position starting
            from the top left of this item at which to
            place the children items.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        wrap_x: When wrapping, on the second row and later rows,
            start from the wrap_x position relative to the
            starting position. Note the value is in pixel value
            and you must scale it if needed. The wrapping position
            is clamped such that you always start at a position >= 0
            relative to the window content area, thus passing
            a significant negative value will bring back to
            the start of the window.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        """
        Force an update of the layout next time the scene
        is rendered
        
        """
        ...


    def __enter__(self) -> HorizontalLayout:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def alignment_mode(self) -> Alignment:
        """
        Horizontal alignment mode of the items.
        LEFT: items are appended from the left
        RIGHT: items are appended from the right
        CENTER: items are centered
        JUSTIFIED: spacing is organized such
        that items start at the left and end
        at the right.
        MANUAL: items are positionned at the requested
        positions

        FOR LEFT/RIGHT/CENTER, ItemSpacing's style can
        be used to control spacing between the items.
        Default is LEFT.
        
        """
        ...


    @alignment_mode.setter
    def alignment_mode(self, value : Alignment):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_wrap(self) -> bool:
        """
        Disable wrapping to the next row when the
        elements cannot fit in the available region.
        
        """
        ...


    @no_wrap.setter
    def no_wrap(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def positions(self) -> list:
        """
        When in MANUAL mode, the x position starting
        from the top left of this item at which to
        place the children items.

        If the positions are between 0 and 1, they are
        interpreted as percentages relative to the
        size of the Layout width.
        If the positions are negatives, they are interpreted
        as in reference to the right of the layout rather
        than the left. Items are still left aligned to
        the target position though.

        Setting this field sets the alignment mode to
        MANUAL.
        
        """
        ...


    @positions.setter
    def positions(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


    @property
    def wrap_x(self) -> float:
        """
        When wrapping, on the second row and later rows,
        start from the wrap_x position relative to the
        starting position. Note the value is in pixel value
        and you must scale it if needed. The wrapping position
        is clamped such that you always start at a position >= 0
        relative to the window content area, thus passing
        a significant negative value will bring back to
        the start of the window.
        
        """
        ...


    @wrap_x.setter
    def wrap_x(self, value : float):
        ...


class HoverHandler(baseHandler):
    """
    Handler that calls the callback when
    the target item is hovered.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> HoverHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Image(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., border_color : list = [0.0, 0.0, 0.0, 0.0], callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, texture : Texture | None = None, theme : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 1.0, 1.0], value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., border_color : list = [0.0, 0.0, 0.0, 0.0], callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, texture : Texture | None = None, theme : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 1.0, 1.0], value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Image:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def border_color(self) -> list:
        ...


    @border_color.setter
    def border_color(self, value : list):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def color_multiplier(self) -> list:
        ...


    @color_multiplier.setter
    def color_multiplier(self, value : list):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def texture(self) -> Texture | None:
        ...


    @texture.setter
    def texture(self, value : Texture | None):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def uv(self) -> list:
        ...


    @uv.setter
    def uv(self, value : list):
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ImageButton(uiItem):
    def __init__(self, context : Context, attach : Any = ..., background_color : list = [0.0, 0.0, 0.0, 0.0], before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], enabled : bool = True, focused : bool = False, font : Font = None, frame_padding : int = -1, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, texture : Texture | None = None, theme : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 1.0, 1.0], value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., background_color : list = [0.0, 0.0, 0.0, 0.0], before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], enabled : bool = True, focused : bool = False, font : Font = None, frame_padding : int = -1, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, texture : Texture | None = None, theme : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 1.0, 1.0], value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ImageButton:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def background_color(self) -> list:
        ...


    @background_color.setter
    def background_color(self, value : list):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def color_multiplier(self) -> list:
        ...


    @color_multiplier.setter
    def color_multiplier(self, value : list):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def frame_padding(self) -> int:
        ...


    @frame_padding.setter
    def frame_padding(self, value : int):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def texture(self) -> Texture | None:
        ...


    @texture.setter
    def texture(self, value : Texture | None):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def uv(self) -> list:
        ...


    @uv.setter
    def uv(self, value : list):
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class InputText(uiItem):
    def __init__(self, context : Context, always_overwrite : bool = False, attach : Any = ..., auto_select_all : bool = False, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], ctrl_enter_for_new_line : bool = False, decimal : bool = False, enabled : bool = True, escape_clears_all : bool = False, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, hexadecimal : bool = False, hint : str = "", indent : float = 0.0, label : str = "", max_characters : int = 1024, multiline : bool = False, next_sibling : baseItem | None = None, no_horizontal_scroll : bool = False, no_newline : bool = False, no_scaling : bool = False, no_spaces : bool = False, no_undo_redo : bool = False, on_enter : bool = False, parent : uiItem | plotElement | None = None, password : bool = False, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, readonly : bool = False, scaling_factor : float = 1.0, scientific : bool = False, shareable_value : SharedStr = ..., show : bool = True, tab_input : bool = False, theme : Any = ..., uppercase : bool = False, user_data : Any = ..., value : str = "", width : float = 0.0):
        """

        always_overwrite: Overwrite mode
        attach: Whether to attach the item to a parent. Default is None (auto)
        auto_select_all: Select entire text when first taking mouse focus
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        ctrl_enter_for_new_line: In multi-line mode, validate with Enter,
            add new line with Ctrl+Enter
            (default is opposite: validate with Ctrl+Enter, add line with Enter).
        decimal: Allow 0123456789.+-
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        escape_clears_all: Escape key clears content if not empty,
            and deactivate otherwise
            (contrast to default behavior of Escape to revert)
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hexadecimal: Allow 0123456789ABCDEFabcdef
        hint: text hint.
            Doesn't work with multiline.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_characters: Maximal number of characters that can be written
        multiline: multiline text input.
            Doesn't work with non-empty hint.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_horizontal_scroll: Disable following the scroll horizontally
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_spaces: Filter out spaces, tabs
        no_undo_redo: Disable undo/redo.
        on_enter: Callback called everytime Enter is pressed,
            not just when the value is modified.
        parent: parent of the item in the rendering tree.
        password: Password mode, display all characters as '*', disable copy
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        readonly: Read-only mode
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        scientific: Allow 0123456789.+-*/eE
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tab_input: Pressing TAB input a '	' character into the text field
        theme: bound theme for the item
        uppercase: Turn a..z into A..Z
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_overwrite : bool = False, attach : Any = ..., auto_select_all : bool = False, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], ctrl_enter_for_new_line : bool = False, decimal : bool = False, enabled : bool = True, escape_clears_all : bool = False, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, hexadecimal : bool = False, hint : str = "", indent : float = 0.0, label : str = "", max_characters : int = 1024, multiline : bool = False, next_sibling : baseItem | None = None, no_horizontal_scroll : bool = False, no_newline : bool = False, no_scaling : bool = False, no_spaces : bool = False, no_undo_redo : bool = False, on_enter : bool = False, parent : uiItem | plotElement | None = None, password : bool = False, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, readonly : bool = False, scaling_factor : float = 1.0, scientific : bool = False, shareable_value : SharedStr = ..., show : bool = True, tab_input : bool = False, theme : Any = ..., uppercase : bool = False, user_data : Any = ..., value : str = "", width : float = 0.0):
        """
        always_overwrite: Overwrite mode
        attach: Whether to attach the item to a parent. Default is None (auto)
        auto_select_all: Select entire text when first taking mouse focus
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        ctrl_enter_for_new_line: In multi-line mode, validate with Enter,
            add new line with Ctrl+Enter
            (default is opposite: validate with Ctrl+Enter, add line with Enter).
        decimal: Allow 0123456789.+-
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        escape_clears_all: Escape key clears content if not empty,
            and deactivate otherwise
            (contrast to default behavior of Escape to revert)
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hexadecimal: Allow 0123456789ABCDEFabcdef
        hint: text hint.
            Doesn't work with multiline.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_characters: Maximal number of characters that can be written
        multiline: multiline text input.
            Doesn't work with non-empty hint.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_horizontal_scroll: Disable following the scroll horizontally
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_spaces: Filter out spaces, tabs
        no_undo_redo: Disable undo/redo.
        on_enter: Callback called everytime Enter is pressed,
            not just when the value is modified.
        parent: parent of the item in the rendering tree.
        password: Password mode, display all characters as '*', disable copy
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        readonly: Read-only mode
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        scientific: Allow 0123456789.+-*/eE
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tab_input: Pressing TAB input a '	' character into the text field
        theme: bound theme for the item
        uppercase: Turn a..z into A..Z
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> InputText:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def always_overwrite(self) -> bool:
        """
        Writable attribute: Overwrite mode
        
        """
        ...


    @always_overwrite.setter
    def always_overwrite(self, value : bool):
        ...


    @property
    def auto_select_all(self) -> bool:
        """
        Writable attribute: Select entire text when first taking mouse focus
        
        """
        ...


    @auto_select_all.setter
    def auto_select_all(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def ctrl_enter_for_new_line(self) -> bool:
        """
        Writable attribute: In multi-line mode, validate with Enter,
        add new line with Ctrl+Enter
        (default is opposite: validate with Ctrl+Enter, add line with Enter).
        
        """
        ...


    @ctrl_enter_for_new_line.setter
    def ctrl_enter_for_new_line(self, value : bool):
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def decimal(self) -> bool:
        """
        Writable attribute: Allow 0123456789.+-
        
        """
        ...


    @decimal.setter
    def decimal(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def escape_clears_all(self) -> bool:
        """
        Writable attribute: Escape key clears content if not empty,
        and deactivate otherwise
        (contrast to default behavior of Escape to revert)
        
        """
        ...


    @escape_clears_all.setter
    def escape_clears_all(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hexadecimal(self) -> bool:
        """
        Writable attribute:  Allow 0123456789ABCDEFabcdef
        
        """
        ...


    @hexadecimal.setter
    def hexadecimal(self, value : bool):
        ...


    @property
    def hint(self) -> str:
        """
        Writable attribute: text hint.
        Doesn't work with multiline.
        
        """
        ...


    @hint.setter
    def hint(self, value : str):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def max_characters(self) -> int:
        """
        Writable attribute: Maximal number of characters that can be written
        
        """
        ...


    @max_characters.setter
    def max_characters(self, value : int):
        ...


    @property
    def multiline(self) -> bool:
        """
        Writable attribute: multiline text input.
        Doesn't work with non-empty hint.
        
        """
        ...


    @multiline.setter
    def multiline(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_horizontal_scroll(self) -> bool:
        """
        Writable attribute: Disable following the scroll horizontally
        
        """
        ...


    @no_horizontal_scroll.setter
    def no_horizontal_scroll(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_spaces(self) -> bool:
        """
        Writable attribute: Filter out spaces, tabs
        
        """
        ...


    @no_spaces.setter
    def no_spaces(self, value : bool):
        ...


    @property
    def no_undo_redo(self) -> bool:
        """
        Writable attribute: Disable undo/redo.
        
        """
        ...


    @no_undo_redo.setter
    def no_undo_redo(self, value : bool):
        ...


    @property
    def on_enter(self) -> bool:
        """
        Writable attribute: Callback called everytime Enter is pressed,
        not just when the value is modified.
        
        """
        ...


    @on_enter.setter
    def on_enter(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def password(self) -> bool:
        """
        Writable attribute: Password mode, display all characters as '*', disable copy
        
        """
        ...


    @password.setter
    def password(self, value : bool):
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def readonly(self) -> bool:
        """
        Writable attribute: Read-only mode
        
        """
        ...


    @readonly.setter
    def readonly(self, value : bool):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def scientific(self) -> bool:
        """
        Writable attribute: Allow 0123456789.+-*/eE
        
        """
        ...


    @scientific.setter
    def scientific(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tab_input(self) -> bool:
        """
        Writable attribute: Pressing TAB input a '	' character into the text field
        
        """
        ...


    @tab_input.setter
    def tab_input(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def uppercase(self) -> bool:
        """
        Writable attribute: Turn a..z into A..Z
        
        """
        ...


    @uppercase.setter
    def uppercase(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class InputValue(uiItem):
    def __init__(self, context : Context, always_overwrite : bool = False, attach : Any = ..., auto_select_all : bool = False, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], decimal : bool = False, empty_as_zero : bool = False, empty_if_zero : bool = False, enabled : bool = True, escape_clears_all : bool = False, focused : bool = False, font : Font = None, format : str = "float", handlers : list = [], height : float = 0.0, hexadecimal : bool = False, indent : float = 0.0, label : str = "", max_value : float = inf, min_value : float = -inf, next_sibling : baseItem | None = None, no_horizontal_scroll : bool = False, no_newline : bool = False, no_scaling : bool = False, no_undo_redo : bool = False, on_enter : bool = False, parent : uiItem | plotElement | None = None, password : bool = False, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, print_format : str = "%.3f", readonly : bool = False, scaling_factor : float = 1.0, scientific : bool = False, shareable_value : SharedFloat = ..., show : bool = True, size : int = 1, step : float = 0.1, step_fast : float = 1.0, theme : Any = ..., user_data : Any = ..., value : float = 0.0, width : float = 0.0):
        """

        always_overwrite: Overwrite mode
        attach: Whether to attach the item to a parent. Default is None (auto)
        auto_select_all: Select entire text when first taking mouse focus
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        decimal: Allow 0123456789.+-
        empty_as_zero: parse empty string as zero value
        empty_if_zero: when value is zero, do not display it
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        escape_clears_all: Escape key clears content if not empty,
            and deactivate otherwise
            (contrast to default behavior of Escape to revert)
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        format: Format of the slider.
            Must be "int", "float" or "double".
            Note that float here means the 32 bits version.
            The python float corresponds to a double.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hexadecimal: Allow 0123456789ABCDEFabcdef
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_value: Maximum value the input
            will be clamped to.
        min_value: Minimum value the input
            will be clamped to.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_horizontal_scroll: Disable following the scroll horizontally
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_undo_redo: Disable undo/redo.
        on_enter: Callback called everytime Enter is pressed,
            not just when the value is modified.
        parent: parent of the item in the rendering tree.
        password: Password mode, display all characters as '*', disable copy
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        print_format: format string
            for the value -> string conversion
            for display. If round_to_format is
            enabled, the value is converted
            back and thus appears rounded.
        readonly: Read-only mode
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        scientific: Allow 0123456789.+-*/eE
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Size of the slider.
            Can be 1, 2, 3 or 4.
            When 1 the item's value is held with
            a scalar shared value, else it is held
            with a vector of 4 elements (even for
            size 2 and 3)
        step: 
        step_fast: 
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_overwrite : bool = False, attach : Any = ..., auto_select_all : bool = False, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], decimal : bool = False, empty_as_zero : bool = False, empty_if_zero : bool = False, enabled : bool = True, escape_clears_all : bool = False, focused : bool = False, font : Font = None, format : str = "float", handlers : list = [], height : float = 0.0, hexadecimal : bool = False, indent : float = 0.0, label : str = "", max_value : float = inf, min_value : float = -inf, next_sibling : baseItem | None = None, no_horizontal_scroll : bool = False, no_newline : bool = False, no_scaling : bool = False, no_undo_redo : bool = False, on_enter : bool = False, parent : uiItem | plotElement | None = None, password : bool = False, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, print_format : str = "%.3f", readonly : bool = False, scaling_factor : float = 1.0, scientific : bool = False, shareable_value : SharedFloat = ..., show : bool = True, size : int = 1, step : float = 0.1, step_fast : float = 1.0, theme : Any = ..., user_data : Any = ..., value : float = 0.0, width : float = 0.0):
        """
        always_overwrite: Overwrite mode
        attach: Whether to attach the item to a parent. Default is None (auto)
        auto_select_all: Select entire text when first taking mouse focus
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        decimal: Allow 0123456789.+-
        empty_as_zero: parse empty string as zero value
        empty_if_zero: when value is zero, do not display it
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        escape_clears_all: Escape key clears content if not empty,
            and deactivate otherwise
            (contrast to default behavior of Escape to revert)
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        format: Format of the slider.
            Must be "int", "float" or "double".
            Note that float here means the 32 bits version.
            The python float corresponds to a double.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hexadecimal: Allow 0123456789ABCDEFabcdef
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_value: Maximum value the input
            will be clamped to.
        min_value: Minimum value the input
            will be clamped to.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_horizontal_scroll: Disable following the scroll horizontally
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_undo_redo: Disable undo/redo.
        on_enter: Callback called everytime Enter is pressed,
            not just when the value is modified.
        parent: parent of the item in the rendering tree.
        password: Password mode, display all characters as '*', disable copy
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        print_format: format string
            for the value -> string conversion
            for display. If round_to_format is
            enabled, the value is converted
            back and thus appears rounded.
        readonly: Read-only mode
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        scientific: Allow 0123456789.+-*/eE
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Size of the slider.
            Can be 1, 2, 3 or 4.
            When 1 the item's value is held with
            a scalar shared value, else it is held
            with a vector of 4 elements (even for
            size 2 and 3)
        step: 
        step_fast: 
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> InputValue:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def always_overwrite(self) -> bool:
        """
        Writable attribute: Overwrite mode
        
        """
        ...


    @always_overwrite.setter
    def always_overwrite(self, value : bool):
        ...


    @property
    def auto_select_all(self) -> bool:
        """
        Writable attribute: Select entire text when first taking mouse focus
        
        """
        ...


    @auto_select_all.setter
    def auto_select_all(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def decimal(self) -> bool:
        """
        Writable attribute: Allow 0123456789.+-
        
        """
        ...


    @decimal.setter
    def decimal(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def empty_as_zero(self) -> bool:
        """
        Writable attribute: parse empty string as zero value
        
        """
        ...


    @empty_as_zero.setter
    def empty_as_zero(self, value : bool):
        ...


    @property
    def empty_if_zero(self) -> bool:
        """
        Writable attribute: when value is zero, do not display it
        
        """
        ...


    @empty_if_zero.setter
    def empty_if_zero(self, value : bool):
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def escape_clears_all(self) -> bool:
        """
        Writable attribute: Escape key clears content if not empty,
        and deactivate otherwise
        (contrast to default behavior of Escape to revert)
        
        """
        ...


    @escape_clears_all.setter
    def escape_clears_all(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def format(self) -> str:
        """
        Writable attribute: Format of the slider.
        Must be "int", "float" or "double".
        Note that float here means the 32 bits version.
        The python float corresponds to a double.
        
        """
        ...


    @format.setter
    def format(self, value : str):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hexadecimal(self) -> bool:
        """
        Writable attribute:  Allow 0123456789ABCDEFabcdef
        
        """
        ...


    @hexadecimal.setter
    def hexadecimal(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def max_value(self) -> float:
        """
        Writable attribute: Maximum value the input
        will be clamped to.
        
        """
        ...


    @max_value.setter
    def max_value(self, value : float):
        ...


    @property
    def min_value(self) -> float:
        """
        Writable attribute: Minimum value the input
        will be clamped to.
        
        """
        ...


    @min_value.setter
    def min_value(self, value : float):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_horizontal_scroll(self) -> bool:
        """
        Writable attribute: Disable following the scroll horizontally
        
        """
        ...


    @no_horizontal_scroll.setter
    def no_horizontal_scroll(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_undo_redo(self) -> bool:
        """
        Writable attribute: Disable undo/redo.
        
        """
        ...


    @no_undo_redo.setter
    def no_undo_redo(self, value : bool):
        ...


    @property
    def on_enter(self) -> bool:
        """
        Writable attribute: Callback called everytime Enter is pressed,
        not just when the value is modified.
        
        """
        ...


    @on_enter.setter
    def on_enter(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def password(self) -> bool:
        """
        Writable attribute: Password mode, display all characters as '*', disable copy
        
        """
        ...


    @password.setter
    def password(self, value : bool):
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def print_format(self) -> str:
        """
        Writable attribute: format string
        for the value -> string conversion
        for display. If round_to_format is
        enabled, the value is converted
        back and thus appears rounded.
        
        """
        ...


    @print_format.setter
    def print_format(self, value : str):
        ...


    @property
    def readonly(self) -> bool:
        """
        Writable attribute: Read-only mode
        
        """
        ...


    @readonly.setter
    def readonly(self, value : bool):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def scientific(self) -> bool:
        """
        Writable attribute: Allow 0123456789.+-*/eE
        
        """
        ...


    @scientific.setter
    def scientific(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedFloat:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedFloat):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def size(self) -> int:
        """
        Writable attribute: Size of the slider.
        Can be 1, 2, 3 or 4.
        When 1 the item's value is held with
        a scalar shared value, else it is held
        with a vector of 4 elements (even for
        size 2 and 3)
        
        """
        ...


    @size.setter
    def size(self, value : int):
        ...


    @property
    def step(self) -> float:
        """
        Writable attribute: 
        
        """
        ...


    @step.setter
    def step(self, value : float):
        ...


    @property
    def step_fast(self) -> float:
        """
        Writable attribute: 
        
        """
        ...


    @step_fast.setter
    def step_fast(self, value : float):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> float:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : float):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class KeyDownHandler(baseHandler):
    """
    Handler that triggers when a key is held down.

    Properties:
        key (Key): Target key to monitor.
        
    Callback receives:
        - key: The key being pressed
        - duration: How long the key has been held down
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : Key = 525, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : Key = 525, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> KeyDownHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def key(self) -> Key:
        ...


    @key.setter
    def key(self, value : Key):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class KeyPressHandler(baseHandler):
    """
    Handler that triggers when a key is initially pressed.

    Properties:
        key (Key): Target key to monitor
        repeat (bool): Whether to trigger repeatedly while key is held

    Callback receives:
        - key: The key that was pressed
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : Key = 525, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, repeat : bool = True, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : Key = 525, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, repeat : bool = True, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> KeyPressHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def key(self) -> Key:
        ...


    @key.setter
    def key(self, value : Key):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def repeat(self) -> bool:
        ...


    @repeat.setter
    def repeat(self, value : bool):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class KeyReleaseHandler(baseHandler):
    """
    Handler that triggers when a key is released.

    Properties:
        key (Key): Target key to monitor

    Callback receives:
        - key: The key that was released
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : Key = 525, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : Key = 525, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> KeyReleaseHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def key(self) -> Key:
        ...


    @key.setter
    def key(self, value : Key):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Layout(uiItem):
    """
    A layout is a group of elements organized
    together.
    The layout states correspond to the OR
    of all the item states, and the rect size
    corresponds to the minimum rect containing
    all the items. The position of the layout
    is used to initialize the default position
    for the first item.
    For example setting indent will shift all
    the items of the Layout.

    Subclassing Layout:
    For custom layouts, you can use Layout with
    a callback. The callback is called whenever
    the layout should be updated.

    If the automated update detection is not
    sufficient, update_layout() can be called
    to force a recomputation of the layout.

    Currently the update detection detects a change in
    the size of the remaining content area available
    locally within the window, or if the last item has changed.

    The layout item works by changing the positioning
    policy and the target position of its children, and
    thus there is no guarantee that the user set
    positioning and position states of the children are
    preserved.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        ...


    def __enter__(self) -> Layout:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ListBox(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, num_items_shown_when_open : int = -1, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedStr = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : str = "", width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        num_items_shown_when_open: Number of items
            shown when the menu is opened
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, num_items_shown_when_open : int = -1, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedStr = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : str = "", width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        num_items_shown_when_open: Number of items
            shown when the menu is opened
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ListBox:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def items(self) -> list:
        """
        Writable attribute: List of text values to select
        
        """
        ...


    @items.setter
    def items(self, value : list):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def num_items_shown_when_open(self) -> int:
        """
        Writable attribute: Number of items
        shown when the menu is opened
        
        """
        ...


    @num_items_shown_when_open.setter
    def num_items_shown_when_open(self, value : int):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class LostFocusHandler(baseHandler):
    """
    Handler for when windows or sub-windows lose
    focus.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> LostFocusHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class LostHoverHandler(baseHandler):
    """
    Handler that calls the callback the first
    frame when the target item was hovered, but
    is not anymore.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> LostHoverHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class LostMouseOverHandler(baseHandler):
    """
Prefer LostHoverHandler unless you really need to (see MouseOverHandler)
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> LostMouseOverHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class LostRenderHandler(baseHandler):
    """
    Handler that only calls the
    callback when the item switches from a
    rendered to non-rendered state. Note
    that when an item is not rendered, subsequent
    frames will not run handlers. Only the first time
    an item is non-rendered will trigger the handlers.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> LostRenderHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Menu(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Menu:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class MenuBar(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : Viewport | Window | ChildWindow = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : Viewport | Window | ChildWindow = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MenuBar:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> Viewport | Window | ChildWindow:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Viewport | Window | ChildWindow):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class MenuItem(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], check : bool = False, children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., shortcut : str = "", show : bool = True, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        check: 
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        shortcut: 
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], check : bool = False, children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., shortcut : str = "", show : bool = True, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        check: 
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        shortcut: 
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MenuItem:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def check(self) -> bool:
        """
        Writable attribute:
        
        """
        ...


    @check.setter
    def check(self, value : bool):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def shortcut(self) -> str:
        """
        Writable attribute:
        
        """
        ...


    @shortcut.setter
    def shortcut(self, value : str):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class MotionHandler(baseHandler):
    """
    Handler that calls the callback when
    the target item is moved relative to
    the positioning reference (by default the parent)
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, pos_policy : tuple[Positioning, Positioning] = ..., previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        pos_policy: positioning policy used as reference for the motion
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, pos_policy : tuple[Positioning, Positioning] = ..., previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        pos_policy: positioning policy used as reference for the motion
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MotionHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """positioning policy used as reference for the motion

        REL_PARENT: motion relative to the parent
        REL_WINDOW: motion relative to the window
        REL_VIEWPORT: motion relative to the viewport
        DEFAULT: Disabled motion detection for the axis

        pos_policy is a tuple of Positioning where the
        first element refers to the x axis and the second
        to the y axis

        Defaults to REL_PARENT on both axes.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseClickHandler(baseHandler):
    """
    Handler for mouse button clicks anywhere.

    Properties:
        button (MouseButton): Target mouse button to monitor
        repeat (bool): Whether to trigger repeatedly while button held

    Callback receives:
        - button: The button that was clicked
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, repeat : bool = False, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, repeat : bool = False, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseClickHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def repeat(self) -> bool:
        ...


    @repeat.setter
    def repeat(self, value : bool):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseCursorHandler(baseHandler):
    """
    Since the mouse cursor is reset every frame,
    this handler is used to set the cursor automatically
    the frames where this handler is run.
    Typical usage would be in a ConditionalHandler,
    combined with a HoverHandler.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], cursor : MouseCursor = 0, enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        cursor: Change the mouse cursor to one of MouseCursor,
            but only for the frames where this handler
            is run.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], cursor : MouseCursor = 0, enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        cursor: Change the mouse cursor to one of MouseCursor,
            but only for the frames where this handler
            is run.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseCursorHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def cursor(self) -> MouseCursor:
        """
        Change the mouse cursor to one of MouseCursor,
        but only for the frames where this handler
        is run.
        
        """
        ...


    @cursor.setter
    def cursor(self, value : MouseCursor):
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseDoubleClickHandler(baseHandler):
    """
    Handler for mouse button double-clicks anywhere.

    Properties:
        button (MouseButton): Target mouse button to monitor

    Callback receives:
        - button: The button that was double-clicked
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseDoubleClickHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseDownHandler(baseHandler):
    """
    Handler for mouse button being held down.

    Properties:
        button (MouseButton): Target mouse button to monitor

    Callback receives:
        - button: The button being held
        - duration: How long the button has been held
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseDownHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseDragHandler(baseHandler):
    """
    Handler for mouse dragging motions.

    Properties:
        button (MouseButton): Target mouse button for drag
        threshold (float): Movement threshold to trigger drag.
                         Negative means use default.

    Callback receives:
        - button: The button used for dragging
        - delta_x: Horizontal drag distance
        - delta_y: Vertical drag distance
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, threshold : float = -1.0, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, threshold : float = -1.0, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseDragHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def threshold(self) -> float:
        ...


    @threshold.setter
    def threshold(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseInRect(baseHandler):
    """
    Handler that triggers when the mouse is inside a predefined rectangle.

    The rectangle is defined in viewport coordinates.
    
    Properties:
        rect: A tuple (x1, y1, x2, y2) or Rect object defining the area to monitor
        
    Callback receives:
        - x: Current mouse x position 
        - y: Current mouse y position
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, rect : Rect = (0.0, 0.0, 0.0, 0.0), show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        rect: Rectangle to test in viewport coordinates
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, rect : Rect = (0.0, 0.0, 0.0, 0.0), show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        rect: Rectangle to test in viewport coordinates
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseInRect:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect(self) -> Rect:
        """Rectangle to test in viewport coordinates
        """
        ...


    @rect.setter
    def rect(self, value : Rect):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseMoveHandler(baseHandler):
    """
    Handler that triggers when the mouse cursor moves.

    Callback receives:
        - x: New mouse x position
        - y: New mouse y position
        
    Note:
        Position is relative to the viewport.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseMoveHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseOverHandler(baseHandler):
    """
Prefer HoverHandler unless you really need to (see below)

    Handler that calls the callback when
    the mouse is over the item. In most cases,
    this is equivalent to HoverHandler,
    with the difference that a single item
    is considered hovered, while in
    some specific cases, several items could
    have the mouse above them.

    Prefer using HoverHandler for general use,
    and reserve MouseOverHandler for custom
    drag & drop operations.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseOverHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseReleaseHandler(baseHandler):
    """
    Handler for mouse button releases.

    Properties:
        button (MouseButton): Target mouse button to monitor

    Callback receives:  
        - button: The button that was released
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseReleaseHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseWheelHandler(baseHandler):
    """
    A handler that monitors mouse wheel scrolling events.

    Detects both vertical (default) and horizontal scrolling movements.
    For horizontal scrolling, either use Shift+vertical wheel or a horizontal
    wheel if available on the input device.

    Properties:
        horizontal (bool): When True, monitors horizontal scrolling instead of vertical.
                         Defaults to False (vertical scrolling).

    Note:
        Holding Shift while using vertical scroll wheel generates horizontal scroll events.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, horizontal : bool = False, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        horizontal: Whether to look at the horizontal wheel
            instead of the vertical wheel.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, horizontal : bool = False, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        horizontal: Whether to look at the horizontal wheel
            instead of the vertical wheel.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseWheelHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Whether to look at the horizontal wheel
        instead of the vertical wheel.

        NOTE: Shift+ vertical wheel => horizontal wheel
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class OpenHandler(baseHandler):
    """
    Handler that triggers the callback when the
    item is in an opened state.
    Here Close/Open refers to being in a
    reduced state when the full content is not
    shown, but could be if the user clicked on
    a specific button. The doesn't mean that
    the object is show or not shown.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> OpenHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class OtherItemHandler(HandlerList):
    """
    A handler that monitors states from a different item than the one it's attached to.

    This handler allows checking states of an item different from its attachment point,
    while still sending callbacks with the attached item as the target.

    Use cases:
    - Combining states between different items (AND/OR operations)
    - Monitoring items that might not be rendered
    - Creating dependencies between different interface elements

    Note:
        Callbacks still reference the attached item as target, not the monitored item.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, op : HandlerListOP = 0, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, target : Any = ..., user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        op: HandlerListOP that defines which condition
            is required to trigger the callback of this
            handler.
            Default is ALL
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        target: Target item which state will be used
            for children handlers.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, op : HandlerListOP = 0, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, target : Any = ..., user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        op: HandlerListOP that defines which condition
            is required to trigger the callback of this
            handler.
            Default is ALL
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        target: Target item which state will be used
            for children handlers.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> OtherItemHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> list[baseHandler]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseHandler]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def op(self) -> HandlerListOP:
        """
        HandlerListOP that defines which condition
        is required to trigger the callback of this
        handler.
        Default is ALL
        
        """
        ...


    @op.setter
    def op(self, value : HandlerListOP):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def target(self):
        """
        Target item which state will be used
        for children handlers.
        
        """
        ...


    @target.setter
    def target(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlaceHolderParent(baseItem):
    """
    Placeholder parent to store items outside the rendering tree.
    Can be a parent to anything but cannot have any parent itself.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlaceHolderParent:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Plot(uiItem):
    """
    Plot. Can have Plot elements as child.

    By default the axes X1 and Y1 are enabled,
    but other can be enabled, up to X3 and Y3.
    For instance:
    my_plot.X2.enabled = True

    By default, the legend and axes have reserved space.
    They can have their own handlers that can react to
    when they are hovered by the mouse or clicked.

    The states of the plot relate to the rendering area (excluding
    the legend, padding and axes). Thus if you want to react
    to mouse event inside the plot area (for example implementing
    clicking an curve), you can do it with using handlers bound
    to the plot (+ some logic in your callbacks). 
    
    """
    def __init__(self, context : Context, X1 : PlotAxisConfig = ..., X2 : PlotAxisConfig = ..., X3 : PlotAxisConfig = ..., Y1 : PlotAxisConfig = ..., Y2 : PlotAxisConfig = ..., Y3 : PlotAxisConfig = ..., attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[plotElement] = [], crosshairs : bool = False, enabled : bool = True, equal_aspects : bool = False, fit_button : MouseButton = 0, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", legend_config : PlotLegendConfig = ..., menu_button : MouseButton = 1, mouse_location : LegendLocation = 10, next_sibling : baseItem | None = None, no_frame : bool = False, no_inputs : bool = False, no_legend : bool = False, no_menus : bool = False, no_mouse_pos : bool = False, no_newline : bool = False, no_scaling : bool = False, no_title : bool = False, pan_button : MouseButton = 0, pan_mod : KeyMod = 0, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., use_24hour_clock : bool = False, use_ISO8601 : bool = False, use_local_time : bool = False, user_data : Any = ..., value : Any = ..., width : float = 0.0, zoom_mod : KeyMod = 0, zoom_rate : float = 0.10000000149011612):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        crosshairs: Writable attribute to replace the default mouse
            cursor by a crosshair when hovered
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        equal_aspects: Writable attribute to constrain x/y axes
            pairs to have the same units/pixels
        fit_button: Button that must be double-clicked to initiate
            a fit of the axes to the displayed data.
            Default is the left mouse button.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        menu_button: Button that opens context menus
            (if enabled) when clicked.
            Default is the right mouse button.
        mouse_location: Location where the mouse position text will be displayed.
            Default is LegendLocation.southeast.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_frame: Writable attribute to disable the drawing of the
            imgui frame.
        no_inputs: Writable attribute to disable user interactions with
            the plot.
        no_legend: Writable attribute to disable the display of the
            legend
        no_menus: Writable attribute to disable the user interactions
            to open the context menus
        no_mouse_pos: Writable attribute to disable the display of the
            mouse position
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_title: Writable attribute to disable the display of the
            plot title
        pan_button: Button that when held enables to navigate inside the plot
            Default is the left mouse button.
        pan_mod: Modifier combination (shift/ctrl/alt/super) that must be
            pressed for pan_button to have effect.
            Default is no modifier.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        use_24hour_clock: If set, times will be formatted using a 24 hour clock.
            Default is False
        use_ISO8601: If set, dates will be formatted according to ISO 8601
            where applicable (e.g. YYYY-MM-DD, YYYY-MM,
            --MM-DD, etc.)
            Default is False.
        use_local_time: If set, axis labels will be formatted for the system
            timezone when ImPlotAxisFlag_Time is enabled.
            Default is False.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        zoom_mod: Modifier combination (shift/ctrl/alt/super) that
            must be hold for the mouse wheel to trigger a zoom
            of the plot.
            Default is no modifier.
        zoom_rate: Zoom rate for scroll (e.g. 0.1 = 10% plot range every
            scroll click);
            make negative to invert.
            Default is 0.1
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X1 : PlotAxisConfig = ..., X2 : PlotAxisConfig = ..., X3 : PlotAxisConfig = ..., Y1 : PlotAxisConfig = ..., Y2 : PlotAxisConfig = ..., Y3 : PlotAxisConfig = ..., attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[plotElement] = [], crosshairs : bool = False, enabled : bool = True, equal_aspects : bool = False, fit_button : MouseButton = 0, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", legend_config : PlotLegendConfig = ..., menu_button : MouseButton = 1, mouse_location : LegendLocation = 10, next_sibling : baseItem | None = None, no_frame : bool = False, no_inputs : bool = False, no_legend : bool = False, no_menus : bool = False, no_mouse_pos : bool = False, no_newline : bool = False, no_scaling : bool = False, no_title : bool = False, pan_button : MouseButton = 0, pan_mod : KeyMod = 0, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., use_24hour_clock : bool = False, use_ISO8601 : bool = False, use_local_time : bool = False, user_data : Any = ..., value : Any = ..., width : float = 0.0, zoom_mod : KeyMod = 0, zoom_rate : float = 0.10000000149011612):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        crosshairs: Writable attribute to replace the default mouse
            cursor by a crosshair when hovered
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        equal_aspects: Writable attribute to constrain x/y axes
            pairs to have the same units/pixels
        fit_button: Button that must be double-clicked to initiate
            a fit of the axes to the displayed data.
            Default is the left mouse button.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        menu_button: Button that opens context menus
            (if enabled) when clicked.
            Default is the right mouse button.
        mouse_location: Location where the mouse position text will be displayed.
            Default is LegendLocation.southeast.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_frame: Writable attribute to disable the drawing of the
            imgui frame.
        no_inputs: Writable attribute to disable user interactions with
            the plot.
        no_legend: Writable attribute to disable the display of the
            legend
        no_menus: Writable attribute to disable the user interactions
            to open the context menus
        no_mouse_pos: Writable attribute to disable the display of the
            mouse position
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_title: Writable attribute to disable the display of the
            plot title
        pan_button: Button that when held enables to navigate inside the plot
            Default is the left mouse button.
        pan_mod: Modifier combination (shift/ctrl/alt/super) that must be
            pressed for pan_button to have effect.
            Default is no modifier.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        use_24hour_clock: If set, times will be formatted using a 24 hour clock.
            Default is False
        use_ISO8601: If set, dates will be formatted according to ISO 8601
            where applicable (e.g. YYYY-MM-DD, YYYY-MM,
            --MM-DD, etc.)
            Default is False.
        use_local_time: If set, axis labels will be formatted for the system
            timezone when ImPlotAxisFlag_Time is enabled.
            Default is False.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        zoom_mod: Modifier combination (shift/ctrl/alt/super) that
            must be hold for the mouse wheel to trigger a zoom
            of the plot.
            Default is no modifier.
        zoom_rate: Zoom rate for scroll (e.g. 0.1 = 10% plot range every
            scroll click);
            make negative to invert.
            Default is 0.1
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Plot:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X1(self) -> PlotAxisConfig:
        ...


    @X1.setter
    def X1(self, value : PlotAxisConfig):
        ...


    @property
    def X2(self) -> PlotAxisConfig:
        ...


    @X2.setter
    def X2(self, value : PlotAxisConfig):
        ...


    @property
    def X3(self) -> PlotAxisConfig:
        ...


    @X3.setter
    def X3(self, value : PlotAxisConfig):
        ...


    @property
    def Y1(self) -> PlotAxisConfig:
        ...


    @Y1.setter
    def Y1(self, value : PlotAxisConfig):
        ...


    @property
    def Y2(self) -> PlotAxisConfig:
        ...


    @Y2.setter
    def Y2(self, value : PlotAxisConfig):
        ...


    @property
    def Y3(self) -> PlotAxisConfig:
        ...


    @Y3.setter
    def Y3(self, value : PlotAxisConfig):
        ...


    @property
    def axes(self) -> list:
        """
        Helper read-only property to retrieve the 6 axes
        in an array [X1, X2, X3, Y1, Y2, Y3]
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[plotElement]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[plotElement]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def crosshairs(self) -> bool:
        """
        Writable attribute to replace the default mouse
        cursor by a crosshair when hovered
        
        """
        ...


    @crosshairs.setter
    def crosshairs(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def equal_aspects(self) -> bool:
        """
        Writable attribute to constrain x/y axes
        pairs to have the same units/pixels
        
        """
        ...


    @equal_aspects.setter
    def equal_aspects(self, value : bool):
        ...


    @property
    def fit_button(self) -> MouseButton:
        """
        Button that must be double-clicked to initiate
        a fit of the axes to the displayed data.
        Default is the left mouse button.
        
        """
        ...


    @fit_button.setter
    def fit_button(self, value : MouseButton):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_config(self) -> PlotLegendConfig:
        ...


    @legend_config.setter
    def legend_config(self, value : PlotLegendConfig):
        ...


    @property
    def menu_button(self) -> MouseButton:
        """
        Button that opens context menus
        (if enabled) when clicked.
        Default is the right mouse button.
        
        """
        ...


    @menu_button.setter
    def menu_button(self, value : MouseButton):
        ...


    @property
    def mouse_location(self) -> LegendLocation:
        """
        Location where the mouse position text will be displayed.
        Default is LegendLocation.southeast.
        
        """
        ...


    @mouse_location.setter
    def mouse_location(self, value : LegendLocation):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_frame(self) -> bool:
        """
        Writable attribute to disable the drawing of the
        imgui frame.
        
        """
        ...


    @no_frame.setter
    def no_frame(self, value : bool):
        ...


    @property
    def no_inputs(self) -> bool:
        """
        Writable attribute to disable user interactions with
        the plot.
        
        """
        ...


    @no_inputs.setter
    def no_inputs(self, value : bool):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the display of the
        legend
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def no_menus(self) -> bool:
        """
        Writable attribute to disable the user interactions
        to open the context menus
        
        """
        ...


    @no_menus.setter
    def no_menus(self, value : bool):
        ...


    @property
    def no_mouse_pos(self) -> bool:
        """
        Writable attribute to disable the display of the
        mouse position
        
        """
        ...


    @no_mouse_pos.setter
    def no_mouse_pos(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_title(self) -> bool:
        """
        Writable attribute to disable the display of the
        plot title
        
        """
        ...


    @no_title.setter
    def no_title(self, value : bool):
        ...


    @property
    def pan_button(self) -> MouseButton:
        """
        Button that when held enables to navigate inside the plot
        Default is the left mouse button.
        
        """
        ...


    @pan_button.setter
    def pan_button(self, value : MouseButton):
        ...


    @property
    def pan_mod(self) -> KeyMod:
        """
        Modifier combination (shift/ctrl/alt/super) that must be
        pressed for pan_button to have effect.
        Default is no modifier.
        
        """
        ...


    @pan_mod.setter
    def pan_mod(self, value : KeyMod):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def use_24hour_clock(self) -> bool:
        """
        If set, times will be formatted using a 24 hour clock.
        Default is False
        
        """
        ...


    @use_24hour_clock.setter
    def use_24hour_clock(self, value : bool):
        ...


    @property
    def use_ISO8601(self) -> bool:
        """
        If set, dates will be formatted according to ISO 8601
        where applicable (e.g. YYYY-MM-DD, YYYY-MM,
        --MM-DD, etc.)
        Default is False.
        
        """
        ...


    @use_ISO8601.setter
    def use_ISO8601(self, value : bool):
        ...


    @property
    def use_local_time(self) -> bool:
        """
        If set, axis labels will be formatted for the system
        timezone when ImPlotAxisFlag_Time is enabled.
        Default is False.
        
        """
        ...


    @use_local_time.setter
    def use_local_time(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


    @property
    def zoom_mod(self) -> KeyMod:
        """
        Modifier combination (shift/ctrl/alt/super) that
        must be hold for the mouse wheel to trigger a zoom
        of the plot.
        Default is no modifier.
        
        """
        ...


    @zoom_mod.setter
    def zoom_mod(self, value : KeyMod):
        ...


    @property
    def zoom_rate(self) -> float:
        """
        Zoom rate for scroll (e.g. 0.1 = 10% plot range every
        scroll click);
        make negative to invert.
        Default is 0.1
        
        """
        ...


    @zoom_rate.setter
    def zoom_rate(self, value : float):
        ...


class PlotAnnotation(plotElement):
    """
    Adds an annotation to the plot.
    Annotations are always rendered on top.
    
    """
    def __init__(self, context : Context, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., bg_color : list = [0.0, 0.0, 0.0, 0.0], children : None  = [], clamp : bool = False, label : str = "", next_sibling : baseItem | None = None, offset : tuple = (0.0, 0.0), parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, text : str = "", theme : Any = ..., user_data : Any = ..., x : float = 0.0, y : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        bg_color: Background color of the annotation
            0 means no background, in which case ImPlotCol_InlayText
            is used for the text color. Else Text is automatically
            set to white or black depending on the background color
        children: List of all the children of the item,
            from first rendered, to last rendered.
        clamp: Clamp the annotation to the plot area.
            Without this setting, the annotation will not be
            drawn if outside the plot area. Else it is displayed
            no matter what.
        label: label assigned to the element
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        offset: Offset in pixels from the plot coordinate
            at which to display the annotation
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        text: Text of the annotation
        theme: theme for the legend and plot
        user_data: User data of any type.
        x: X coordinate of the annotation in plot units
        y: Y coordinate of the annotation in plot units
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., bg_color : list = [0.0, 0.0, 0.0, 0.0], children : None  = [], clamp : bool = False, label : str = "", next_sibling : baseItem | None = None, offset : tuple = (0.0, 0.0), parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, text : str = "", theme : Any = ..., user_data : Any = ..., x : float = 0.0, y : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        bg_color: Background color of the annotation
            0 means no background, in which case ImPlotCol_InlayText
            is used for the text color. Else Text is automatically
            set to white or black depending on the background color
        children: List of all the children of the item,
            from first rendered, to last rendered.
        clamp: Clamp the annotation to the plot area.
            Without this setting, the annotation will not be
            drawn if outside the plot area. Else it is displayed
            no matter what.
        label: label assigned to the element
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        offset: Offset in pixels from the plot coordinate
            at which to display the annotation
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        text: Text of the annotation
        theme: theme for the legend and plot
        user_data: User data of any type.
        x: X coordinate of the annotation in plot units
        y: Y coordinate of the annotation in plot units
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotAnnotation:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def bg_color(self) -> list:
        """Background color of the annotation
        0 means no background, in which case ImPlotCol_InlayText
        is used for the text color. Else Text is automatically
        set to white or black depending on the background color

        Returns:
            list: RGBA values in [0,1] range
        
        """
        ...


    @bg_color.setter
    def bg_color(self, value : list):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clamp(self) -> bool:
        """Clamp the annotation to the plot area.
        Without this setting, the annotation will not be
        drawn if outside the plot area. Else it is displayed
        no matter what.
        
        """
        ...


    @clamp.setter
    def clamp(self, value : bool):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def offset(self) -> tuple:
        """Offset in pixels from the plot coordinate
        at which to display the annotation
        """
        ...


    @offset.setter
    def offset(self, value : tuple):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def text(self) -> str:
        """Text of the annotation
        """
        ...


    @text.setter
    def text(self, value : str):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def x(self) -> float:
        """X coordinate of the annotation in plot units
        """
        ...


    @x.setter
    def x(self, value : float):
        ...


    @property
    def y(self) -> float:
        """Y coordinate of the annotation in plot units
        """
        ...


    @y.setter
    def y(self, value : float):
        ...


class PlotAxisConfig(baseItem):
    def __init__(self, context : Context, attach : Any = ..., auto_fit : bool = False, before : Any = ..., children : list[baseItem] = [], constraint_max : float = inf, constraint_min : float = -inf, enabled : bool = True, foreground_grid : bool = False, format : str = "", handlers : list = [], invert : bool = False, keep_default_ticks : bool = False, label : str = "", labels : list = [], labels_coord : list = [], lock_max : bool = False, lock_min : bool = False, max : float = 1.0, min : float = 0.0, next_sibling : baseItem | None = None, no_gridlines : bool = False, no_highlight : bool = False, no_initial_fit : bool = False, no_label : bool = False, no_menus : bool = False, no_side_switch : bool = False, no_tick_labels : bool = False, no_tick_marks : bool = False, opposite : bool = False, pan_stretch : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, restrict_fit_to_range : bool = False, scale : AxisScale = 0, user_data : Any = ..., zoom_max : float = inf, zoom_min : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        auto_fit: Writable attribute to force the axis to fit its range
            to the data every frame.
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        constraint_max: Constraint on the maximum value
            of max.
        constraint_min: Constraint on the minimum value
            of min.
        enabled: Whether elements using this axis should
            be drawn.
        foreground_grid: Writable attribute to render gridlines on top of
            the data rather than behind.
        format: format string to display axis values
        handlers: bound handlers for the axis.
            Only visible, hovered and clicked handlers are compatible.
        invert: Writable attribute to invert the values of the axis
        keep_default_ticks: If set to True, when custom labels are provided via the labels property,
            the default ticks will be kept in addition to the custom labels.
            Default is False.
        label: axis name
        labels: array of strings to display as labels
        labels_coord: coordinate for each label in labels at
            which to display the labels
        lock_max: Writable attribute to lock the axis maximum value
            when panning/zooming
        lock_min: Writable attribute to lock the axis minimum value
            when panning/zooming
        max: Current maximum of the range displayed.
            Do not set max <= min. Set invert to change
            the axis order.
        min: Current minimum of the range displayed.
            Do not set max <= min. Set invert to change
            the axis order.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_gridlines: Writable attribute to not render grid lines
        no_highlight: Writable attribute to not highlight the axis background
            when hovered or held
        no_initial_fit: Writable attribute to disable fitting the extent
            of the axis to the data on the first frame.
        no_label: Writable attribute to not render the axis label
        no_menus: Writable attribute to prevent right-click to
            open context menus.
        no_side_switch: Writable attribute to prevent the user from switching
            the axis by dragging it.
        no_tick_labels: Writable attribute to not render tick labels
        no_tick_marks: Writable attribute to not render tick marks
        opposite: Writable attribute to render ticks and labels on
            the opposite side.
        pan_stretch: Writable attribute that when set, if panning in a locked or
            constrained state, will cause the axis to stretch
            if possible.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        restrict_fit_to_range: Writable attribute to ignore points that are outside
            the visible region of the opposite axis when fitting
            this axis.
        scale: Current AxisScale.
            Default is AxisScale.linear
        user_data: User data of any type.
        zoom_max: Constraint on the maximum value
            of the zoom
        zoom_min: Constraint on the minimum value
            of the zoom
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., auto_fit : bool = False, before : Any = ..., children : list[baseItem] = [], constraint_max : float = inf, constraint_min : float = -inf, enabled : bool = True, foreground_grid : bool = False, format : str = "", handlers : list = [], invert : bool = False, keep_default_ticks : bool = False, label : str = "", labels : list = [], labels_coord : list = [], lock_max : bool = False, lock_min : bool = False, max : float = 1.0, min : float = 0.0, next_sibling : baseItem | None = None, no_gridlines : bool = False, no_highlight : bool = False, no_initial_fit : bool = False, no_label : bool = False, no_menus : bool = False, no_side_switch : bool = False, no_tick_labels : bool = False, no_tick_marks : bool = False, opposite : bool = False, pan_stretch : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, restrict_fit_to_range : bool = False, scale : AxisScale = 0, user_data : Any = ..., zoom_max : float = inf, zoom_min : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        auto_fit: Writable attribute to force the axis to fit its range
            to the data every frame.
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        constraint_max: Constraint on the maximum value
            of max.
        constraint_min: Constraint on the minimum value
            of min.
        enabled: Whether elements using this axis should
            be drawn.
        foreground_grid: Writable attribute to render gridlines on top of
            the data rather than behind.
        format: format string to display axis values
        handlers: bound handlers for the axis.
            Only visible, hovered and clicked handlers are compatible.
        invert: Writable attribute to invert the values of the axis
        keep_default_ticks: If set to True, when custom labels are provided via the labels property,
            the default ticks will be kept in addition to the custom labels.
            Default is False.
        label: axis name
        labels: array of strings to display as labels
        labels_coord: coordinate for each label in labels at
            which to display the labels
        lock_max: Writable attribute to lock the axis maximum value
            when panning/zooming
        lock_min: Writable attribute to lock the axis minimum value
            when panning/zooming
        max: Current maximum of the range displayed.
            Do not set max <= min. Set invert to change
            the axis order.
        min: Current minimum of the range displayed.
            Do not set max <= min. Set invert to change
            the axis order.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_gridlines: Writable attribute to not render grid lines
        no_highlight: Writable attribute to not highlight the axis background
            when hovered or held
        no_initial_fit: Writable attribute to disable fitting the extent
            of the axis to the data on the first frame.
        no_label: Writable attribute to not render the axis label
        no_menus: Writable attribute to prevent right-click to
            open context menus.
        no_side_switch: Writable attribute to prevent the user from switching
            the axis by dragging it.
        no_tick_labels: Writable attribute to not render tick labels
        no_tick_marks: Writable attribute to not render tick marks
        opposite: Writable attribute to render ticks and labels on
            the opposite side.
        pan_stretch: Writable attribute that when set, if panning in a locked or
            constrained state, will cause the axis to stretch
            if possible.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        restrict_fit_to_range: Writable attribute to ignore points that are outside
            the visible region of the opposite axis when fitting
            this axis.
        scale: Current AxisScale.
            Default is AxisScale.linear
        user_data: User data of any type.
        zoom_max: Constraint on the maximum value
            of the zoom
        zoom_min: Constraint on the minimum value
            of the zoom
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def fit(self):
        """
        Request for a fit of min/max to the data the next time the plot is drawn
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotAxisConfig:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def auto_fit(self) -> bool:
        """
        Writable attribute to force the axis to fit its range
        to the data every frame.
        
        """
        ...


    @auto_fit.setter
    def auto_fit(self, value : bool):
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def constraint_max(self) -> float:
        """
        Constraint on the maximum value
        of max.
        
        """
        ...


    @constraint_max.setter
    def constraint_max(self, value : float):
        ...


    @property
    def constraint_min(self) -> float:
        """
        Constraint on the minimum value
        of min.
        
        """
        ...


    @constraint_min.setter
    def constraint_min(self, value : float):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Whether elements using this axis should
        be drawn.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def foreground_grid(self) -> bool:
        """
        Writable attribute to render gridlines on top of
        the data rather than behind.
        
        """
        ...


    @foreground_grid.setter
    def foreground_grid(self, value : bool):
        ...


    @property
    def format(self) -> str:
        """
        Writable attribute: format string to display axis values
        
        """
        ...


    @format.setter
    def format(self, value : str):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the axis.
        Only visible, hovered and clicked handlers are compatible.
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the axis label area
        
        """
        ...


    @property
    def invert(self) -> bool:
        """
        Writable attribute to invert the values of the axis
        
        """
        ...


    @invert.setter
    def invert(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def keep_default_ticks(self) -> bool:
        """
        If set to True, when custom labels are provided via the labels property,
        the default ticks will be kept in addition to the custom labels.
        Default is False.
        
        """
        ...


    @keep_default_ticks.setter
    def keep_default_ticks(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: axis name
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def labels(self) -> list:
        """
        Writable attribute: array of strings to display as labels
        
        """
        ...


    @labels.setter
    def labels(self, value : list):
        ...


    @property
    def labels_coord(self) -> list:
        """
        Writable attribute: coordinate for each label in labels at
        which to display the labels
        
        """
        ...


    @labels_coord.setter
    def labels_coord(self, value : list):
        ...


    @property
    def lock_max(self) -> bool:
        """
        Writable attribute to lock the axis maximum value
        when panning/zooming
        
        """
        ...


    @lock_max.setter
    def lock_max(self, value : bool):
        ...


    @property
    def lock_min(self) -> bool:
        """
        Writable attribute to lock the axis minimum value
        when panning/zooming
        
        """
        ...


    @lock_min.setter
    def lock_min(self, value : bool):
        ...


    @property
    def max(self) -> float:
        """
        Current maximum of the range displayed.
        Do not set max <= min. Set invert to change
        the axis order.
        
        """
        ...


    @max.setter
    def max(self, value : float):
        ...


    @property
    def min(self) -> float:
        """
        Current minimum of the range displayed.
        Do not set max <= min. Set invert to change
        the axis order.
        
        """
        ...


    @min.setter
    def min(self, value : float):
        ...


    @property
    def mouse_coord(self) -> float:
        """
        Readonly attribute:
        The last estimated mouse position in plot space
        for this axis.
        Beware not to assign the same instance of
        PlotAxisConfig to several axes if you plan on using
        this.
        The mouse position is updated everytime the plot is
        drawn and the axis is enabled.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_gridlines(self) -> bool:
        """
        Writable attribute to not render grid lines
        
        """
        ...


    @no_gridlines.setter
    def no_gridlines(self, value : bool):
        ...


    @property
    def no_highlight(self) -> bool:
        """
        Writable attribute to not highlight the axis background
        when hovered or held
        
        """
        ...


    @no_highlight.setter
    def no_highlight(self, value : bool):
        ...


    @property
    def no_initial_fit(self) -> bool:
        """
        Writable attribute to disable fitting the extent
        of the axis to the data on the first frame.
        
        """
        ...


    @no_initial_fit.setter
    def no_initial_fit(self, value : bool):
        ...


    @property
    def no_label(self) -> bool:
        """
        Writable attribute to not render the axis label
        
        """
        ...


    @no_label.setter
    def no_label(self, value : bool):
        ...


    @property
    def no_menus(self) -> bool:
        """
        Writable attribute to prevent right-click to
        open context menus.
        
        """
        ...


    @no_menus.setter
    def no_menus(self, value : bool):
        ...


    @property
    def no_side_switch(self) -> bool:
        """
        Writable attribute to prevent the user from switching
        the axis by dragging it.
        
        """
        ...


    @no_side_switch.setter
    def no_side_switch(self, value : bool):
        ...


    @property
    def no_tick_labels(self) -> bool:
        """
        Writable attribute to not render tick labels
        
        """
        ...


    @no_tick_labels.setter
    def no_tick_labels(self, value : bool):
        ...


    @property
    def no_tick_marks(self) -> bool:
        """
        Writable attribute to not render tick marks
        
        """
        ...


    @no_tick_marks.setter
    def no_tick_marks(self, value : bool):
        ...


    @property
    def opposite(self) -> bool:
        """
        Writable attribute to render ticks and labels on
        the opposite side.
        
        """
        ...


    @opposite.setter
    def opposite(self, value : bool):
        ...


    @property
    def pan_stretch(self) -> bool:
        """
        Writable attribute that when set, if panning in a locked or
        constrained state, will cause the axis to stretch
        if possible.
        
        """
        ...


    @pan_stretch.setter
    def pan_stretch(self, value : bool):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def restrict_fit_to_range(self) -> bool:
        """
        Writable attribute to ignore points that are outside
        the visible region of the opposite axis when fitting
        this axis.
        
        """
        ...


    @restrict_fit_to_range.setter
    def restrict_fit_to_range(self, value : bool):
        ...


    @property
    def scale(self) -> AxisScale:
        """
        Current AxisScale.
        Default is AxisScale.linear
        
        """
        ...


    @scale.setter
    def scale(self, value : AxisScale):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def zoom_max(self) -> float:
        """
        Constraint on the maximum value
        of the zoom
        
        """
        ...


    @zoom_max.setter
    def zoom_max(self, value : float):
        ...


    @property
    def zoom_min(self) -> float:
        """
        Constraint on the minimum value
        of the zoom
        
        """
        ...


    @zoom_min.setter
    def zoom_min(self, value : float):
        ...


class PlotBarGroups(plotElementWithLegend):
    def __init__(self, context : Context, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, group_size : float = 0.67, horizontal : bool = False, ignore_fit : bool = False, label : str = "", labels : list = ['Item 0'], legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, shift : float = 0.0, show : bool = True, stacked : bool = False, theme : Any = ..., user_data : Any = ..., values : ndarray = [[0.]]):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        group_size: Size of each group.
            Default is 0.67
        horizontal: Bar groups will be rendered horizontally on the current y-axis
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        labels: Array of item labels. Must match the number of rows in values.
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shift: Shift in plot units to offset groups.
            Default is 0 
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        stacked: Items in a group will be stacked on top of each other
        theme: theme for the legend and plot
        user_data: User data of any type.
        values: A row-major array with item_count rows and group_count columns.
            Each row represents one label/plotline/color.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, group_size : float = 0.67, horizontal : bool = False, ignore_fit : bool = False, label : str = "", labels : list = ['Item 0'], legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, shift : float = 0.0, show : bool = True, stacked : bool = False, theme : Any = ..., user_data : Any = ..., values : ndarray = [[0.]]):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        group_size: Size of each group.
            Default is 0.67
        horizontal: Bar groups will be rendered horizontally on the current y-axis
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        labels: Array of item labels. Must match the number of rows in values.
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shift: Shift in plot units to offset groups.
            Default is 0 
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        stacked: Items in a group will be stacked on top of each other
        theme: theme for the legend and plot
        user_data: User data of any type.
        values: A row-major array with item_count rows and group_count columns.
            Each row represents one label/plotline/color.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotBarGroups:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def group_size(self) -> float:
        """
        Size of each group.
        Default is 0.67
        
        """
        ...


    @group_size.setter
    def group_size(self, value : float):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Bar groups will be rendered horizontally on the current y-axis
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def labels(self) -> list:
        """
        Array of item labels. Must match the number of rows in values.
        
        """
        ...


    @labels.setter
    def labels(self, value : list):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def shift(self) -> float:
        """
        Shift in plot units to offset groups.
        Default is 0 
        
        """
        ...


    @shift.setter
    def shift(self, value : float):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def stacked(self) -> bool:
        """
        Items in a group will be stacked on top of each other
        
        """
        ...


    @stacked.setter
    def stacked(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def values(self) -> ndarray:
        """
        A row-major array with item_count rows and group_count columns.
        Each row represents one label/plotline/color.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @values.setter
    def values(self, value : ndarray):
        ...


class PlotBars(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ..., weight : float = 1.0):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Bars will be rendered horizontally
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        weight: bar_size. TODO better document
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ..., weight : float = 1.0):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Bars will be rendered horizontally
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        weight: bar_size. TODO better document
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotBars:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Bars will be rendered horizontally
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def weight(self) -> float:
        """
        bar_size. TODO better document
        
        """
        ...


    @weight.setter
    def weight(self, value : float):
        ...


class PlotDigital(plotElementXY):
    """
    Plots a digital signal as a step function from X,Y data.
    Digital plots are always referenced to the bottom of the plot,
    do not respond to y axis zooming.
    
    """
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotDigital:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotInfLines(plotElementX):
    """
    Draw vertical (or horizontal) infinite lines at
    the passed coordinates
    
    """
    def __init__(self, context : Context, X : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Plot horizontal lines rather than plots
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Plot horizontal lines rather than plots
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotInfLines:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Plot horizontal lines rather than plots
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotLegendConfig(baseItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], horizontal : bool = False, location : LegendLocation = 5, next_sibling : baseItem | None = None, no_buttons : bool = False, no_highlight_axis : bool = False, no_highlight_item : bool = False, no_menus : bool = False, outside : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, sorted : bool = False, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        horizontal: Writable attribute to display the legend entries
            horizontally rather than vertically
        location: Position of the legend.
            Default is LegendLocation.northwest
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_buttons: Writable attribute to prevent legend icons
            to function as hide/show buttons
        no_highlight_axis: Writable attribute to disable highlighting axes
            when their legend entry is hovered
            (only relevant if x/y-axis count > 1)
        no_highlight_item: Writable attribute to disable highlighting plot items
            when their legend entry is hovered
        no_menus: Writable attribute to disable right-clicking
            to open context menus.
        outside: Writable attribute to render the legend outside
            of the plot area
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        sorted: Writable attribute to display the legend entries
            in alphabetical order
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], horizontal : bool = False, location : LegendLocation = 5, next_sibling : baseItem | None = None, no_buttons : bool = False, no_highlight_axis : bool = False, no_highlight_item : bool = False, no_menus : bool = False, outside : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, sorted : bool = False, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        horizontal: Writable attribute to display the legend entries
            horizontally rather than vertically
        location: Position of the legend.
            Default is LegendLocation.northwest
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_buttons: Writable attribute to prevent legend icons
            to function as hide/show buttons
        no_highlight_axis: Writable attribute to disable highlighting axes
            when their legend entry is hovered
            (only relevant if x/y-axis count > 1)
        no_highlight_item: Writable attribute to disable highlighting plot items
            when their legend entry is hovered
        no_menus: Writable attribute to disable right-clicking
            to open context menus.
        outside: Writable attribute to render the legend outside
            of the plot area
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        sorted: Writable attribute to display the legend entries
            in alphabetical order
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotLegendConfig:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def horizontal(self) -> bool:
        """
        Writable attribute to display the legend entries
        horizontally rather than vertically
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def location(self) -> LegendLocation:
        """
        Position of the legend.
        Default is LegendLocation.northwest
        
        """
        ...


    @location.setter
    def location(self, value : LegendLocation):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_buttons(self) -> bool:
        """
        Writable attribute to prevent legend icons
        to function as hide/show buttons
        
        """
        ...


    @no_buttons.setter
    def no_buttons(self, value : bool):
        ...


    @property
    def no_highlight_axis(self) -> bool:
        """
        Writable attribute to disable highlighting axes
        when their legend entry is hovered
        (only relevant if x/y-axis count > 1)
        
        """
        ...


    @no_highlight_axis.setter
    def no_highlight_axis(self, value : bool):
        ...


    @property
    def no_highlight_item(self) -> bool:
        """
        Writable attribute to disable highlighting plot items
        when their legend entry is hovered
        
        """
        ...


    @no_highlight_item.setter
    def no_highlight_item(self, value : bool):
        ...


    @property
    def no_menus(self) -> bool:
        """
        Writable attribute to disable right-clicking
        to open context menus.
        
        """
        ...


    @no_menus.setter
    def no_menus(self, value : bool):
        ...


    @property
    def outside(self) -> bool:
        """
        Writable attribute to render the legend outside
        of the plot area
        
        """
        ...


    @outside.setter
    def outside(self, value : bool):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def sorted(self) -> bool:
        """
        Writable attribute to display the legend entries
        in alphabetical order
        
        """
        ...


    @sorted.setter
    def sorted(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotLine(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], loop : bool = False, next_sibling : baseItem | None = None, no_clip : bool = False, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, segments : bool = False, shaded : bool = False, show : bool = True, skip_nan : bool = False, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        loop: Connect the first and last points
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Markers (if displayed) on the edge of a plot will not be clipped.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        segments: Plot segments rather than a full line
        shaded: A filled region between the line and horizontal
            origin will be rendered.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        skip_nan: A NaN data point will be ignored instead of
            being rendered as missing data.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], loop : bool = False, next_sibling : baseItem | None = None, no_clip : bool = False, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, segments : bool = False, shaded : bool = False, show : bool = True, skip_nan : bool = False, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        loop: Connect the first and last points
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Markers (if displayed) on the edge of a plot will not be clipped.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        segments: Plot segments rather than a full line
        shaded: A filled region between the line and horizontal
            origin will be rendered.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        skip_nan: A NaN data point will be ignored instead of
            being rendered as missing data.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotLine:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def loop(self) -> bool:
        """
        Connect the first and last points
        
        """
        ...


    @loop.setter
    def loop(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_clip(self) -> bool:
        """
        Markers (if displayed) on the edge of a plot will not be clipped.
        
        """
        ...


    @no_clip.setter
    def no_clip(self, value : bool):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def segments(self) -> bool:
        """
        Plot segments rather than a full line
        
        """
        ...


    @segments.setter
    def segments(self, value : bool):
        ...


    @property
    def shaded(self) -> bool:
        """
        A filled region between the line and horizontal
        origin will be rendered.
        
        """
        ...


    @shaded.setter
    def shaded(self, value : bool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def skip_nan(self) -> bool:
        """
        A NaN data point will be ignored instead of
        being rendered as missing data.
        
        """
        ...


    @skip_nan.setter
    def skip_nan(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotPieChart(plotElementWithLegend):
    """
    Plots a pie chart with the given values and labels.
    The pie chart is centered at (x,y) with the given radius.
    
    """
    def __init__(self, context : Context, angle : float = 90.0, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, ignore_hidden : bool = False, label : str = "", labels : list = ['Slice 0'], legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, normalize : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, radius : float = 1.0, show : bool = True, theme : Any = ..., user_data : Any = ..., values : ndarray = [0.], x : float = 0.0, y : float = 0.0):
        """

        angle: Starting angle for first slice in degrees. Default is 90.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        ignore_hidden: Ignore hidden slices when drawing the pie chart
            (as if they were not there)
        label: label assigned to the element
        labels: Array of labels for each pie slice. Must match the number of values.
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        normalize: Force normalization of pie chart values (i.e. always make
            a full circle if sum < 0)
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        radius: Radius of pie chart in plot units
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        values: Array of values for each pie slice.
        x: X coordinate of pie chart center in plot units
        y: Y coordinate of pie chart center in plot units
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, angle : float = 90.0, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, ignore_hidden : bool = False, label : str = "", labels : list = ['Slice 0'], legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, normalize : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, radius : float = 1.0, show : bool = True, theme : Any = ..., user_data : Any = ..., values : ndarray = [0.], x : float = 0.0, y : float = 0.0):
        """
        angle: Starting angle for first slice in degrees. Default is 90.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        ignore_hidden: Ignore hidden slices when drawing the pie chart
            (as if they were not there)
        label: label assigned to the element
        labels: Array of labels for each pie slice. Must match the number of values.
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        normalize: Force normalization of pie chart values (i.e. always make
            a full circle if sum < 0)
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        radius: Radius of pie chart in plot units
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        values: Array of values for each pie slice.
        x: X coordinate of pie chart center in plot units
        y: Y coordinate of pie chart center in plot units
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotPieChart:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def angle(self) -> float:
        """Starting angle for first slice in degrees. Default is 90.
        """
        ...


    @angle.setter
    def angle(self, value : float):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def ignore_hidden(self) -> bool:
        """
        Ignore hidden slices when drawing the pie chart
        (as if they were not there)
        
        """
        ...


    @ignore_hidden.setter
    def ignore_hidden(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def labels(self) -> list:
        """
        Array of labels for each pie slice. Must match the number of values.
        
        """
        ...


    @labels.setter
    def labels(self, value : list):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def normalize(self) -> bool:
        """
        Force normalization of pie chart values (i.e. always make
        a full circle if sum < 0)
        
        """
        ...


    @normalize.setter
    def normalize(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def radius(self) -> float:
        """Radius of pie chart in plot units
        """
        ...


    @radius.setter
    def radius(self, value : float):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def values(self) -> ndarray:
        """
        Array of values for each pie slice.

        By default, will try to use the passed array directly for its 
        internal backing (no copy). Supported types for no copy are 
        np.int32, np.float32, np.float64.
        
        """
        ...


    @values.setter
    def values(self, value : ndarray):
        ...


    @property
    def x(self) -> float:
        """X coordinate of pie chart center in plot units
        """
        ...


    @x.setter
    def x(self, value : float):
        ...


    @property
    def y(self) -> float:
        """Y coordinate of pie chart center in plot units
        """
        ...


    @y.setter
    def y(self, value : float):
        ...


class PlotScatter(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_clip : bool = False, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Markers on the edge of a plot will not be clipped
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_clip : bool = False, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Markers on the edge of a plot will not be clipped
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotScatter:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_clip(self) -> bool:
        """
        Markers on the edge of a plot will not be clipped
        
        """
        ...


    @no_clip.setter
    def no_clip(self, value : bool):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotShadedLine(plotElementXYY):
    def __init__(self, context : Context, X : ndarray = [0.], Y1 : ndarray = [0.], Y2 : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y1 : ndarray = [0.], Y2 : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotShadedLine:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y1(self) -> ndarray:
        ...


    @Y1.setter
    def Y1(self, value : ndarray):
        ...


    @property
    def Y2(self) -> ndarray:
        ...


    @Y2.setter
    def Y2(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotStairs(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, pre_step : bool = False, previous_sibling : baseItem | None = None, shaded : bool = False, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        pre_step: The y value is continued constantly to the left
            from every x position, i.e. the interval
            (x[i-1], x[i]] has the value y[i].
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shaded: a filled region between the stairs and horizontal
            origin will be rendered; use PlotShadedLine for
            more advanced cases.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, pre_step : bool = False, previous_sibling : baseItem | None = None, shaded : bool = False, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        pre_step: The y value is continued constantly to the left
            from every x position, i.e. the interval
            (x[i-1], x[i]] has the value y[i].
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shaded: a filled region between the stairs and horizontal
            origin will be rendered; use PlotShadedLine for
            more advanced cases.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotStairs:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pre_step(self) -> bool:
        """
        The y value is continued constantly to the left
        from every x position, i.e. the interval
        (x[i-1], x[i]] has the value y[i].
        
        """
        ...


    @pre_step.setter
    def pre_step(self, value : bool):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def shaded(self) -> bool:
        """
        a filled region between the stairs and horizontal
        origin will be rendered; use PlotShadedLine for
        more advanced cases.
        
        """
        ...


    @shaded.setter
    def shaded(self, value : bool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotStems(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Stems will be rendered horizontally
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Stems will be rendered horizontally
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotStems:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Stems will be rendered horizontally
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ProgressBar(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, overlay : str = "", parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedFloat = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : float = 0.0, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        overlay: 
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, overlay : str = "", parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedFloat = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : float = 0.0, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        overlay: 
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ProgressBar:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def overlay(self) -> str:
        """
        Writable attribute:
        
        """
        ...


    @overlay.setter
    def overlay(self, value : str):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedFloat:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedFloat):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> float:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : float):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class RadioButton(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, horizontal : bool = False, indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedStr = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : str = "", width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal: Horizontal vs vertical placement
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, horizontal : bool = False, indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedStr = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : str = "", width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal: Horizontal vs vertical placement
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> RadioButton:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Writable attribute: Horizontal vs vertical placement
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def items(self) -> list:
        """
        Writable attribute: List of text values to select
        
        """
        ...


    @items.setter
    def items(self, value : list):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class RenderHandler(baseHandler):
    """
    Handler that calls the callback
    whenever the item is rendered during
    frame rendering. This doesn't mean
    that the item is visible as it can be
    occluded by an item in front of it.
    Usually rendering skips items that
    are outside the window's clipping region,
    or items that are inside a menu that is
    currently closed.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> RenderHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ResizeHandler(baseHandler):
    """
    Handler that triggers the callback
    whenever the item's bounding box changes size.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ResizeHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Selectable(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], disable_popup_close : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, highlighted : bool = False, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, span_columns : bool = False, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        disable_popup_close: Clicking this doesn't close parent popup window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        highlighted: highlighted as if hovered
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        on_double_click: call callbacks on double clicks too
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        span_columns: Frame will span all columns of its container table (text will still fit in current column)
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], disable_popup_close : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, highlighted : bool = False, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, span_columns : bool = False, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        disable_popup_close: Clicking this doesn't close parent popup window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        highlighted: highlighted as if hovered
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        on_double_click: call callbacks on double clicks too
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        span_columns: Frame will span all columns of its container table (text will still fit in current column)
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Selectable:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def disable_popup_close(self) -> bool:
        """
        Writable attribute: Clicking this doesn't close parent popup window
        
        """
        ...


    @disable_popup_close.setter
    def disable_popup_close(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def highlighted(self) -> bool:
        """
        Writable attribute: highlighted as if hovered
        
        """
        ...


    @highlighted.setter
    def highlighted(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def on_double_click(self) -> bool:
        """
        Writable attribute: call callbacks on double clicks too
        
        """
        ...


    @on_double_click.setter
    def on_double_click(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def span_columns(self) -> bool:
        """
        Writable attribute: Frame will span all columns of its container table (text will still fit in current column)
        
        """
        ...


    @span_columns.setter
    def span_columns(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Separator(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Separator:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class SharedBool(SharedValue):
    def __init__(self, context : Context, value : bool):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        ...


    @property
    def value(self) -> bool:
        ...


    @value.setter
    def value(self, value : bool):
        ...


class SharedColor(SharedValue):
    def __init__(self, context : Context, value : int):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedColor:
        ...


    @property
    def value(self) -> int:
        ...


    @value.setter
    def value(self, value : int):
        ...


class SharedDouble(SharedValue):
    def __init__(self, context : Context, value : float):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedDouble:
        ...


    @property
    def value(self) -> float:
        ...


    @value.setter
    def value(self, value : float):
        ...


class SharedDouble4(SharedValue):
    def __init__(self, context : Context, value : list):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedDouble4:
        ...


    @property
    def value(self) -> list:
        ...


    @value.setter
    def value(self, value : list):
        ...


class SharedFloat(SharedValue):
    def __init__(self, context : Context, value : float):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedFloat:
        ...


    @property
    def value(self) -> float:
        ...


    @value.setter
    def value(self, value : float):
        ...


class SharedFloat4(SharedValue):
    def __init__(self, context : Context, value : list):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedFloat4:
        ...


    @property
    def value(self) -> list:
        ...


    @value.setter
    def value(self, value : list):
        ...


class SharedFloatVect(SharedValue):
    def __init__(self, context : Context, value : Any):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedFloatVect:
        ...


    @property
    def value(self):
        ...


    @value.setter
    def value(self, value):
        ...


class SharedInt(SharedValue):
    def __init__(self, context : Context, value : int):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedInt:
        ...


    @property
    def value(self) -> int:
        ...


    @value.setter
    def value(self, value : int):
        ...


class SharedInt4(SharedValue):
    def __init__(self, context : Context, value : list):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedInt4:
        ...


    @property
    def value(self) -> list:
        ...


    @value.setter
    def value(self, value : list):
        ...


class SharedStr(SharedValue):
    def __init__(self, context : Context, value : str):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedStr:
        ...


    @property
    def value(self) -> str:
        ...


    @value.setter
    def value(self, value : str):
        ...


class SharedValue(object):
    """
    Represents a shared value that can be used by multiple items.

    Attributes:
    - value: Main value of the shared object.
    - shareable_value: Shareable value of the shared object.
    - last_frame_update: Last frame index when the value was updated.
    - last_frame_change: Last frame index when the value was changed.
    - num_attached: Number of items sharing this value.
    
    """
    def __init__(self, context : Context, value : Any):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        ...


    @property
    def value(self):
        ...


    @value.setter
    def value(self, value):
        ...


class SimplePlot(uiItem):
    def __init__(self, context : Context, attach : Any = ..., autoscale : bool = True, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, histogram : bool = False, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, overlay : bytes = b'', parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scale_max : float = 0.0, scale_min : float = 0.0, scaling_factor : float = 1.0, shareable_value : SharedFloatVect = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        autoscale: Whether scale_min and scale_max should be deduced
            from the data
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        histogram: Whether the data should be plotted as an histogram
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        overlay: Overlay text
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scale_max: value corresponding to the maximum value of plot scale
        scale_min: value corresponding to the minimum value of plot scale
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., autoscale : bool = True, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, histogram : bool = False, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, overlay : bytes = b'', parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scale_max : float = 0.0, scale_min : float = 0.0, scaling_factor : float = 1.0, shareable_value : SharedFloatVect = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        autoscale: Whether scale_min and scale_max should be deduced
            from the data
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        histogram: Whether the data should be plotted as an histogram
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        overlay: Overlay text
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scale_max: value corresponding to the maximum value of plot scale
        scale_min: value corresponding to the minimum value of plot scale
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> SimplePlot:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def autoscale(self) -> bool:
        """
        Writable attribute: Whether scale_min and scale_max should be deduced
        from the data
        
        """
        ...


    @autoscale.setter
    def autoscale(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def histogram(self) -> bool:
        """
        Writable attribute: Whether the data should be plotted as an histogram
        
        """
        ...


    @histogram.setter
    def histogram(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def overlay(self) -> bytes:
        """
        Writable attribute: Overlay text
        
        """
        ...


    @overlay.setter
    def overlay(self, value : bytes):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scale_max(self) -> float:
        """
        Writable attribute: value corresponding to the maximum value of plot scale
        
        """
        ...


    @scale_max.setter
    def scale_max(self, value : float):
        ...


    @property
    def scale_min(self) -> float:
        """
        Writable attribute: value corresponding to the minimum value of plot scale
        
        """
        ...


    @scale_min.setter
    def scale_min(self, value : float):
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedFloatVect:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedFloatVect):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Slider(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], clamped : bool = False, drag : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, format : str = "float", handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", logarithmic : bool = False, max_value : float = 100.0, min_value : float = 0.0, next_sibling : baseItem | None = None, no_input : bool = False, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, print_format : str = "%.3f", round_to_format : bool = True, scaling_factor : float = 1.0, shareable_value : SharedFloat = ..., show : bool = True, size : int = 1, speed : float = 1.0, theme : Any = ..., user_data : Any = ..., value : float = 0.0, vertical : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        clamped: Whether the slider value should be clamped even when keyboard set
        drag: Whether the use a 'drag'
            slider rather than a regular one.
            Incompatible with 'vertical'.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        format: Format of the slider.
            Must be "int", "float" or "double".
            Note that float here means the 32 bits version.
            The python float corresponds to a double.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        logarithmic: Make the slider logarithmic.
            Disables round_to_format if enabled
        max_value: Maximum value the slider
            will be clamped to.
        min_value: Minimum value the slider
            will be clamped to.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: Disable Ctrl+Click and Enter key to
            manually set the value
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        print_format: format string
            for the value -> string conversion
            for display. If round_to_format is
            enabled, the value is converted
            back and thus appears rounded.
        round_to_format: If set (default),
            the value will not have more digits precision
            than the requested format string for display.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Size of the slider.
            Can be 1, 2, 3 or 4.
            When 1 the item's value is held with
            a scalar shared value, else it is held
            with a vector of 4 elements (even for
            size 2 and 3)
        speed: When drag is true,
            this attributes sets the drag speed.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        vertical: Whether the use a vertical
            slider. Only sliders of size 1 and drag False
            are supported.
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], clamped : bool = False, drag : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, format : str = "float", handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", logarithmic : bool = False, max_value : float = 100.0, min_value : float = 0.0, next_sibling : baseItem | None = None, no_input : bool = False, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, print_format : str = "%.3f", round_to_format : bool = True, scaling_factor : float = 1.0, shareable_value : SharedFloat = ..., show : bool = True, size : int = 1, speed : float = 1.0, theme : Any = ..., user_data : Any = ..., value : float = 0.0, vertical : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        clamped: Whether the slider value should be clamped even when keyboard set
        drag: Whether the use a 'drag'
            slider rather than a regular one.
            Incompatible with 'vertical'.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        format: Format of the slider.
            Must be "int", "float" or "double".
            Note that float here means the 32 bits version.
            The python float corresponds to a double.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        logarithmic: Make the slider logarithmic.
            Disables round_to_format if enabled
        max_value: Maximum value the slider
            will be clamped to.
        min_value: Minimum value the slider
            will be clamped to.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: Disable Ctrl+Click and Enter key to
            manually set the value
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        print_format: format string
            for the value -> string conversion
            for display. If round_to_format is
            enabled, the value is converted
            back and thus appears rounded.
        round_to_format: If set (default),
            the value will not have more digits precision
            than the requested format string for display.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Size of the slider.
            Can be 1, 2, 3 or 4.
            When 1 the item's value is held with
            a scalar shared value, else it is held
            with a vector of 4 elements (even for
            size 2 and 3)
        speed: When drag is true,
            this attributes sets the drag speed.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        vertical: Whether the use a vertical
            slider. Only sliders of size 1 and drag False
            are supported.
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Slider:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clamped(self) -> bool:
        """
        Writable attribute: Whether the slider value should be clamped even when keyboard set
        
        """
        ...


    @clamped.setter
    def clamped(self, value : bool):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def drag(self) -> bool:
        """
        Writable attribute: Whether the use a 'drag'
        slider rather than a regular one.
        Incompatible with 'vertical'.
        
        """
        ...


    @drag.setter
    def drag(self, value : bool):
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def format(self) -> str:
        """
        Writable attribute: Format of the slider.
        Must be "int", "float" or "double".
        Note that float here means the 32 bits version.
        The python float corresponds to a double.
        
        """
        ...


    @format.setter
    def format(self, value : str):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def logarithmic(self) -> bool:
        """
        Writable attribute: Make the slider logarithmic.
        Disables round_to_format if enabled
        
        """
        ...


    @logarithmic.setter
    def logarithmic(self, value : bool):
        ...


    @property
    def max_value(self) -> float:
        """
        Writable attribute: Maximum value the slider
        will be clamped to.
        
        """
        ...


    @max_value.setter
    def max_value(self, value : float):
        ...


    @property
    def min_value(self) -> float:
        """
        Writable attribute: Minimum value the slider
        will be clamped to.
        
        """
        ...


    @min_value.setter
    def min_value(self, value : float):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_input(self) -> bool:
        """
        Writable attribute: Disable Ctrl+Click and Enter key to
        manually set the value
        
        """
        ...


    @no_input.setter
    def no_input(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def print_format(self) -> str:
        """
        Writable attribute: format string
        for the value -> string conversion
        for display. If round_to_format is
        enabled, the value is converted
        back and thus appears rounded.
        
        """
        ...


    @print_format.setter
    def print_format(self, value : str):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def round_to_format(self) -> bool:
        """
        Writable attribute: If set (default),
        the value will not have more digits precision
        than the requested format string for display.
        
        """
        ...


    @round_to_format.setter
    def round_to_format(self, value : bool):
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedFloat:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedFloat):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def size(self) -> int:
        """
        Writable attribute: Size of the slider.
        Can be 1, 2, 3 or 4.
        When 1 the item's value is held with
        a scalar shared value, else it is held
        with a vector of 4 elements (even for
        size 2 and 3)
        
        """
        ...


    @size.setter
    def size(self, value : int):
        ...


    @property
    def speed(self) -> float:
        """
        Writable attribute: When drag is true,
        this attributes sets the drag speed.
        
        """
        ...


    @speed.setter
    def speed(self, value : float):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> float:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : float):
        ...


    @property
    def vertical(self) -> bool:
        """
        Writable attribute: Whether the use a vertical
        slider. Only sliders of size 1 and drag False
        are supported.
        
        """
        ...


    @vertical.setter
    def vertical(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Spacer(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Spacer:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Subplots(uiItem):
    """
    Creates a grid of plots that share various axis properties.
    
    Can have Plot items as children. The plots are added in row-major order
    by default (can be changed to column major).

    Attributes:
    - rows (int): Number of subplot rows 
    - cols (int): Number of subplot columns
    - row_ratios (List[float]): Size ratios for each row
    - col_ratios (List[float]): Size ratios for each column
    - no_legend (bool): Hide subplot legends (if share_legends is True)
    - no_title (bool): Hide subplot titles
    - no_menus (bool): Disable context menus
    - no_resize (bool): Disable subplot resize splitters 
    - no_align (bool): Disable subplot edge alignment
    - col_major (bool): Add plots in column-major order
    - share_legends (bool): Share legend items across subplots
    - share_rows (bool): Link X1/Y1-axis limits by rows
    - share_cols (bool): Link X1/Y1-axis limits by columns
    - share_x_all (bool): Link X1-axis limits across all plots
    - share_y_all (bool): Link Y1-axis limits across all plots
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], col_major : bool = False, col_ratios : list = [], cols : int = 1, enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_align : bool = False, no_menus : bool = False, no_newline : bool = False, no_resize : bool = False, no_scaling : bool = False, no_title : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, row_ratios : list = [], rows : int = 1, scaling_factor : float = 1.0, share_cols : bool = False, share_legends : bool = False, share_rows : bool = False, share_x_all : bool = False, share_y_all : bool = False, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        col_major: Add plots in column-major order
        col_ratios: Size ratios for subplot columns
        cols: Number of subplot columns
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_align: Disable subplot edge alignment
        no_menus: Disable subplot context menus
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_resize: Disable subplot resize splitters
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_title: Hide subplot titles
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        row_ratios: Size ratios for subplot rows
        rows: Number of subplot rows
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        share_cols: Link X1/Y1-axis limits within each column
        share_legends: Share legend items across subplots
        share_rows: Link X1/Y1-axis limits within each row
        share_x_all: Link X1-axis limits across all plots
        share_y_all: Link Y1-axis limits across all plots
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], col_major : bool = False, col_ratios : list = [], cols : int = 1, enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_align : bool = False, no_menus : bool = False, no_newline : bool = False, no_resize : bool = False, no_scaling : bool = False, no_title : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, row_ratios : list = [], rows : int = 1, scaling_factor : float = 1.0, share_cols : bool = False, share_legends : bool = False, share_rows : bool = False, share_x_all : bool = False, share_y_all : bool = False, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        col_major: Add plots in column-major order
        col_ratios: Size ratios for subplot columns
        cols: Number of subplot columns
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_align: Disable subplot edge alignment
        no_menus: Disable subplot context menus
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_resize: Disable subplot resize splitters
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_title: Hide subplot titles
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        row_ratios: Size ratios for subplot rows
        rows: Number of subplot rows
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        share_cols: Link X1/Y1-axis limits within each column
        share_legends: Share legend items across subplots
        share_rows: Link X1/Y1-axis limits within each row
        share_x_all: Link X1-axis limits across all plots
        share_y_all: Link Y1-axis limits across all plots
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Subplots:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def col_major(self) -> bool:
        """Add plots in column-major order
        """
        ...


    @col_major.setter
    def col_major(self, value : bool):
        ...


    @property
    def col_ratios(self) -> list:
        """Size ratios for subplot columns
        """
        ...


    @col_ratios.setter
    def col_ratios(self, value : list):
        ...


    @property
    def cols(self) -> int:
        """Number of subplot columns
        """
        ...


    @cols.setter
    def cols(self, value : int):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_align(self) -> bool:
        """Disable subplot edge alignment
        """
        ...


    @no_align.setter
    def no_align(self, value : bool):
        ...


    @property
    def no_legend(self) -> bool:
        """Hide subplot legends
        """
        ...


    @property
    def no_menus(self) -> bool:
        """Disable subplot context menus
        """
        ...


    @no_menus.setter
    def no_menus(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_resize(self) -> bool:
        """Disable subplot resize splitters
        """
        ...


    @no_resize.setter
    def no_resize(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_title(self) -> bool:
        """Hide subplot titles
        """
        ...


    @no_title.setter
    def no_title(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def row_ratios(self) -> list:
        """Size ratios for subplot rows
        """
        ...


    @row_ratios.setter
    def row_ratios(self, value : list):
        ...


    @property
    def rows(self) -> int:
        """Number of subplot rows
        """
        ...


    @rows.setter
    def rows(self, value : int):
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def share_cols(self) -> bool:
        """Link X1/Y1-axis limits within each column
        """
        ...


    @share_cols.setter
    def share_cols(self, value : bool):
        ...


    @property
    def share_legends(self) -> bool:
        """Share legend items across subplots
        """
        ...


    @share_legends.setter
    def share_legends(self, value : bool):
        ...


    @property
    def share_rows(self) -> bool:
        """Link X1/Y1-axis limits within each row
        """
        ...


    @share_rows.setter
    def share_rows(self, value : bool):
        ...


    @property
    def share_x_all(self) -> bool:
        """Link X1-axis limits across all plots
        """
        ...


    @share_x_all.setter
    def share_x_all(self, value : bool):
        ...


    @property
    def share_y_all(self) -> bool:
        """Link Y1-axis limits across all plots
        """
        ...


    @share_y_all.setter
    def share_y_all(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Tab(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], closable : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", leading : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_reorder : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., trailing : bool = False, user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closable: Can the tab be closed
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leading: Enforce the tab position to the
            left of the tab bar (after the tab list popup button)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_reorder: Disable reordering this tab or
            having another tab cross over this tab
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: Disable tooltip for the given tab
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        trailing: Enforce the tab position to the
            right of the tab bar (before the scrolling buttons)
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], closable : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", leading : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_reorder : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., trailing : bool = False, user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closable: Can the tab be closed
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leading: Enforce the tab position to the
            left of the tab bar (after the tab list popup button)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_reorder: Disable reordering this tab or
            having another tab cross over this tab
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: Disable tooltip for the given tab
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        trailing: Enforce the tab position to the
            right of the tab bar (before the scrolling buttons)
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Tab:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def closable(self) -> bool:
        """
        Writable attribute: Can the tab be closed
        
        """
        ...


    @closable.setter
    def closable(self, value : bool):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def leading(self) -> bool:
        """
        Writable attribute: Enforce the tab position to the
        left of the tab bar (after the tab list popup button)
        
        """
        ...


    @leading.setter
    def leading(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_reorder(self) -> bool:
        """
        Writable attribute: Disable reordering this tab or
        having another tab cross over this tab
        
        """
        ...


    @no_reorder.setter
    def no_reorder(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: Disable tooltip for the given tab
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def trailing(self) -> bool:
        """
        Writable attribute: Enforce the tab position to the
        right of the tab bar (before the scrolling buttons)
        
        """
        ...


    @trailing.setter
    def trailing(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class TabBar(uiItem):
    def __init__(self, context : Context, allow_tab_scroll : bool = False, attach : Any = ..., autoselect_new_tabs : bool = False, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_close_with_middle_mouse_button : bool = False, no_newline : bool = False, no_scaling : bool = False, no_scrolling_button : bool = False, no_tab_list_popup_button : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, reorderable : bool = False, resize_to_fit : bool = False, scaling_factor : float = 1.0, selected_overline : bool = False, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        allow_tab_scroll: Add scroll buttons when tabs don't fit
        attach: Whether to attach the item to a parent. Default is None (auto)
        autoselect_new_tabs: Automatically select new
            tabs when they appear
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_close_with_middle_mouse_button: Disable behavior of closing tabs with middle mouse button.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scrolling_button: Disable scrolling buttons
        no_tab_list_popup_button: Disable buttons to open the tab list popup
        no_tooltip: Disable tooltip for all tabs
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        reorderable: Allow manually dragging tabs
            to re-order them + New tabs are appended at the end of list
        resize_to_fit: Resize tabs when they don't fit
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        selected_overline: Draw selected overline markers over selected tab
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, allow_tab_scroll : bool = False, attach : Any = ..., autoselect_new_tabs : bool = False, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_close_with_middle_mouse_button : bool = False, no_newline : bool = False, no_scaling : bool = False, no_scrolling_button : bool = False, no_tab_list_popup_button : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, reorderable : bool = False, resize_to_fit : bool = False, scaling_factor : float = 1.0, selected_overline : bool = False, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        allow_tab_scroll: Add scroll buttons when tabs don't fit
        attach: Whether to attach the item to a parent. Default is None (auto)
        autoselect_new_tabs: Automatically select new
            tabs when they appear
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_close_with_middle_mouse_button: Disable behavior of closing tabs with middle mouse button.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scrolling_button: Disable scrolling buttons
        no_tab_list_popup_button: Disable buttons to open the tab list popup
        no_tooltip: Disable tooltip for all tabs
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        reorderable: Allow manually dragging tabs
            to re-order them + New tabs are appended at the end of list
        resize_to_fit: Resize tabs when they don't fit
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        selected_overline: Draw selected overline markers over selected tab
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TabBar:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def allow_tab_scroll(self) -> bool:
        """
        Writable attribute: Add scroll buttons when tabs don't fit
        
        """
        ...


    @allow_tab_scroll.setter
    def allow_tab_scroll(self, value : bool):
        ...


    @property
    def autoselect_new_tabs(self) -> bool:
        """
        Writable attribute: Automatically select new
        tabs when they appear
        
        """
        ...


    @autoselect_new_tabs.setter
    def autoselect_new_tabs(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_close_with_middle_mouse_button(self) -> bool:
        """
        Writable attribute: Disable behavior of closing tabs with middle mouse button.
        
        """
        ...


    @no_close_with_middle_mouse_button.setter
    def no_close_with_middle_mouse_button(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_scrolling_button(self) -> bool:
        """
        Writable attribute: Disable scrolling buttons
        
        """
        ...


    @no_scrolling_button.setter
    def no_scrolling_button(self, value : bool):
        ...


    @property
    def no_tab_list_popup_button(self) -> bool:
        """
        Writable attribute: Disable buttons to open the tab list popup
        
        """
        ...


    @no_tab_list_popup_button.setter
    def no_tab_list_popup_button(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: Disable tooltip for all tabs
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def reorderable(self) -> bool:
        """
        Writable attribute: Allow manually dragging tabs
        to re-order them + New tabs are appended at the end of list
        
        """
        ...


    @reorderable.setter
    def reorderable(self, value : bool):
        ...


    @property
    def resize_to_fit(self) -> bool:
        """
        Writable attribute: Resize tabs when they don't fit
        
        """
        ...


    @resize_to_fit.setter
    def resize_to_fit(self, value : bool):
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def selected_overline(self) -> bool:
        """
        Writable attribute: Draw selected overline markers over selected tab
        
        """
        ...


    @selected_overline.setter
    def selected_overline(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class TabButton(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", leading : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_reorder : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., trailing : bool = False, user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leading: Enforce the tab position to the
            left of the tab bar (after the tab list popup button)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_reorder: Disable reordering this tab or
            having another tab cross over this tab
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: Disable tooltip for the given tab
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        trailing: Enforce the tab position to the
            right of the tab bar (before the scrolling buttons)
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", leading : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_reorder : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedBool = ..., show : bool = True, theme : Any = ..., trailing : bool = False, user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leading: Enforce the tab position to the
            left of the tab bar (after the tab list popup button)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_reorder: Disable reordering this tab or
            having another tab cross over this tab
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: Disable tooltip for the given tab
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        trailing: Enforce the tab position to the
            right of the tab bar (before the scrolling buttons)
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TabButton:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def leading(self) -> bool:
        """
        Writable attribute: Enforce the tab position to the
        left of the tab bar (after the tab list popup button)
        
        """
        ...


    @leading.setter
    def leading(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_reorder(self) -> bool:
        """
        Writable attribute: Disable reordering this tab or
        having another tab cross over this tab
        
        """
        ...


    @no_reorder.setter
    def no_reorder(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: Disable tooltip for the given tab
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def trailing(self) -> bool:
        """
        Writable attribute: Enforce the tab position to the
        right of the tab bar (before the scrolling buttons)
        
        """
        ...


    @trailing.setter
    def trailing(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class TableColumnConfig(baseItem):
    """
    Configuration for a table column.

    A table column can be hidden, stretched, resized, etc.

    The states can be changed by the user, but also by the
    application.
    To listen for state changes use:
    - ActivatedHandler to listen if the user requests
        the column to be sorted.
    - ToggledOpenHandler/ToggledCloseHandler to listen if the user
        requests the column to be shown/hidden.
    - ContentResizeHandler to listen if the user resizes the column.
    - HoveredHandler to listen if the user hovers the column.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., bg_color : list = [0.0, 0.0, 0.0, 0.0], children : list[baseItem] = [], enabled : bool = False, handlers : list = [], next_sibling : baseItem | None = None, no_clip : bool = False, no_hide : bool = False, no_reorder : bool = False, no_resize : bool = False, no_scaling : bool = True, no_sort : bool = False, parent : baseItem | None = None, prefer_sort_ascending : bool = False, prefer_sort_descending : bool = False, previous_sibling : baseItem | None = None, show : bool = True, stretch : Any = ..., stretch_weight : float = 1.0, user_data : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bg_color: Background color for the whole column.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Writable attribute (and can change with user interaction):
            Whether the table is hidden (user can control this
            in the context menu).
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Disable clipping for this column
        no_hide: Disable ability to hide this column
        no_reorder: Disable manual reordering
        no_resize: Disable manual resizing
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_sort: Disable sorting for this column
        parent: parent of the item in the rendering tree.
        prefer_sort_ascending: Make the initial sort direction ascending when first sorting
        prefer_sort_descending: Make the initial sort direction descending when first sorting
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Show the column.
        stretch: Writable attribute to enable stretching for this column.
            True: Stretch, using the stretch_weight factor
            False: Fixed width, using the width value.
            None: Default depending on Table policy.
        stretch_weight: Weight used when stretching this column. Must be >= 0.
        user_data: User data of any type.
        width: Requested fixed width of the column in pixels.
            Unused if in stretch mode.
            Set to 0 for auto-width.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., bg_color : list = [0.0, 0.0, 0.0, 0.0], children : list[baseItem] = [], enabled : bool = False, handlers : list = [], next_sibling : baseItem | None = None, no_clip : bool = False, no_hide : bool = False, no_reorder : bool = False, no_resize : bool = False, no_scaling : bool = True, no_sort : bool = False, parent : baseItem | None = None, prefer_sort_ascending : bool = False, prefer_sort_descending : bool = False, previous_sibling : baseItem | None = None, show : bool = True, stretch : Any = ..., stretch_weight : float = 1.0, user_data : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bg_color: Background color for the whole column.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Writable attribute (and can change with user interaction):
            Whether the table is hidden (user can control this
            in the context menu).
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Disable clipping for this column
        no_hide: Disable ability to hide this column
        no_reorder: Disable manual reordering
        no_resize: Disable manual resizing
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_sort: Disable sorting for this column
        parent: parent of the item in the rendering tree.
        prefer_sort_ascending: Make the initial sort direction ascending when first sorting
        prefer_sort_descending: Make the initial sort direction descending when first sorting
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Show the column.
        stretch: Writable attribute to enable stretching for this column.
            True: Stretch, using the stretch_weight factor
            False: Fixed width, using the width value.
            None: Default depending on Table policy.
        stretch_weight: Weight used when stretching this column. Must be >= 0.
        user_data: User data of any type.
        width: Requested fixed width of the column in pixels.
            Unused if in stretch mode.
            Set to 0 for auto-width.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TableColumnConfig:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def bg_color(self) -> list:
        """Background color for the whole column.

        Set to 0 (default) to disable.
        
        """
        ...


    @bg_color.setter
    def bg_color(self, value : list):
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute (and can change with user interaction):
        Whether the table is hidden (user can control this
        in the context menu).
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_clip(self) -> bool:
        """Disable clipping for this column
        """
        ...


    @no_clip.setter
    def no_clip(self, value : bool):
        ...


    @property
    def no_hide(self) -> bool:
        """Disable ability to hide this column
        """
        ...


    @no_hide.setter
    def no_hide(self, value : bool):
        ...


    @property
    def no_reorder(self) -> bool:
        """Disable manual reordering
        """
        ...


    @no_reorder.setter
    def no_reorder(self, value : bool):
        ...


    @property
    def no_resize(self) -> bool:
        """Disable manual resizing
        """
        ...


    @no_resize.setter
    def no_resize(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_sort(self) -> bool:
        """Disable sorting for this column
        """
        ...


    @no_sort.setter
    def no_sort(self, value : bool):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def prefer_sort_ascending(self) -> bool:
        """Make the initial sort direction ascending when first sorting
        """
        ...


    @prefer_sort_ascending.setter
    def prefer_sort_ascending(self, value : bool):
        ...


    @property
    def prefer_sort_descending(self) -> bool:
        """Make the initial sort direction descending when first sorting
        """
        ...


    @prefer_sort_descending.setter
    def prefer_sort_descending(self, value : bool):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Show the column.

        show = False differs from hidden=True as
        the latter can be changed by user interaction.
        Defaults to True.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def stretch(self):
        """
        Writable attribute to enable stretching for this column.
        True: Stretch, using the stretch_weight factor
        False: Fixed width, using the width value.
        None: Default depending on Table policy.
        
        """
        ...


    @stretch.setter
    def stretch(self, value):
        ...


    @property
    def stretch_weight(self) -> float:
        """Weight used when stretching this column. Must be >= 0.
        """
        ...


    @stretch_weight.setter
    def stretch_weight(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def width(self) -> float:
        """Requested fixed width of the column in pixels.
        Unused if in stretch mode.
        Set to 0 for auto-width.
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Text(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color : Color = 0, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedStr = ..., show : bool = True, show_label : bool = False, theme : Any = ..., user_data : Any = ..., value : str = "", width : float = 0.0, wrap : int = -1):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bullet: Whether to add a bullet
            before the text
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: text color.
            If set to 0 (default), that is
            full transparent text, use the
            default value given by the style
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        show_label: Whether to display the
            label next to the text stored in value
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        wrap: wrap width in pixels
            -1 for no wrapping
            The width is multiplied by the global scale
            unless the no_scaling option is set.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color : Color = 0, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedStr = ..., show : bool = True, show_label : bool = False, theme : Any = ..., user_data : Any = ..., value : str = "", width : float = 0.0, wrap : int = -1):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bullet: Whether to add a bullet
            before the text
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: text color.
            If set to 0 (default), that is
            full transparent text, use the
            default value given by the style
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        show_label: Whether to display the
            label next to the text stored in value
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        wrap: wrap width in pixels
            -1 for no wrapping
            The width is multiplied by the global scale
            unless the no_scaling option is set.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Text:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def bullet(self) -> bool:
        """
        Writable attribute: Whether to add a bullet
        before the text
        
        """
        ...


    @bullet.setter
    def bullet(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def color(self) -> Color:
        """
        Writable attribute: text color.
        If set to 0 (default), that is
        full transparent text, use the
        default value given by the style
        
        """
        ...


    @color.setter
    def color(self, value : Color):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def show_label(self) -> bool:
        """
        Writable attribute: Whether to display the
        label next to the text stored in value
        
        """
        ...


    @show_label.setter
    def show_label(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


    @property
    def wrap(self) -> int:
        """
        Writable attribute: wrap width in pixels
        -1 for no wrapping
        The width is multiplied by the global scale
        unless the no_scaling option is set.
        
        """
        ...


    @wrap.setter
    def wrap(self, value : int):
        ...


class Texture(baseItem):
    """
    Represents a texture that can be used in the UI.

    Attributes:
    - hint_dynamic: Boolean indicating if the texture is dynamic.
    - nearest_neighbor_upsampling: Boolean indicating if nearest neighbor upsampling is used.
    - width: Width of the texture.
    - height: Height of the texture.
    - num_chans: Number of channels in the texture.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], hint_dynamic : bool = False, nearest_neighbor_upsampling : int = 0, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        hint_dynamic: Hint for texture placement that
            the texture will be updated very
            frequently.
        nearest_neighbor_upsampling: Whether to use nearest neighbor interpolation
            instead of bilinear interpolation when upscaling
            the texture. Must be set before set_value.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, *args, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], hint_dynamic : bool = False, nearest_neighbor_upsampling : int = 0, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        hint_dynamic: Hint for texture placement that
            the texture will be updated very
            frequently.
        nearest_neighbor_upsampling: Whether to use nearest neighbor interpolation
            instead of bilinear interpolation when upscaling
            the texture. Must be set before set_value.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def set_value(self, value):
        """
        Pass an array as texture data.
        The currently native formats are:
        - data type: uint8 or float32.
            Anything else will be converted to float32
            float32 data must be normalized between 0 and 1.
        - number of channels: 1 (R), 2 (RG), 3 (RGB), 4 (RGBA)

        In the case of single channel textures, during rendering, R is
        duplicated on G and B, thus the texture is displayed as gray,
        not red.

        If set_value is called on a texture which already
        has content, the previous allocation will be reused
        if the size, type and number of channels is identical.

        The data is uploaded right away during set_value,
        thus the call is not instantaneous.
        The data can be discarded after set_value.

        If you change the data of a texture, you don't
        need to bind it again to the objects it is
        bound. The objects will automatically take
        the updated texture.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Texture:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def height(self) -> int:
        """
 Height of the current texture content 
        """
        ...


    @property
    def hint_dynamic(self) -> bool:
        """
        Hint for texture placement that
        the texture will be updated very
        frequently.
        
        """
        ...


    @hint_dynamic.setter
    def hint_dynamic(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def nearest_neighbor_upsampling(self) -> int:
        """
        Whether to use nearest neighbor interpolation
        instead of bilinear interpolation when upscaling
        the texture. Must be set before set_value.
        
        """
        ...


    @nearest_neighbor_upsampling.setter
    def nearest_neighbor_upsampling(self, value : int):
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def num_chans(self) -> int:
        """
 Number of channels of the current texture content 
        """
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def width(self) -> int:
        """
 Width of the current texture content 
        """
        ...


class ThemeColorImGui(baseThemeColor):
    """
    Theme color parameters that affect how ImGui
    renders items.
    All colors accept three formats:
    - unsigned (encodes a rgba little-endian)
    - (r, g, b, a) with r, g, b, a as integers.
    - (r, g, b, a) with r, g, b, a as floats.

    When r, g, b, a are floats, they should be normalized
    between 0 and 1, while integers are between 0 and 255.
    If a is missing, it defaults to 255.

    Keyword Arguments:
        Text: Color for text rendering
        TextDisabled: Color for the text of disabled items
        WindowBg: Background of normal windows
        ChildBg:  Background of child windows
        PopupBg: Background of popups, menus, tooltips windows
        Border: Color of borders
        BorderShadow: Color of border shadows
        FrameBg: Background of checkbox, radio button, plot, slider, text input
        FrameBgHovered: Color of FrameBg when the item is hovered
        FrameBgActive: Color of FrameBg when the item is active
        TitleBg: Title bar
        TitleBgActive: Title bar when focused
        TitleBgCollapsed: Title bar when collapsed
        MenuBarBg: Background color of the menu bar
        ScrollbarBg: Background color of the scroll bar
        ScrollbarGrab: Color of the scroll slider
        ScrollbarGrabHovered: Color of the scroll slider when hovered
        ScrollbarGrabActive: Color of the scroll slider when selected
        CheckMark: Checkbox tick and RadioButton circle
        SliderGrab: Color of sliders
        SliderGrabActive: Color of selected sliders
        Button: Color of buttons
        ButtonHovered: Color of buttons when hovered
        ButtonActive: Color of buttons when selected
        Header: Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem
        HeaderHovered: Header color when hovered
        HeaderActive: Header color when clicked
        Separator: Color of separators
        SeparatorHovered: Color of separator when hovered
        SeparatorActive: Color of separator when active
        ResizeGrip: Resize grip in lower-right and lower-left corners of windows.
        ResizeGripHovered: ResizeGrip when hovered
        ResizeGripActive: ResizeGrip when clicked
        TabHovered: Tab background, when hovered
        Tab: Tab background, when tab-bar is focused & tab is unselected
        TabSelected: Tab background, when tab-bar is focused & tab is selected
        TabSelectedOverline: Tab horizontal overline, when tab-bar is focused & tab is selected
        TabDimmed: Tab background, when tab-bar is unfocused & tab is unselected
        TabDimmedSelected: Tab background, when tab-bar is unfocused & tab is selected
        TabDimmedSelectedOverline: ..horizontal overline, when tab-bar is unfocused & tab is selected
        PlotLines: Color of SimplePlot lines
        PlotLinesHovered: Color of SimplePlot lines when hovered
        PlotHistogram: Color of SimplePlot histogram
        PlotHistogramHovered: Color of SimplePlot histogram when hovered
        TableHeaderBg: Table header background
        TableBorderStrong: Table outer and header borders (prefer using Alpha=1.0 here)
        TableBorderLight: Table inner borders (prefer using Alpha=1.0 here)
        TableRowBg: Table row background (even rows)
        TableRowBgAlt: Table row background (odd rows)
        TextLink: Hyperlink color
        TextSelectedBg: Color of the background of selected text
        DragDropTarget: Rectangle highlighting a drop target
        NavCursor: Gamepad/keyboard: current highlighted item
        NavWindowingHighlight: Highlight window when using CTRL+TAB
        NavWindowingDimBg: Darken/colorize entire screen behind the CTRL+TAB window list, when active
        ModalWindowDimBg: Darken/colorize entire screen behind a modal window, when one is active
    
    """
    def __init__(self, context : Context, Border : Color| None = None, BorderShadow : Color| None = None, Button : Color| None = None, ButtonActive : Color| None = None, ButtonHovered : Color| None = None, CheckMark : Color| None = None, ChildBg : Color| None = None, DragDropTarget : Color| None = None, FrameBg : Color| None = None, FrameBgActive : Color| None = None, FrameBgHovered : Color| None = None, Header : Color| None = None, HeaderActive : Color| None = None, HeaderHovered : Color| None = None, MenuBarBg : Color| None = None, ModalWindowDimBg : Color| None = None, NavCursor : Color| None = None, NavWindowingDimBg : Color| None = None, NavWindowingHighlight : Color| None = None, PlotHistogram : Color| None = None, PlotHistogramHovered : Color| None = None, PlotLines : Color| None = None, PlotLinesHovered : Color| None = None, PopupBg : Color| None = None, ResizeGrip : Color| None = None, ResizeGripActive : Color| None = None, ResizeGripHovered : Color| None = None, ScrollbarBg : Color| None = None, ScrollbarGrab : Color| None = None, ScrollbarGrabActive : Color| None = None, ScrollbarGrabHovered : Color| None = None, Separator : Color| None = None, SeparatorActive : Color| None = None, SeparatorHovered : Color| None = None, SliderGrab : Color| None = None, SliderGrabActive : Color| None = None, Tab : Color| None = None, TabDimmed : Color| None = None, TabDimmedSelected : Color| None = None, TabDimmedSelectedOverline : Color| None = None, TabHovered : Color| None = None, TabSelected : Color| None = None, TabSelectedOverline : Color| None = None, TableBorderLight : Color| None = None, TableBorderStrong : Color| None = None, TableHeaderBg : Color| None = None, TableRowBg : Color| None = None, TableRowBgAlt : Color| None = None, Text : Color| None = None, TextDisabled : Color| None = None, TextLink : Color| None = None, TextSelectedBg : Color| None = None, TitleBg : Color| None = None, TitleBgActive : Color| None = None, TitleBgCollapsed : Color| None = None, WindowBg : Color| None = None, attach : Color| None = None, before : Color| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Color| None = None):
        """

        Border: Color of borders.
            Default: (0.43, 0.43, 0.50, 0.50)
        BorderShadow: Color of border shadows.
            Default: (0.00, 0.00, 0.00, 0.00)
        Button: Button color.
            Default: (0.26, 0.59, 0.98, 0.40)
        ButtonActive: Button color when active.
            Default: (0.06, 0.53, 0.98, 1.00)
        ButtonHovered: Button color when hovered.
            Default: (0.26, 0.59, 0.98, 1.00)
        CheckMark: Checkmark color.
            Default: (0.26, 0.59, 0.98, 1.00)
        ChildBg: Background of child windows.
            Default: (0.00, 0.00, 0.00, 0.00)
        DragDropTarget: Rectangle highlighting a drop target.
            Default: (1.00, 1.00, 0.00, 0.90)
        FrameBg: Background of checkbox, radio button, plot, slider, text input.
            Default: (0.16, 0.29, 0.48, 0.54)
        FrameBgActive: Color of FrameBg when the item is active.
            Default: (0.26, 0.59, 0.98, 0.67)
        FrameBgHovered: Color of FrameBg when the item is hovered.
            Default: (0.26, 0.59, 0.98, 0.40)
        Header: Colors used for CollapsingHeader, TreeNode, Selectable, MenuItem.
            Default: (0.26, 0.59, 0.98, 0.31)
        HeaderActive: Header colors when activated/clicked.
            Default: (0.26, 0.59, 0.98, 1.00)
        HeaderHovered: Header colors when hovered.
            Default: (0.26, 0.59, 0.98, 0.80)
        MenuBarBg: Menu bar background color.
            Default: (0.14, 0.14, 0.14, 1.00)
        ModalWindowDimBg: Darken/colorize entire screen behind a modal window.
            Default: (0.80, 0.80, 0.80, 0.35)
        NavCursor: Color of keyboard/gamepad navigation cursor/rectangle, when visible.
            Default: Same as HeaderHovered (0.26, 0.59, 0.98, 1.00)
        NavWindowingDimBg: Darken/colorize entire screen behind CTRL+TAB window list.
            Default: (0.80, 0.80, 0.80, 0.20)
        NavWindowingHighlight: Highlight window when using CTRL+TAB.
            Default: (1.00, 1.00, 1.00, 0.70)
        PlotHistogram: Color of SimplePlot histogram.
            Default: (0.90, 0.70, 0.00, 1.00)
        PlotHistogramHovered: Color of SimplePlot histogram when hovered.
            Default: (1.00, 0.60, 0.00, 1.00)
        PlotLines: Color of SimplePlot lines.
            Default: (0.61, 0.61, 0.61, 1.00)
        PlotLinesHovered: Color of SimplePlot lines when hovered.
            Default: (1.00, 0.43, 0.35, 1.00)
        PopupBg: Background of popups, menus, tooltips windows.
            Default: (0.08, 0.08, 0.08, 0.94)
        ResizeGrip: Resize grip in lower-right and lower-left corners of windows.
            Default: (0.26, 0.59, 0.98, 0.20)
        ResizeGripActive: ResizeGrip color when clicked.
            Default: (0.26, 0.59, 0.98, 0.95)
        ResizeGripHovered: ResizeGrip color when hovered.
            Default: (0.26, 0.59, 0.98, 0.67)
        ScrollbarBg: Scrollbar background color.
            Default: (0.02, 0.02, 0.02, 0.53)
        ScrollbarGrab: Scrollbar grab color.
            Default: (0.31, 0.31, 0.31, 1.00)
        ScrollbarGrabActive: Scrollbar grab color when active.
            Default: (0.51, 0.51, 0.51, 1.00)
        ScrollbarGrabHovered: Scrollbar grab color when hovered.
            Default: (0.41, 0.41, 0.41, 1.00)
        Separator: Color of separating lines.
            Default: Same as Border color (0.43, 0.43, 0.50, 0.50)
        SeparatorActive: Separator color when active.
            Default: (0.10, 0.40, 0.75, 1.00)
        SeparatorHovered: Separator color when hovered.
            Default: (0.10, 0.40, 0.75, 0.78)
        SliderGrab: Slider grab color.
            Default: (0.24, 0.52, 0.88, 1.00)
        SliderGrabActive: Slider grab color when active.
            Default: (0.26, 0.59, 0.98, 1.00)
        Tab: Tab background when tab-bar is focused & tab is unselected.
            Default: Value interpolated between Header and TitleBgActive colors with factor 0.80
        TabDimmed: Tab background when tab-bar is unfocused & tab is unselected.
            Default: Value interpolated between Tab and TitleBg colors with factor 0.80
        TabDimmedSelected: Tab background when tab-bar is unfocused & tab is selected.
            Default: Value interpolated between TabSelected and TitleBg colors with factor 0.40
        TabDimmedSelectedOverline: Tab horizontal overline when tab-bar is unfocused & tab is selected.
            Default: (0.50, 0.50, 0.50, 1.00)
        TabHovered: Tab background when hovered.
            Default: Same as HeaderHovered color
        TabSelected: Tab background when tab-bar is focused & tab is selected.
            Default: Value interpolated between HeaderActive and TitleBgActive colors with factor 0.60
        TabSelectedOverline: Tab horizontal overline when tab-bar is focused & tab is selected.
            Default: Same as HeaderActive color
        TableBorderLight: Table inner borders (prefer using Alpha=1.0 here).
            Default: (0.23, 0.23, 0.25, 1.00)
        TableBorderStrong: Table outer borders and headers (prefer using Alpha=1.0 here).
            Default: (0.31, 0.31, 0.35, 1.00)
        TableHeaderBg: Table header background.
            Default: (0.19, 0.19, 0.20, 1.00)
        TableRowBg: Table row background (even rows).
            Default: (0.00, 0.00, 0.00, 0.00)
        TableRowBgAlt: Table row background (odd rows).
            Default: (1.00, 1.00, 1.00, 0.06)
        Text: Color for text rendering.
            Default: (1.00, 1.00, 1.00, 1.00)
        TextDisabled: Color for the text of disabled items.
            Default: (0.50, 0.50, 0.50, 1.00)
        TextLink: Hyperlink color.
            Default: Same as HeaderActive color
        TextSelectedBg: Background color of selected text.
            Default: (0.26, 0.59, 0.98, 0.35)
        TitleBg: Title bar color.
            Default: (0.04, 0.04, 0.04, 1.00)
        TitleBgActive: Title bar color when focused.
            Default: (0.16, 0.29, 0.48, 1.00)
        TitleBgCollapsed: Title bar color when collapsed.
            Default: (0.00, 0.00, 0.00, 0.51)
        WindowBg: Background of normal windows.
            Default: (0.06, 0.06, 0.06, 0.94)
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, Border : Color| None = None, BorderShadow : Color| None = None, Button : Color| None = None, ButtonActive : Color| None = None, ButtonHovered : Color| None = None, CheckMark : Color| None = None, ChildBg : Color| None = None, DragDropTarget : Color| None = None, FrameBg : Color| None = None, FrameBgActive : Color| None = None, FrameBgHovered : Color| None = None, Header : Color| None = None, HeaderActive : Color| None = None, HeaderHovered : Color| None = None, MenuBarBg : Color| None = None, ModalWindowDimBg : Color| None = None, NavCursor : Color| None = None, NavWindowingDimBg : Color| None = None, NavWindowingHighlight : Color| None = None, PlotHistogram : Color| None = None, PlotHistogramHovered : Color| None = None, PlotLines : Color| None = None, PlotLinesHovered : Color| None = None, PopupBg : Color| None = None, ResizeGrip : Color| None = None, ResizeGripActive : Color| None = None, ResizeGripHovered : Color| None = None, ScrollbarBg : Color| None = None, ScrollbarGrab : Color| None = None, ScrollbarGrabActive : Color| None = None, ScrollbarGrabHovered : Color| None = None, Separator : Color| None = None, SeparatorActive : Color| None = None, SeparatorHovered : Color| None = None, SliderGrab : Color| None = None, SliderGrabActive : Color| None = None, Tab : Color| None = None, TabDimmed : Color| None = None, TabDimmedSelected : Color| None = None, TabDimmedSelectedOverline : Color| None = None, TabHovered : Color| None = None, TabSelected : Color| None = None, TabSelectedOverline : Color| None = None, TableBorderLight : Color| None = None, TableBorderStrong : Color| None = None, TableHeaderBg : Color| None = None, TableRowBg : Color| None = None, TableRowBgAlt : Color| None = None, Text : Color| None = None, TextDisabled : Color| None = None, TextLink : Color| None = None, TextSelectedBg : Color| None = None, TitleBg : Color| None = None, TitleBgActive : Color| None = None, TitleBgCollapsed : Color| None = None, WindowBg : Color| None = None, attach : Color| None = None, before : Color| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Color| None = None):
        """
        Border: Color of borders.
            Default: (0.43, 0.43, 0.50, 0.50)
        BorderShadow: Color of border shadows.
            Default: (0.00, 0.00, 0.00, 0.00)
        Button: Button color.
            Default: (0.26, 0.59, 0.98, 0.40)
        ButtonActive: Button color when active.
            Default: (0.06, 0.53, 0.98, 1.00)
        ButtonHovered: Button color when hovered.
            Default: (0.26, 0.59, 0.98, 1.00)
        CheckMark: Checkmark color.
            Default: (0.26, 0.59, 0.98, 1.00)
        ChildBg: Background of child windows.
            Default: (0.00, 0.00, 0.00, 0.00)
        DragDropTarget: Rectangle highlighting a drop target.
            Default: (1.00, 1.00, 0.00, 0.90)
        FrameBg: Background of checkbox, radio button, plot, slider, text input.
            Default: (0.16, 0.29, 0.48, 0.54)
        FrameBgActive: Color of FrameBg when the item is active.
            Default: (0.26, 0.59, 0.98, 0.67)
        FrameBgHovered: Color of FrameBg when the item is hovered.
            Default: (0.26, 0.59, 0.98, 0.40)
        Header: Colors used for CollapsingHeader, TreeNode, Selectable, MenuItem.
            Default: (0.26, 0.59, 0.98, 0.31)
        HeaderActive: Header colors when activated/clicked.
            Default: (0.26, 0.59, 0.98, 1.00)
        HeaderHovered: Header colors when hovered.
            Default: (0.26, 0.59, 0.98, 0.80)
        MenuBarBg: Menu bar background color.
            Default: (0.14, 0.14, 0.14, 1.00)
        ModalWindowDimBg: Darken/colorize entire screen behind a modal window.
            Default: (0.80, 0.80, 0.80, 0.35)
        NavCursor: Color of keyboard/gamepad navigation cursor/rectangle, when visible.
            Default: Same as HeaderHovered (0.26, 0.59, 0.98, 1.00)
        NavWindowingDimBg: Darken/colorize entire screen behind CTRL+TAB window list.
            Default: (0.80, 0.80, 0.80, 0.20)
        NavWindowingHighlight: Highlight window when using CTRL+TAB.
            Default: (1.00, 1.00, 1.00, 0.70)
        PlotHistogram: Color of SimplePlot histogram.
            Default: (0.90, 0.70, 0.00, 1.00)
        PlotHistogramHovered: Color of SimplePlot histogram when hovered.
            Default: (1.00, 0.60, 0.00, 1.00)
        PlotLines: Color of SimplePlot lines.
            Default: (0.61, 0.61, 0.61, 1.00)
        PlotLinesHovered: Color of SimplePlot lines when hovered.
            Default: (1.00, 0.43, 0.35, 1.00)
        PopupBg: Background of popups, menus, tooltips windows.
            Default: (0.08, 0.08, 0.08, 0.94)
        ResizeGrip: Resize grip in lower-right and lower-left corners of windows.
            Default: (0.26, 0.59, 0.98, 0.20)
        ResizeGripActive: ResizeGrip color when clicked.
            Default: (0.26, 0.59, 0.98, 0.95)
        ResizeGripHovered: ResizeGrip color when hovered.
            Default: (0.26, 0.59, 0.98, 0.67)
        ScrollbarBg: Scrollbar background color.
            Default: (0.02, 0.02, 0.02, 0.53)
        ScrollbarGrab: Scrollbar grab color.
            Default: (0.31, 0.31, 0.31, 1.00)
        ScrollbarGrabActive: Scrollbar grab color when active.
            Default: (0.51, 0.51, 0.51, 1.00)
        ScrollbarGrabHovered: Scrollbar grab color when hovered.
            Default: (0.41, 0.41, 0.41, 1.00)
        Separator: Color of separating lines.
            Default: Same as Border color (0.43, 0.43, 0.50, 0.50)
        SeparatorActive: Separator color when active.
            Default: (0.10, 0.40, 0.75, 1.00)
        SeparatorHovered: Separator color when hovered.
            Default: (0.10, 0.40, 0.75, 0.78)
        SliderGrab: Slider grab color.
            Default: (0.24, 0.52, 0.88, 1.00)
        SliderGrabActive: Slider grab color when active.
            Default: (0.26, 0.59, 0.98, 1.00)
        Tab: Tab background when tab-bar is focused & tab is unselected.
            Default: Value interpolated between Header and TitleBgActive colors with factor 0.80
        TabDimmed: Tab background when tab-bar is unfocused & tab is unselected.
            Default: Value interpolated between Tab and TitleBg colors with factor 0.80
        TabDimmedSelected: Tab background when tab-bar is unfocused & tab is selected.
            Default: Value interpolated between TabSelected and TitleBg colors with factor 0.40
        TabDimmedSelectedOverline: Tab horizontal overline when tab-bar is unfocused & tab is selected.
            Default: (0.50, 0.50, 0.50, 1.00)
        TabHovered: Tab background when hovered.
            Default: Same as HeaderHovered color
        TabSelected: Tab background when tab-bar is focused & tab is selected.
            Default: Value interpolated between HeaderActive and TitleBgActive colors with factor 0.60
        TabSelectedOverline: Tab horizontal overline when tab-bar is focused & tab is selected.
            Default: Same as HeaderActive color
        TableBorderLight: Table inner borders (prefer using Alpha=1.0 here).
            Default: (0.23, 0.23, 0.25, 1.00)
        TableBorderStrong: Table outer borders and headers (prefer using Alpha=1.0 here).
            Default: (0.31, 0.31, 0.35, 1.00)
        TableHeaderBg: Table header background.
            Default: (0.19, 0.19, 0.20, 1.00)
        TableRowBg: Table row background (even rows).
            Default: (0.00, 0.00, 0.00, 0.00)
        TableRowBgAlt: Table row background (odd rows).
            Default: (1.00, 1.00, 1.00, 0.06)
        Text: Color for text rendering.
            Default: (1.00, 1.00, 1.00, 1.00)
        TextDisabled: Color for the text of disabled items.
            Default: (0.50, 0.50, 0.50, 1.00)
        TextLink: Hyperlink color.
            Default: Same as HeaderActive color
        TextSelectedBg: Background color of selected text.
            Default: (0.26, 0.59, 0.98, 0.35)
        TitleBg: Title bar color.
            Default: (0.04, 0.04, 0.04, 1.00)
        TitleBgActive: Title bar color when focused.
            Default: (0.16, 0.29, 0.48, 1.00)
        TitleBgCollapsed: Title bar color when collapsed.
            Default: (0.00, 0.00, 0.00, 0.51)
        WindowBg: Background of normal windows.
            Default: (0.06, 0.06, 0.06, 0.94)
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeColorImGui:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def Border(self) -> Color| None:
        """Color of borders.
        Default: (0.43, 0.43, 0.50, 0.50)
        """
        ...


    @Border.setter
    def Border(self, value : Color| None):
        ...


    @property
    def BorderShadow(self) -> Color| None:
        """Color of border shadows.
        Default: (0.00, 0.00, 0.00, 0.00)
        """
        ...


    @BorderShadow.setter
    def BorderShadow(self, value : Color| None):
        ...


    @property
    def Button(self) -> Color| None:
        """Button color.
        Default: (0.26, 0.59, 0.98, 0.40)
        """
        ...


    @Button.setter
    def Button(self, value : Color| None):
        ...


    @property
    def ButtonActive(self) -> Color| None:
        """Button color when active.
        Default: (0.06, 0.53, 0.98, 1.00)
        """
        ...


    @ButtonActive.setter
    def ButtonActive(self, value : Color| None):
        ...


    @property
    def ButtonHovered(self) -> Color| None:
        """Button color when hovered.
        Default: (0.26, 0.59, 0.98, 1.00)
        """
        ...


    @ButtonHovered.setter
    def ButtonHovered(self, value : Color| None):
        ...


    @property
    def CheckMark(self) -> Color| None:
        """Checkmark color.
        Default: (0.26, 0.59, 0.98, 1.00)
        """
        ...


    @CheckMark.setter
    def CheckMark(self, value : Color| None):
        ...


    @property
    def ChildBg(self) -> Color| None:
        """Background of child windows.
        Default: (0.00, 0.00, 0.00, 0.00)
        """
        ...


    @ChildBg.setter
    def ChildBg(self, value : Color| None):
        ...


    @property
    def DragDropTarget(self) -> Color| None:
        """Rectangle highlighting a drop target.
        Default: (1.00, 1.00, 0.00, 0.90)
        """
        ...


    @DragDropTarget.setter
    def DragDropTarget(self, value : Color| None):
        ...


    @property
    def FrameBg(self) -> Color| None:
        """Background of checkbox, radio button, plot, slider, text input.
        Default: (0.16, 0.29, 0.48, 0.54)
        """
        ...


    @FrameBg.setter
    def FrameBg(self, value : Color| None):
        ...


    @property
    def FrameBgActive(self) -> Color| None:
        """Color of FrameBg when the item is active.
        Default: (0.26, 0.59, 0.98, 0.67)
        """
        ...


    @FrameBgActive.setter
    def FrameBgActive(self, value : Color| None):
        ...


    @property
    def FrameBgHovered(self) -> Color| None:
        """Color of FrameBg when the item is hovered.
        Default: (0.26, 0.59, 0.98, 0.40)
        """
        ...


    @FrameBgHovered.setter
    def FrameBgHovered(self, value : Color| None):
        ...


    @property
    def Header(self) -> Color| None:
        """Colors used for CollapsingHeader, TreeNode, Selectable, MenuItem.
        Default: (0.26, 0.59, 0.98, 0.31)
        """
        ...


    @Header.setter
    def Header(self, value : Color| None):
        ...


    @property
    def HeaderActive(self) -> Color| None:
        """Header colors when activated/clicked.
        Default: (0.26, 0.59, 0.98, 1.00)
        """
        ...


    @HeaderActive.setter
    def HeaderActive(self, value : Color| None):
        ...


    @property
    def HeaderHovered(self) -> Color| None:
        """Header colors when hovered.
        Default: (0.26, 0.59, 0.98, 0.80)
        """
        ...


    @HeaderHovered.setter
    def HeaderHovered(self, value : Color| None):
        ...


    @property
    def MenuBarBg(self) -> Color| None:
        """Menu bar background color.
        Default: (0.14, 0.14, 0.14, 1.00)
        """
        ...


    @MenuBarBg.setter
    def MenuBarBg(self, value : Color| None):
        ...


    @property
    def ModalWindowDimBg(self) -> Color| None:
        """Darken/colorize entire screen behind a modal window.
        Default: (0.80, 0.80, 0.80, 0.35)
        """
        ...


    @ModalWindowDimBg.setter
    def ModalWindowDimBg(self, value : Color| None):
        ...


    @property
    def NavCursor(self) -> Color| None:
        """Color of keyboard/gamepad navigation cursor/rectangle, when visible.
        Default: Same as HeaderHovered (0.26, 0.59, 0.98, 1.00)
        """
        ...


    @NavCursor.setter
    def NavCursor(self, value : Color| None):
        ...


    @property
    def NavWindowingDimBg(self) -> Color| None:
        """Darken/colorize entire screen behind CTRL+TAB window list.
        Default: (0.80, 0.80, 0.80, 0.20)
        """
        ...


    @NavWindowingDimBg.setter
    def NavWindowingDimBg(self, value : Color| None):
        ...


    @property
    def NavWindowingHighlight(self) -> Color| None:
        """Highlight window when using CTRL+TAB.
        Default: (1.00, 1.00, 1.00, 0.70)
        """
        ...


    @NavWindowingHighlight.setter
    def NavWindowingHighlight(self, value : Color| None):
        ...


    @property
    def PlotHistogram(self) -> Color| None:
        """Color of SimplePlot histogram.
        Default: (0.90, 0.70, 0.00, 1.00)
        """
        ...


    @PlotHistogram.setter
    def PlotHistogram(self, value : Color| None):
        ...


    @property
    def PlotHistogramHovered(self) -> Color| None:
        """Color of SimplePlot histogram when hovered.
        Default: (1.00, 0.60, 0.00, 1.00)
        """
        ...


    @PlotHistogramHovered.setter
    def PlotHistogramHovered(self, value : Color| None):
        ...


    @property
    def PlotLines(self) -> Color| None:
        """Color of SimplePlot lines.
        Default: (0.61, 0.61, 0.61, 1.00)
        """
        ...


    @PlotLines.setter
    def PlotLines(self, value : Color| None):
        ...


    @property
    def PlotLinesHovered(self) -> Color| None:
        """Color of SimplePlot lines when hovered.
        Default: (1.00, 0.43, 0.35, 1.00)
        """
        ...


    @PlotLinesHovered.setter
    def PlotLinesHovered(self, value : Color| None):
        ...


    @property
    def PopupBg(self) -> Color| None:
        """Background of popups, menus, tooltips windows.
        Default: (0.08, 0.08, 0.08, 0.94)
        """
        ...


    @PopupBg.setter
    def PopupBg(self, value : Color| None):
        ...


    @property
    def ResizeGrip(self) -> Color| None:
        """Resize grip in lower-right and lower-left corners of windows.
        Default: (0.26, 0.59, 0.98, 0.20)
        """
        ...


    @ResizeGrip.setter
    def ResizeGrip(self, value : Color| None):
        ...


    @property
    def ResizeGripActive(self) -> Color| None:
        """ResizeGrip color when clicked.
        Default: (0.26, 0.59, 0.98, 0.95)
        """
        ...


    @ResizeGripActive.setter
    def ResizeGripActive(self, value : Color| None):
        ...


    @property
    def ResizeGripHovered(self) -> Color| None:
        """ResizeGrip color when hovered.
        Default: (0.26, 0.59, 0.98, 0.67)
        """
        ...


    @ResizeGripHovered.setter
    def ResizeGripHovered(self, value : Color| None):
        ...


    @property
    def ScrollbarBg(self) -> Color| None:
        """Scrollbar background color.
        Default: (0.02, 0.02, 0.02, 0.53)
        """
        ...


    @ScrollbarBg.setter
    def ScrollbarBg(self, value : Color| None):
        ...


    @property
    def ScrollbarGrab(self) -> Color| None:
        """Scrollbar grab color.
        Default: (0.31, 0.31, 0.31, 1.00)
        """
        ...


    @ScrollbarGrab.setter
    def ScrollbarGrab(self, value : Color| None):
        ...


    @property
    def ScrollbarGrabActive(self) -> Color| None:
        """Scrollbar grab color when active.
        Default: (0.51, 0.51, 0.51, 1.00)
        """
        ...


    @ScrollbarGrabActive.setter
    def ScrollbarGrabActive(self, value : Color| None):
        ...


    @property
    def ScrollbarGrabHovered(self) -> Color| None:
        """Scrollbar grab color when hovered. 
        Default: (0.41, 0.41, 0.41, 1.00)
        """
        ...


    @ScrollbarGrabHovered.setter
    def ScrollbarGrabHovered(self, value : Color| None):
        ...


    @property
    def Separator(self) -> Color| None:
        """Color of separating lines.
        Default: Same as Border color (0.43, 0.43, 0.50, 0.50)
        """
        ...


    @Separator.setter
    def Separator(self, value : Color| None):
        ...


    @property
    def SeparatorActive(self) -> Color| None:
        """Separator color when active.
        Default: (0.10, 0.40, 0.75, 1.00)
        """
        ...


    @SeparatorActive.setter
    def SeparatorActive(self, value : Color| None):
        ...


    @property
    def SeparatorHovered(self) -> Color| None:
        """Separator color when hovered.
        Default: (0.10, 0.40, 0.75, 0.78)
        """
        ...


    @SeparatorHovered.setter
    def SeparatorHovered(self, value : Color| None):
        ...


    @property
    def SliderGrab(self) -> Color| None:
        """Slider grab color.
        Default: (0.24, 0.52, 0.88, 1.00)
        """
        ...


    @SliderGrab.setter
    def SliderGrab(self, value : Color| None):
        ...


    @property
    def SliderGrabActive(self) -> Color| None:
        """Slider grab color when active.
        Default: (0.26, 0.59, 0.98, 1.00)
        """
        ...


    @SliderGrabActive.setter
    def SliderGrabActive(self, value : Color| None):
        ...


    @property
    def Tab(self) -> Color| None:
        """Tab background when tab-bar is focused & tab is unselected.
        Default: Value interpolated between Header and TitleBgActive colors with factor 0.80
        """
        ...


    @Tab.setter
    def Tab(self, value : Color| None):
        ...


    @property
    def TabDimmed(self) -> Color| None:
        """Tab background when tab-bar is unfocused & tab is unselected.
        Default: Value interpolated between Tab and TitleBg colors with factor 0.80
        """
        ...


    @TabDimmed.setter
    def TabDimmed(self, value : Color| None):
        ...


    @property
    def TabDimmedSelected(self) -> Color| None:
        """Tab background when tab-bar is unfocused & tab is selected.
        Default: Value interpolated between TabSelected and TitleBg colors with factor 0.40
        """
        ...


    @TabDimmedSelected.setter
    def TabDimmedSelected(self, value : Color| None):
        ...


    @property
    def TabDimmedSelectedOverline(self) -> Color| None:
        """Tab horizontal overline when tab-bar is unfocused & tab is selected.
        Default: (0.50, 0.50, 0.50, 1.00)
        """
        ...


    @TabDimmedSelectedOverline.setter
    def TabDimmedSelectedOverline(self, value : Color| None):
        ...


    @property
    def TabHovered(self) -> Color| None:
        """Tab background when hovered.
        Default: Same as HeaderHovered color
        """
        ...


    @TabHovered.setter
    def TabHovered(self, value : Color| None):
        ...


    @property
    def TabSelected(self) -> Color| None:
        """Tab background when tab-bar is focused & tab is selected.
        Default: Value interpolated between HeaderActive and TitleBgActive colors with factor 0.60
        """
        ...


    @TabSelected.setter
    def TabSelected(self, value : Color| None):
        ...


    @property
    def TabSelectedOverline(self) -> Color| None:
        """Tab horizontal overline when tab-bar is focused & tab is selected.
        Default: Same as HeaderActive color
        """
        ...


    @TabSelectedOverline.setter
    def TabSelectedOverline(self, value : Color| None):
        ...


    @property
    def TableBorderLight(self) -> Color| None:
        """Table inner borders (prefer using Alpha=1.0 here).
        Default: (0.23, 0.23, 0.25, 1.00)
        """
        ...


    @TableBorderLight.setter
    def TableBorderLight(self, value : Color| None):
        ...


    @property
    def TableBorderStrong(self) -> Color| None:
        """Table outer borders and headers (prefer using Alpha=1.0 here).
        Default: (0.31, 0.31, 0.35, 1.00)
        """
        ...


    @TableBorderStrong.setter
    def TableBorderStrong(self, value : Color| None):
        ...


    @property
    def TableHeaderBg(self) -> Color| None:
        """Table header background.
        Default: (0.19, 0.19, 0.20, 1.00)
        """
        ...


    @TableHeaderBg.setter
    def TableHeaderBg(self, value : Color| None):
        ...


    @property
    def TableRowBg(self) -> Color| None:
        """Table row background (even rows).
        Default: (0.00, 0.00, 0.00, 0.00)
        """
        ...


    @TableRowBg.setter
    def TableRowBg(self, value : Color| None):
        ...


    @property
    def TableRowBgAlt(self) -> Color| None:
        """Table row background (odd rows).
        Default: (1.00, 1.00, 1.00, 0.06)
        """
        ...


    @TableRowBgAlt.setter
    def TableRowBgAlt(self, value : Color| None):
        ...


    @property
    def Text(self) -> Color| None:
        """Color for text rendering. 
        Default: (1.00, 1.00, 1.00, 1.00)
        """
        ...


    @Text.setter
    def Text(self, value : Color| None):
        ...


    @property
    def TextDisabled(self) -> Color| None:
        """Color for the text of disabled items.
        Default: (0.50, 0.50, 0.50, 1.00)
        """
        ...


    @TextDisabled.setter
    def TextDisabled(self, value : Color| None):
        ...


    @property
    def TextLink(self) -> Color| None:
        """Hyperlink color.
        Default: Same as HeaderActive color
        """
        ...


    @TextLink.setter
    def TextLink(self, value : Color| None):
        ...


    @property
    def TextSelectedBg(self) -> Color| None:
        """Background color of selected text.
        Default: (0.26, 0.59, 0.98, 0.35)
        """
        ...


    @TextSelectedBg.setter
    def TextSelectedBg(self, value : Color| None):
        ...


    @property
    def TitleBg(self) -> Color| None:
        """Title bar color.
        Default: (0.04, 0.04, 0.04, 1.00)
        """
        ...


    @TitleBg.setter
    def TitleBg(self, value : Color| None):
        ...


    @property
    def TitleBgActive(self) -> Color| None:
        """Title bar color when focused.
        Default: (0.16, 0.29, 0.48, 1.00)
        """
        ...


    @TitleBgActive.setter
    def TitleBgActive(self, value : Color| None):
        ...


    @property
    def TitleBgCollapsed(self) -> Color| None:
        """Title bar color when collapsed.
        Default: (0.00, 0.00, 0.00, 0.51)
        """
        ...


    @TitleBgCollapsed.setter
    def TitleBgCollapsed(self, value : Color| None):
        ...


    @property
    def WindowBg(self) -> Color| None:
        """Background of normal windows.
        Default: (0.06, 0.06, 0.06, 0.94)
        """
        ...


    @WindowBg.setter
    def WindowBg(self, value : Color| None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self) -> Color| None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : Color| None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeColorImPlot(baseThemeColor):
    """
    Theme color parameters that affect how ImPlot renders plots.
    All colors accept three formats:
    - unsigned (encodes a rgba little-endian)
    - (r, g, b, a) with r, g, b, a as integers.
    - (r, g, b, a) with r, g, b, a as floats.

    When r, g, b, a are floats, they should be normalized
    between 0 and 1, while integers are between 0 and 255.
    If a is missing, it defaults to 255.

    Keyword Arguments:
        Line: Plot line color. Auto - derived from Text color
        Fill: Plot fill color. Auto - derived from Line color
        MarkerOutline: Plot marker outline color. Auto - derived from Line color
        MarkerFill: Plot marker fill color. Auto - derived from Line color 
        ErrorBar: Error bar color. Auto - derived from Text color
        FrameBg: Plot frame background color. Auto - derived from FrameBg color
        PlotBg: Plot area background color. Auto - derived from WindowBg color
        PlotBorder: Plot area border color. Auto - derived from Border color
        LegendBg: Legend background color. Auto - derived from PopupBg color
        LegendBorder: Legend border color. Auto - derived from Border color
        LegendText: Legend text color. Auto - derived from Text color
        TitleText: Plot title text color. Auto - derived from Text color
        InlayText: Color of text appearing inside plots. Auto - derived from Text color
        AxisText: Axis text labels color. Auto - derived from Text color
        AxisGrid: Axis grid color. Auto - derived from Text color with reduced alpha
        AxisTick: Axis tick marks color. Auto - derived from AxisGrid color
        AxisBg: Background color of axis hover region. Auto - transparent
        AxisBgHovered: Axis background color when hovered. Auto - derived from ButtonHovered color
        AxisBgActive: Axis background color when clicked. Auto - derived from ButtonActive color
        Selection: Box-selection color. Default: (1.00, 1.00, 0.00, 1.00)
        Crosshairs: Crosshairs color. Auto - derived from PlotBorder color
    
    """
    def __init__(self, context : Context, AxisBg : Color| None = None, AxisBgActive : Color| None = None, AxisBgHovered : Color| None = None, AxisGrid : Color| None = None, AxisText : Color| None = None, AxisTick : Color| None = None, Crosshairs : Color| None = None, ErrorBar : Color| None = None, Fill : Color| None = None, FrameBg : Color| None = None, InlayText : Color| None = None, LegendBg : Color| None = None, LegendBorder : Color| None = None, LegendText : Color| None = None, Line : Color| None = None, MarkerFill : Color| None = None, MarkerOutline : Color| None = None, PlotBg : Color| None = None, PlotBorder : Color| None = None, Selection : Color| None = None, TitleText : Color| None = None, attach : Color| None = None, before : Color| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Color| None = None):
        """

        AxisBg: Background color of axis hover region.
            Default: transparent
        AxisBgActive: Axis background color when clicked.
            Default: Auto - derived from ButtonActive color
        AxisBgHovered: Axis background color when hovered.
            Default: Auto - derived from ButtonHovered color
        AxisGrid: Axis grid color.
            Default: Auto - derived from Text color
        AxisText: Axis text labels color.
            Default: Auto - derived from Text color
        AxisTick: Axis tick marks color.
            Default: Auto - derived from AxisGrid color
        Crosshairs: Crosshairs color.
            Default: Auto - derived from PlotBorder color
        ErrorBar: Error bar color.
            Default: Auto - derived from Text color
        Fill: Plot fill color.
            Default: Auto - derived from Line color
        FrameBg: Plot frame background color.
            Default: Auto - derived from FrameBg color
        InlayText: Color of text appearing inside of plots.
            Default: Auto - derived from Text color
        LegendBg: Legend background color.
            Default: Auto - derived from PopupBg color
        LegendBorder: Legend border color.
            Default: Auto - derived from Border color
        LegendText: Legend text color.
            Default: Auto - derived from Text color
        Line: Plot line color.
            Default: Auto - derived from Text color
        MarkerFill: Plot marker fill color.
            Default: Auto - derived from Line color
        MarkerOutline: Plot marker outline color.
            Default: Auto - derived from Line color
        PlotBg: Plot area background color.
            Default: Auto - derived from WindowBg color
        PlotBorder: Plot area border color.
            Default: Auto - derived from Border color
        Selection: Box-selection color.
            Default: (1.00, 1.00, 0.00, 1.00)
        TitleText: Plot title text color.
            Default: Auto - derived from Text color
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, AxisBg : Color| None = None, AxisBgActive : Color| None = None, AxisBgHovered : Color| None = None, AxisGrid : Color| None = None, AxisText : Color| None = None, AxisTick : Color| None = None, Crosshairs : Color| None = None, ErrorBar : Color| None = None, Fill : Color| None = None, FrameBg : Color| None = None, InlayText : Color| None = None, LegendBg : Color| None = None, LegendBorder : Color| None = None, LegendText : Color| None = None, Line : Color| None = None, MarkerFill : Color| None = None, MarkerOutline : Color| None = None, PlotBg : Color| None = None, PlotBorder : Color| None = None, Selection : Color| None = None, TitleText : Color| None = None, attach : Color| None = None, before : Color| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Color| None = None):
        """
        AxisBg: Background color of axis hover region.
            Default: transparent
        AxisBgActive: Axis background color when clicked.
            Default: Auto - derived from ButtonActive color
        AxisBgHovered: Axis background color when hovered.
            Default: Auto - derived from ButtonHovered color
        AxisGrid: Axis grid color.
            Default: Auto - derived from Text color
        AxisText: Axis text labels color.
            Default: Auto - derived from Text color
        AxisTick: Axis tick marks color.
            Default: Auto - derived from AxisGrid color
        Crosshairs: Crosshairs color.
            Default: Auto - derived from PlotBorder color
        ErrorBar: Error bar color.
            Default: Auto - derived from Text color
        Fill: Plot fill color.
            Default: Auto - derived from Line color
        FrameBg: Plot frame background color.
            Default: Auto - derived from FrameBg color
        InlayText: Color of text appearing inside of plots.
            Default: Auto - derived from Text color
        LegendBg: Legend background color.
            Default: Auto - derived from PopupBg color
        LegendBorder: Legend border color.
            Default: Auto - derived from Border color
        LegendText: Legend text color.
            Default: Auto - derived from Text color
        Line: Plot line color.
            Default: Auto - derived from Text color
        MarkerFill: Plot marker fill color.
            Default: Auto - derived from Line color
        MarkerOutline: Plot marker outline color.
            Default: Auto - derived from Line color
        PlotBg: Plot area background color.
            Default: Auto - derived from WindowBg color
        PlotBorder: Plot area border color.
            Default: Auto - derived from Border color
        Selection: Box-selection color.
            Default: (1.00, 1.00, 0.00, 1.00)
        TitleText: Plot title text color.
            Default: Auto - derived from Text color
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeColorImPlot:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def AxisBg(self) -> Color| None:
        """Background color of axis hover region.
        Default: transparent
        """
        ...


    @AxisBg.setter
    def AxisBg(self, value : Color| None):
        ...


    @property
    def AxisBgActive(self) -> Color| None:
        """Axis background color when clicked.
        Default: Auto - derived from ButtonActive color
        """
        ...


    @AxisBgActive.setter
    def AxisBgActive(self, value : Color| None):
        ...


    @property
    def AxisBgHovered(self) -> Color| None:
        """Axis background color when hovered.
        Default: Auto - derived from ButtonHovered color
        """
        ...


    @AxisBgHovered.setter
    def AxisBgHovered(self, value : Color| None):
        ...


    @property
    def AxisGrid(self) -> Color| None:
        """Axis grid color.
        Default: Auto - derived from Text color
        """
        ...


    @AxisGrid.setter
    def AxisGrid(self, value : Color| None):
        ...


    @property
    def AxisText(self) -> Color| None:
        """Axis text labels color.
        Default: Auto - derived from Text color
        """
        ...


    @AxisText.setter
    def AxisText(self, value : Color| None):
        ...


    @property
    def AxisTick(self) -> Color| None:
        """Axis tick marks color.
        Default: Auto - derived from AxisGrid color
        """
        ...


    @AxisTick.setter
    def AxisTick(self, value : Color| None):
        ...


    @property
    def Crosshairs(self) -> Color| None:
        """Crosshairs color.
        Default: Auto - derived from PlotBorder color
        """
        ...


    @Crosshairs.setter
    def Crosshairs(self, value : Color| None):
        ...


    @property
    def ErrorBar(self) -> Color| None:
        """Error bar color.
        Default: Auto - derived from Text color
        """
        ...


    @ErrorBar.setter
    def ErrorBar(self, value : Color| None):
        ...


    @property
    def Fill(self) -> Color| None:
        """Plot fill color.
        Default: Auto - derived from Line color
        """
        ...


    @Fill.setter
    def Fill(self, value : Color| None):
        ...


    @property
    def FrameBg(self) -> Color| None:
        """Plot frame background color.
        Default: Auto - derived from FrameBg color
        """
        ...


    @FrameBg.setter
    def FrameBg(self, value : Color| None):
        ...


    @property
    def InlayText(self) -> Color| None:
        """Color of text appearing inside of plots.
        Default: Auto - derived from Text color
        """
        ...


    @InlayText.setter
    def InlayText(self, value : Color| None):
        ...


    @property
    def LegendBg(self) -> Color| None:
        """Legend background color.
        Default: Auto - derived from PopupBg color
        """
        ...


    @LegendBg.setter
    def LegendBg(self, value : Color| None):
        ...


    @property
    def LegendBorder(self) -> Color| None:
        """Legend border color.
        Default: Auto - derived from Border color
        """
        ...


    @LegendBorder.setter
    def LegendBorder(self, value : Color| None):
        ...


    @property
    def LegendText(self) -> Color| None:
        """Legend text color.
        Default: Auto - derived from Text color
        """
        ...


    @LegendText.setter
    def LegendText(self, value : Color| None):
        ...


    @property
    def Line(self) -> Color| None:
        """Plot line color.
        Default: Auto - derived from Text color
        """
        ...


    @Line.setter
    def Line(self, value : Color| None):
        ...


    @property
    def MarkerFill(self) -> Color| None:
        """Plot marker fill color.
        Default: Auto - derived from Line color
        """
        ...


    @MarkerFill.setter
    def MarkerFill(self, value : Color| None):
        ...


    @property
    def MarkerOutline(self) -> Color| None:
        """Plot marker outline color.
        Default: Auto - derived from Line color
        """
        ...


    @MarkerOutline.setter
    def MarkerOutline(self, value : Color| None):
        ...


    @property
    def PlotBg(self) -> Color| None:
        """Plot area background color.
        Default: Auto - derived from WindowBg color
        """
        ...


    @PlotBg.setter
    def PlotBg(self, value : Color| None):
        ...


    @property
    def PlotBorder(self) -> Color| None:
        """Plot area border color.
        Default: Auto - derived from Border color
        """
        ...


    @PlotBorder.setter
    def PlotBorder(self, value : Color| None):
        ...


    @property
    def Selection(self) -> Color| None:
        """Box-selection color.
        Default: (1.00, 1.00, 0.00, 1.00)
        """
        ...


    @Selection.setter
    def Selection(self, value : Color| None):
        ...


    @property
    def TitleText(self) -> Color| None:
        """Plot title text color.
        Default: Auto - derived from Text color
        """
        ...


    @TitleText.setter
    def TitleText(self, value : Color| None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self) -> Color| None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : Color| None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeList(baseTheme):
    """
    A set of base theme elements to apply when we render an item.
    Warning: it is bad practice to bind a theme to every item, and
    is not free on CPU. Instead set the theme as high as possible in
    the rendering hierarchy, and only change locally reduced sets
    of theme elements if needed.

    Contains theme styles and colors.
    Can contain a theme list.
    Can be bound to items.

    WARNING: if you bind a theme element to an item,
    and that theme element belongs to a theme list,
    the siblings before the theme element will get
    applied as well.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseTheme] = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[baseTheme] = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeList:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[baseTheme]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseTheme]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeListWithCondition(baseTheme):
    """
    A ThemeList but with delayed activation.
    If during rendering of the children the condition
    is met, then the theme gets applied.

    Contains theme styles and colors.
    Can contain a theme list.
    Can be in a theme list
    Can be bound to items.
    Concatenates with previous theme lists with
    conditions during rendering.
    The condition gets checked on the bound item,
    not just the children.

    As the elements in this list get checked everytime
    a item in the child tree is rendered, use this lightly.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseTheme] = [], condition_category : ThemeCategories = 0, condition_enabled : ThemeEnablers = 0, enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_category: As long as it is active, the theme list
            waits to be applied that the conditions are met.
            category condition: 0: no condition. other value: see list
        condition_enabled: As long as it is active, the theme list
            waits to be applied that the conditions are met.
            enabled condition: 0: no condition. 1: enabled must be true. 2: enabled must be false
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[baseTheme] = [], condition_category : ThemeCategories = 0, condition_enabled : ThemeEnablers = 0, enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_category: As long as it is active, the theme list
            waits to be applied that the conditions are met.
            category condition: 0: no condition. other value: see list
        condition_enabled: As long as it is active, the theme list
            waits to be applied that the conditions are met.
            enabled condition: 0: no condition. 1: enabled must be true. 2: enabled must be false
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeListWithCondition:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[baseTheme]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseTheme]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def condition_category(self) -> ThemeCategories:
        """
        Writable attribute: As long as it is active, the theme list
        waits to be applied that the conditions are met.
        category condition: 0: no condition. other value: see list
        
        """
        ...


    @condition_category.setter
    def condition_category(self, value : ThemeCategories):
        ...


    @property
    def condition_enabled(self) -> ThemeEnablers:
        """
        Writable attribute: As long as it is active, the theme list
        waits to be applied that the conditions are met.
        enabled condition: 0: no condition. 1: enabled must be true. 2: enabled must be false
        
        """
        ...


    @condition_enabled.setter
    def condition_enabled(self, value : ThemeEnablers):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeStopCondition(baseTheme):
    """
    a Theme that blocks any previous theme
    list with condition from propagating to children
    of the item bound. Does not affect the bound item.

    Does not work inside a ThemeListWithCondition
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeStopCondition:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeStyleImGui(baseThemeStyle):
    def __init__(self, context : Context, Alpha : float | None = None, ButtonTextAlign : tuple[float, float] | None = None, CellPadding : tuple[float, float] | None = None, ChildBorderSize : float | None = None, ChildRounding : float | None = None, DisabledAlpha : float | None = None, FrameBorderSize : float | None = None, FramePadding : tuple[float, float] | None = None, FrameRounding : float | None = None, GrabMinSize : float | None = None, GrabRounding : float | None = None, IndentSpacing : float | None = None, ItemInnerSpacing : tuple[float, float] | None = None, ItemSpacing : tuple[float, float] | None = None, PopupBorderSize : float | None = None, PopupRounding : float | None = None, ScrollbarRounding : float | None = None, ScrollbarSize : float | None = None, SelectableTextAlign : tuple[float, float] | None = None, SeparatorTextBorderSize : float | None = None, SeparatorTextPadding : tuple[float, float] | None = None, TabBarBorderSize : float | None = None, TabBarOverlineSize : float | None = None, TabBorderSize : float | None = None, TabRounding : float | None = None, TableAngledHeadersAngle : float | None = None, TableAngledHeadersTextAlign : tuple[float, float] | None = None, WindowBorderSize : float | None = None, WindowMinSize : tuple[float, float] | None = None, WindowPadding : tuple[float, float] | None = None, WindowRounding : float | None = None, WindowTitleAlign : tuple[float, float] | None = None, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : tuple[float, float] | None = None):
        """

        Alpha: Global alpha applied to everything in Dear ImGui.
        ButtonTextAlign: Alignment of button text when button is larger than text.
        
            The value is a pair of floats. Defaults to (0.5, 0.5), i.e. centered
        CellPadding: Tables: padding between cells.
            The x padding is applied for the whole Table,
            while y can be different for every row.
        ChildBorderSize: Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        ChildRounding: Radius of child window corners rounding. Set to 0.0 to have rectangular child windows.
        DisabledAlpha: Unused currently.
        FrameBorderSize: Thickness of border around frames (most widgets). Generally set to 0.0f or 1.0f. Other values not well tested.
        FramePadding: Padding within a framed rectangle (used by most widgets)
        FrameRounding: Radius of frame corners rounding. Set to 0.0 to have rectangular frame (most widgets).
        GrabMinSize: Minimum width/height of a grab box for slider/scrollbar.
        GrabRounding: Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
        IndentSpacing: Default horizontal spacing for indentations. For instance when entering a tree node.
            A good value is Generally == (FontSize + FramePadding.x*2).
        ItemInnerSpacing: Horizontal and vertical spacing between elements inside of a composed widget.
        ItemSpacing: Horizontal and vertical spacing between widgets/lines.
        PopupBorderSize: Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        PopupRounding: Radius of popup or tooltip window corners rounding. Set to 0.0 to have rectangular popup or tooltip windows.
        ScrollbarRounding: Radius of grab corners rounding for scrollbar.
        ScrollbarSize: Width of the vertical scrollbar, Height of the horizontal scrollbar
        SelectableTextAlign: Alignment of text within the separator in percentages.
        
            The value is a pair of floats. Defaults to (0., 0.5), i.e. left-centered
        SeparatorTextBorderSize: Thickness of border in Separator() text.
        
            The value is a float. Defaults to 3.
        SeparatorTextPadding: Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
        
            The value is a pair of floats. Defaults to (20., 3.).
        TabBarBorderSize: Thickness of tab-bar separator, which takes on the tab active color to denote focus.
        TabBarOverlineSize: Thickness of tab-bar overline, which highlights the selected tab-bar.
        TabBorderSize: Thickness of borders around tabs.
        TabRounding: Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
        TableAngledHeadersAngle: Tables: Angle of angled headers (supported values range from -50 degrees to +50 degrees).
        TableAngledHeadersTextAlign: Tables: Alignment (percentages) of angled headers within the cell
        
            The value is a pair of floats. Defaults to (0.5, 0.), i.e. top-centered
        WindowBorderSize: Thickness of border around windows. Generally set to 0.0 or 1.0f. Other values not well tested.
        WindowMinSize: Minimum window size
        WindowPadding: Padding within a window.
        WindowRounding: Radius of window corners rounding. Set to 0.0 to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
        WindowTitleAlign: Alignment for window title bar text in percentages
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, Alpha : float | None = None, ButtonTextAlign : tuple[float, float] | None = None, CellPadding : tuple[float, float] | None = None, ChildBorderSize : float | None = None, ChildRounding : float | None = None, DisabledAlpha : float | None = None, FrameBorderSize : float | None = None, FramePadding : tuple[float, float] | None = None, FrameRounding : float | None = None, GrabMinSize : float | None = None, GrabRounding : float | None = None, IndentSpacing : float | None = None, ItemInnerSpacing : tuple[float, float] | None = None, ItemSpacing : tuple[float, float] | None = None, PopupBorderSize : float | None = None, PopupRounding : float | None = None, ScrollbarRounding : float | None = None, ScrollbarSize : float | None = None, SelectableTextAlign : tuple[float, float] | None = None, SeparatorTextBorderSize : float | None = None, SeparatorTextPadding : tuple[float, float] | None = None, TabBarBorderSize : float | None = None, TabBarOverlineSize : float | None = None, TabBorderSize : float | None = None, TabRounding : float | None = None, TableAngledHeadersAngle : float | None = None, TableAngledHeadersTextAlign : tuple[float, float] | None = None, WindowBorderSize : float | None = None, WindowMinSize : tuple[float, float] | None = None, WindowPadding : tuple[float, float] | None = None, WindowRounding : float | None = None, WindowTitleAlign : tuple[float, float] | None = None, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : tuple[float, float] | None = None):
        """
        Alpha: Global alpha applied to everything in Dear ImGui.
        ButtonTextAlign: Alignment of button text when button is larger than text.
        
            The value is a pair of floats. Defaults to (0.5, 0.5), i.e. centered
        CellPadding: Tables: padding between cells.
            The x padding is applied for the whole Table,
            while y can be different for every row.
        ChildBorderSize: Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        ChildRounding: Radius of child window corners rounding. Set to 0.0 to have rectangular child windows.
        DisabledAlpha: Unused currently.
        FrameBorderSize: Thickness of border around frames (most widgets). Generally set to 0.0f or 1.0f. Other values not well tested.
        FramePadding: Padding within a framed rectangle (used by most widgets)
        FrameRounding: Radius of frame corners rounding. Set to 0.0 to have rectangular frame (most widgets).
        GrabMinSize: Minimum width/height of a grab box for slider/scrollbar.
        GrabRounding: Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
        IndentSpacing: Default horizontal spacing for indentations. For instance when entering a tree node.
            A good value is Generally == (FontSize + FramePadding.x*2).
        ItemInnerSpacing: Horizontal and vertical spacing between elements inside of a composed widget.
        ItemSpacing: Horizontal and vertical spacing between widgets/lines.
        PopupBorderSize: Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        PopupRounding: Radius of popup or tooltip window corners rounding. Set to 0.0 to have rectangular popup or tooltip windows.
        ScrollbarRounding: Radius of grab corners rounding for scrollbar.
        ScrollbarSize: Width of the vertical scrollbar, Height of the horizontal scrollbar
        SelectableTextAlign: Alignment of text within the separator in percentages.
        
            The value is a pair of floats. Defaults to (0., 0.5), i.e. left-centered
        SeparatorTextBorderSize: Thickness of border in Separator() text.
        
            The value is a float. Defaults to 3.
        SeparatorTextPadding: Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
        
            The value is a pair of floats. Defaults to (20., 3.).
        TabBarBorderSize: Thickness of tab-bar separator, which takes on the tab active color to denote focus.
        TabBarOverlineSize: Thickness of tab-bar overline, which highlights the selected tab-bar.
        TabBorderSize: Thickness of borders around tabs.
        TabRounding: Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
        TableAngledHeadersAngle: Tables: Angle of angled headers (supported values range from -50 degrees to +50 degrees).
        TableAngledHeadersTextAlign: Tables: Alignment (percentages) of angled headers within the cell
        
            The value is a pair of floats. Defaults to (0.5, 0.), i.e. top-centered
        WindowBorderSize: Thickness of border around windows. Generally set to 0.0 or 1.0f. Other values not well tested.
        WindowMinSize: Minimum window size
        WindowPadding: Padding within a window.
        WindowRounding: Radius of window corners rounding. Set to 0.0 to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
        WindowTitleAlign: Alignment for window title bar text in percentages
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeStyleImGui:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def Alpha(self) -> float | None:
        """
        Global alpha applied to everything in Dear ImGui.

        The value is in the range [0, 1]. Defaults to 1.
        
        """
        ...


    @Alpha.setter
    def Alpha(self, value : float | None):
        ...


    @property
    def ButtonTextAlign(self) -> tuple[float, float] | None:
        """
        Alignment of button text when button is larger than text.
    
        The value is a pair of floats. Defaults to (0.5, 0.5), i.e. centered
        
        """
        ...


    @ButtonTextAlign.setter
    def ButtonTextAlign(self, value : tuple[float, float] | None):
        ...


    @property
    def CellPadding(self) -> tuple[float, float] | None:
        """
        Tables: padding between cells.
        The x padding is applied for the whole Table,
        while y can be different for every row.

        The value is a pair of floats. Defaults to (4, 2).
        
        """
        ...


    @CellPadding.setter
    def CellPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def ChildBorderSize(self) -> float | None:
        """
        Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.

        The value is a float. Defaults to 1.
        
        """
        ...


    @ChildBorderSize.setter
    def ChildBorderSize(self, value : float | None):
        ...


    @property
    def ChildRounding(self) -> float | None:
        """
        Radius of child window corners rounding. Set to 0.0 to have rectangular child windows.

        The value is a float. Defaults to 0.
        
        """
        ...


    @ChildRounding.setter
    def ChildRounding(self, value : float | None):
        ...


    @property
    def DisabledAlpha(self) -> float | None:
        """
        Unused currently.

        The value is in the range [0, 1]. Defaults to 0.6
        
        """
        ...


    @DisabledAlpha.setter
    def DisabledAlpha(self, value : float | None):
        ...


    @property
    def FrameBorderSize(self) -> float | None:
        """
        Thickness of border around frames (most widgets). Generally set to 0.0f or 1.0f. Other values not well tested.

        The value is a float. Defaults to 0.
        
        """
        ...


    @FrameBorderSize.setter
    def FrameBorderSize(self, value : float | None):
        ...


    @property
    def FramePadding(self) -> tuple[float, float] | None:
        """
        Padding within a framed rectangle (used by most widgets)

        The value is a pair of floats. Defaults to (4,3).
        
        """
        ...


    @FramePadding.setter
    def FramePadding(self, value : tuple[float, float] | None):
        ...


    @property
    def FrameRounding(self) -> float | None:
        """
        Radius of frame corners rounding. Set to 0.0 to have rectangular frame (most widgets).

        The value is a float. Defaults to 0.
        
        """
        ...


    @FrameRounding.setter
    def FrameRounding(self, value : float | None):
        ...


    @property
    def GrabMinSize(self) -> float | None:
        """
        Minimum width/height of a grab box for slider/scrollbar.

        The value is a float. Defaults to 12.
        
        """
        ...


    @GrabMinSize.setter
    def GrabMinSize(self, value : float | None):
        ...


    @property
    def GrabRounding(self) -> float | None:
        """
        Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.

        The value is a float. Defaults to 0.
        
        """
        ...


    @GrabRounding.setter
    def GrabRounding(self, value : float | None):
        ...


    @property
    def IndentSpacing(self) -> float | None:
        """
        Default horizontal spacing for indentations. For instance when entering a tree node.
        A good value is Generally == (FontSize + FramePadding.x*2).

        The value is a float. Defaults to 21.
        
        """
        ...


    @IndentSpacing.setter
    def IndentSpacing(self, value : float | None):
        ...


    @property
    def ItemInnerSpacing(self) -> tuple[float, float] | None:
        """
        Horizontal and vertical spacing between elements inside of a composed widget.

        The value is a pair of floats. Defaults to (4, 4).
        
        """
        ...


    @ItemInnerSpacing.setter
    def ItemInnerSpacing(self, value : tuple[float, float] | None):
        ...


    @property
    def ItemSpacing(self) -> tuple[float, float] | None:
        """
        Horizontal and vertical spacing between widgets/lines.

        The value is a pair of floats. Defaults to (8, 4).
        
        """
        ...


    @ItemSpacing.setter
    def ItemSpacing(self, value : tuple[float, float] | None):
        ...


    @property
    def PopupBorderSize(self) -> float | None:
        """
        Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.

        The value is a float. Defaults to 1.
        
        """
        ...


    @PopupBorderSize.setter
    def PopupBorderSize(self, value : float | None):
        ...


    @property
    def PopupRounding(self) -> float | None:
        """
        Radius of popup or tooltip window corners rounding. Set to 0.0 to have rectangular popup or tooltip windows.

        The value is a float. Defaults to 0.
        
        """
        ...


    @PopupRounding.setter
    def PopupRounding(self, value : float | None):
        ...


    @property
    def ScrollbarRounding(self) -> float | None:
        """
        Radius of grab corners rounding for scrollbar.

        The value is a float. Defaults to 9.
        
        """
        ...


    @ScrollbarRounding.setter
    def ScrollbarRounding(self, value : float | None):
        ...


    @property
    def ScrollbarSize(self) -> float | None:
        """
        Width of the vertical scrollbar, Height of the horizontal scrollbar

        The value is a float. Defaults to 14.
        
        """
        ...


    @ScrollbarSize.setter
    def ScrollbarSize(self, value : float | None):
        ...


    @property
    def SelectableTextAlign(self) -> tuple[float, float] | None:
        """
        Alignment of text within the separator in percentages.
    
        The value is a pair of floats. Defaults to (0., 0.5), i.e. left-centered
        
        """
        ...


    @SelectableTextAlign.setter
    def SelectableTextAlign(self, value : tuple[float, float] | None):
        ...


    @property
    def SeparatorTextBorderSize(self) -> float | None:
        """
        Thickness of border in Separator() text.
    
        The value is a float. Defaults to 3.
        
        """
        ...


    @SeparatorTextBorderSize.setter
    def SeparatorTextBorderSize(self, value : float | None):
        ...


    @property
    def SeparatorTextPadding(self) -> tuple[float, float] | None:
        """
        Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
    
        The value is a pair of floats. Defaults to (20., 3.).
        
        """
        ...


    @SeparatorTextPadding.setter
    def SeparatorTextPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def TabBarBorderSize(self) -> float | None:
        """
        Thickness of tab-bar separator, which takes on the tab active color to denote focus.

        The value is a float. Defaults to 1.
        
        """
        ...


    @TabBarBorderSize.setter
    def TabBarBorderSize(self, value : float | None):
        ...


    @property
    def TabBarOverlineSize(self) -> float | None:
        """
        Thickness of tab-bar overline, which highlights the selected tab-bar.

        The value is a float. Defaults to 2.
        
        """
        ...


    @TabBarOverlineSize.setter
    def TabBarOverlineSize(self, value : float | None):
        ...


    @property
    def TabBorderSize(self) -> float | None:
        """
        Thickness of borders around tabs.

        The value is a float. Defaults to 0.
        
        """
        ...


    @TabBorderSize.setter
    def TabBorderSize(self, value : float | None):
        ...


    @property
    def TabRounding(self) -> float | None:
        """
        Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.

        The value is a float. Defaults to 4.
        
        """
        ...


    @TabRounding.setter
    def TabRounding(self, value : float | None):
        ...


    @property
    def TableAngledHeadersAngle(self) -> float | None:
        """
        Tables: Angle of angled headers (supported values range from -50 degrees to +50 degrees).

        The value is a float. Defaults to 35.0f * (IM_PI / 180.0f).
        
        """
        ...


    @TableAngledHeadersAngle.setter
    def TableAngledHeadersAngle(self, value : float | None):
        ...


    @property
    def TableAngledHeadersTextAlign(self) -> tuple[float, float] | None:
        """
        Tables: Alignment (percentages) of angled headers within the cell
    
        The value is a pair of floats. Defaults to (0.5, 0.), i.e. top-centered
        
        """
        ...


    @TableAngledHeadersTextAlign.setter
    def TableAngledHeadersTextAlign(self, value : tuple[float, float] | None):
        ...


    @property
    def WindowBorderSize(self) -> float | None:
        """
        Thickness of border around windows. Generally set to 0.0 or 1.0f. Other values not well tested.

        The value is a float. Defaults to 1.
        
        """
        ...


    @WindowBorderSize.setter
    def WindowBorderSize(self, value : float | None):
        ...


    @property
    def WindowMinSize(self) -> tuple[float, float] | None:
        """
        Minimum window size

        The value is a pair of float (dx, dy). Defaults to (32, 32)
        
        """
        ...


    @WindowMinSize.setter
    def WindowMinSize(self, value : tuple[float, float] | None):
        ...


    @property
    def WindowPadding(self) -> tuple[float, float] | None:
        """
        Padding within a window.

        The value is a pair of float (dx, dy). Defaults to (8, 8)
        
        """
        ...


    @WindowPadding.setter
    def WindowPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def WindowRounding(self) -> float | None:
        """
        Radius of window corners rounding. Set to 0.0 to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.

        The value is a float. Defaults to 0.
        
        """
        ...


    @WindowRounding.setter
    def WindowRounding(self, value : float | None):
        ...


    @property
    def WindowTitleAlign(self) -> tuple[float, float] | None:
        """
        Alignment for window title bar text in percentages

        The value is a pair of float (dx, dy). Defaults to (0., 0.5), which means left-aligned, vertical centering on the row
        
        """
        ...


    @WindowTitleAlign.setter
    def WindowTitleAlign(self, value : tuple[float, float] | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_rounding(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables rounding (after scaling) to the
        closest integer the parameters. The rounding is only
        applied to parameters which impact item positioning
        in a way that would prevent a pixel perfect result.
        
        """
        ...


    @no_rounding.setter
    def no_rounding(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this theme
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self) -> tuple[float, float] | None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : tuple[float, float] | None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeStyleImNodes(baseThemeStyle):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : tuple[float, float] | None = None):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : tuple[float, float] | None = None):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeStyleImNodes:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_rounding(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables rounding (after scaling) to the
        closest integer the parameters. The rounding is only
        applied to parameters which impact item positioning
        in a way that would prevent a pixel perfect result.
        
        """
        ...


    @no_rounding.setter
    def no_rounding(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this theme
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self) -> tuple[float, float] | None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : tuple[float, float] | None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeStyleImPlot(baseThemeStyle):
    def __init__(self, context : Context, AnnotationPadding : tuple[float, float] | None = None, DigitalBitGap : float | None = None, DigitalBitHeight : float | None = None, ErrorBarSize : float | None = None, ErrorBarWeight : float | None = None, FillAlpha : float | None = None, FitPadding : tuple[float, float] | None = None, LabelPadding : tuple[float, float] | None = None, LegendInnerPadding : tuple[float, float] | None = None, LegendPadding : tuple[float, float] | None = None, LegendSpacing : tuple[float, float] | None = None, LineWeight : float | None = None, MajorGridSize : tuple[float, float] | None = None, MajorTickLen : tuple[float, float] | None = None, MajorTickSize : tuple[float, float] | None = None, Marker : float | None = None, MarkerSize : float | None = None, MarkerWeight : float | None = None, MinorAlpha : float | None = None, MinorGridSize : tuple[float, float] | None = None, MinorTickLen : tuple[float, float] | None = None, MinorTickSize : tuple[float, float] | None = None, MousePosPadding : tuple[float, float] | None = None, PlotBorderSize : float | None = None, PlotDefaultSize : tuple[float, float] | None = None, PlotMinSize : tuple[float, float] | None = None, PlotPadding : tuple[float, float] | None = None, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : tuple[float, float] | None = None):
        """

        AnnotationPadding: Text padding around annotation labels.
        DigitalBitGap: Digital channels bit padding gap in pixels.
        DigitalBitHeight: Digital channels bit height (at 1) in pixels.
        ErrorBarSize: Error bar whisker width in pixels.
        ErrorBarWeight: Error bar whisker weight in pixels.
        FillAlpha: Alpha modifier applied to all plot item fills.
        FitPadding: Additional fit padding as a percentage of the fit extents (e.g. (0.1,0.1) adds 10% to the fit extents of X and Y).
        LabelPadding: Padding between axes labels, tick labels, and plot edge.
        LegendInnerPadding: Legend inner padding from legend edges.
        LegendPadding: Legend padding from plot edges.
        LegendSpacing: Spacing between legend entries.
        LineWeight: Plot item line weight in pixels.
        MajorGridSize: Line thickness of major grid lines.
        MajorTickLen: Major tick lengths for X and Y axes.
        MajorTickSize: Line thickness of major ticks.
        Marker: Marker specification.
        MarkerSize: Marker size in pixels (roughly the marker's "radius").
        MarkerWeight: Plot outline weight of markers in pixels.
        MinorAlpha: Alpha multiplier applied to minor axis grid lines.
        MinorGridSize: Line thickness of minor grid lines.
        MinorTickLen: Minor tick lengths for X and Y axes.
        MinorTickSize: Line thickness of minor ticks.
        MousePosPadding: Padding between plot edge and interior info text.
        PlotBorderSize: Thickness of border around plot area.
        PlotDefaultSize: Default size used for plots
        PlotMinSize: Minimum size plot frame can be when shrunk.
        PlotPadding: Padding between widget frame and plot area, labels, or outside legends (i.e. main padding).
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, AnnotationPadding : tuple[float, float] | None = None, DigitalBitGap : float | None = None, DigitalBitHeight : float | None = None, ErrorBarSize : float | None = None, ErrorBarWeight : float | None = None, FillAlpha : float | None = None, FitPadding : tuple[float, float] | None = None, LabelPadding : tuple[float, float] | None = None, LegendInnerPadding : tuple[float, float] | None = None, LegendPadding : tuple[float, float] | None = None, LegendSpacing : tuple[float, float] | None = None, LineWeight : float | None = None, MajorGridSize : tuple[float, float] | None = None, MajorTickLen : tuple[float, float] | None = None, MajorTickSize : tuple[float, float] | None = None, Marker : float | None = None, MarkerSize : float | None = None, MarkerWeight : float | None = None, MinorAlpha : float | None = None, MinorGridSize : tuple[float, float] | None = None, MinorTickLen : tuple[float, float] | None = None, MinorTickSize : tuple[float, float] | None = None, MousePosPadding : tuple[float, float] | None = None, PlotBorderSize : float | None = None, PlotDefaultSize : tuple[float, float] | None = None, PlotMinSize : tuple[float, float] | None = None, PlotPadding : tuple[float, float] | None = None, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : tuple[float, float] | None = None):
        """
        AnnotationPadding: Text padding around annotation labels.
        DigitalBitGap: Digital channels bit padding gap in pixels.
        DigitalBitHeight: Digital channels bit height (at 1) in pixels.
        ErrorBarSize: Error bar whisker width in pixels.
        ErrorBarWeight: Error bar whisker weight in pixels.
        FillAlpha: Alpha modifier applied to all plot item fills.
        FitPadding: Additional fit padding as a percentage of the fit extents (e.g. (0.1,0.1) adds 10% to the fit extents of X and Y).
        LabelPadding: Padding between axes labels, tick labels, and plot edge.
        LegendInnerPadding: Legend inner padding from legend edges.
        LegendPadding: Legend padding from plot edges.
        LegendSpacing: Spacing between legend entries.
        LineWeight: Plot item line weight in pixels.
        MajorGridSize: Line thickness of major grid lines.
        MajorTickLen: Major tick lengths for X and Y axes.
        MajorTickSize: Line thickness of major ticks.
        Marker: Marker specification.
        MarkerSize: Marker size in pixels (roughly the marker's "radius").
        MarkerWeight: Plot outline weight of markers in pixels.
        MinorAlpha: Alpha multiplier applied to minor axis grid lines.
        MinorGridSize: Line thickness of minor grid lines.
        MinorTickLen: Minor tick lengths for X and Y axes.
        MinorTickSize: Line thickness of minor ticks.
        MousePosPadding: Padding between plot edge and interior info text.
        PlotBorderSize: Thickness of border around plot area.
        PlotDefaultSize: Default size used for plots
        PlotMinSize: Minimum size plot frame can be when shrunk.
        PlotPadding: Padding between widget frame and plot area, labels, or outside legends (i.e. main padding).
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeStyleImPlot:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def AnnotationPadding(self) -> tuple[float, float] | None:
        """
        Text padding around annotation labels.

        The value is a pair of floats. Defaults to (2, 2).
        
        """
        ...


    @AnnotationPadding.setter
    def AnnotationPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def DigitalBitGap(self) -> float | None:
        """
        Digital channels bit padding gap in pixels.

        The value is a float. Defaults to 4.
        
        """
        ...


    @DigitalBitGap.setter
    def DigitalBitGap(self, value : float | None):
        ...


    @property
    def DigitalBitHeight(self) -> float | None:
        """
        Digital channels bit height (at 1) in pixels.

        The value is a float. Defaults to 8.
        
        """
        ...


    @DigitalBitHeight.setter
    def DigitalBitHeight(self, value : float | None):
        ...


    @property
    def ErrorBarSize(self) -> float | None:
        """
        Error bar whisker width in pixels.

        The value is a float. Defaults to 5.
        
        """
        ...


    @ErrorBarSize.setter
    def ErrorBarSize(self, value : float | None):
        ...


    @property
    def ErrorBarWeight(self) -> float | None:
        """
        Error bar whisker weight in pixels.

        The value is a float. Defaults to 1.5.
        
        """
        ...


    @ErrorBarWeight.setter
    def ErrorBarWeight(self, value : float | None):
        ...


    @property
    def FillAlpha(self) -> float | None:
        """
        Alpha modifier applied to all plot item fills.

        The value is a float. Defaults to 1.
        
        """
        ...


    @FillAlpha.setter
    def FillAlpha(self, value : float | None):
        ...


    @property
    def FitPadding(self) -> tuple[float, float] | None:
        """
        Additional fit padding as a percentage of the fit extents (e.g. (0.1,0.1) adds 10% to the fit extents of X and Y).

        The value is a pair of floats. Defaults to (0, 0).
        
        """
        ...


    @FitPadding.setter
    def FitPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def LabelPadding(self) -> tuple[float, float] | None:
        """
        Padding between axes labels, tick labels, and plot edge.

        The value is a pair of floats. Defaults to (5, 5).
        
        """
        ...


    @LabelPadding.setter
    def LabelPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def LegendInnerPadding(self) -> tuple[float, float] | None:
        """
        Legend inner padding from legend edges.

        The value is a pair of floats. Defaults to (5, 5).
        
        """
        ...


    @LegendInnerPadding.setter
    def LegendInnerPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def LegendPadding(self) -> tuple[float, float] | None:
        """
        Legend padding from plot edges.

        The value is a pair of floats. Defaults to (10, 10).
        
        """
        ...


    @LegendPadding.setter
    def LegendPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def LegendSpacing(self) -> tuple[float, float] | None:
        """
        Spacing between legend entries.

        The value is a pair of floats. Defaults to (5, 0).
        
        """
        ...


    @LegendSpacing.setter
    def LegendSpacing(self, value : tuple[float, float] | None):
        ...


    @property
    def LineWeight(self) -> float | None:
        """
        Plot item line weight in pixels.

        The value is a float. Defaults to 1.
        
        """
        ...


    @LineWeight.setter
    def LineWeight(self, value : float | None):
        ...


    @property
    def MajorGridSize(self) -> tuple[float, float] | None:
        """
        Line thickness of major grid lines.

        The value is a pair of floats. Defaults to (1, 1).
        
        """
        ...


    @MajorGridSize.setter
    def MajorGridSize(self, value : tuple[float, float] | None):
        ...


    @property
    def MajorTickLen(self) -> tuple[float, float] | None:
        """
        Major tick lengths for X and Y axes.

        The value is a pair of floats. Defaults to (10, 10).
        
        """
        ...


    @MajorTickLen.setter
    def MajorTickLen(self, value : tuple[float, float] | None):
        ...


    @property
    def MajorTickSize(self) -> tuple[float, float] | None:
        """
        Line thickness of major ticks.

        The value is a pair of floats. Defaults to (1, 1).
        
        """
        ...


    @MajorTickSize.setter
    def MajorTickSize(self, value : tuple[float, float] | None):
        ...


    @property
    def Marker(self) -> float | None:
        """
        Marker specification.

        The value is an integer. Defaults to 1.
        
        """
        ...


    @Marker.setter
    def Marker(self, value : float | None):
        ...


    @property
    def MarkerSize(self) -> float | None:
        """
        Marker size in pixels (roughly the marker's "radius").

        The value is a float. Defaults to 4.
        
        """
        ...


    @MarkerSize.setter
    def MarkerSize(self, value : float | None):
        ...


    @property
    def MarkerWeight(self) -> float | None:
        """
        Plot outline weight of markers in pixels.

        The value is a float. Defaults to 1.
        
        """
        ...


    @MarkerWeight.setter
    def MarkerWeight(self, value : float | None):
        ...


    @property
    def MinorAlpha(self) -> float | None:
        """
        Alpha multiplier applied to minor axis grid lines.

        The value is a float. Defaults to 0.25.
        
        """
        ...


    @MinorAlpha.setter
    def MinorAlpha(self, value : float | None):
        ...


    @property
    def MinorGridSize(self) -> tuple[float, float] | None:
        """
        Line thickness of minor grid lines.

        The value is a pair of floats. Defaults to (1, 1).
        
        """
        ...


    @MinorGridSize.setter
    def MinorGridSize(self, value : tuple[float, float] | None):
        ...


    @property
    def MinorTickLen(self) -> tuple[float, float] | None:
        """
        Minor tick lengths for X and Y axes.

        The value is a pair of floats. Defaults to (5, 5).
        
        """
        ...


    @MinorTickLen.setter
    def MinorTickLen(self, value : tuple[float, float] | None):
        ...


    @property
    def MinorTickSize(self) -> tuple[float, float] | None:
        """
        Line thickness of minor ticks.

        The value is a pair of floats. Defaults to (1, 1).
        
        """
        ...


    @MinorTickSize.setter
    def MinorTickSize(self, value : tuple[float, float] | None):
        ...


    @property
    def MousePosPadding(self) -> tuple[float, float] | None:
        """
        Padding between plot edge and interior info text.

        The value is a pair of floats. Defaults to (10, 10).
        
        """
        ...


    @MousePosPadding.setter
    def MousePosPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def PlotBorderSize(self) -> float | None:
        """
        Thickness of border around plot area.

        The value is a float. Defaults to 1.
        
        """
        ...


    @PlotBorderSize.setter
    def PlotBorderSize(self, value : float | None):
        ...


    @property
    def PlotDefaultSize(self) -> tuple[float, float] | None:
        """
        Default size used for plots

        The value is a pair of floats. Defaults to (400, 300).
        
        """
        ...


    @PlotDefaultSize.setter
    def PlotDefaultSize(self, value : tuple[float, float] | None):
        ...


    @property
    def PlotMinSize(self) -> tuple[float, float] | None:
        """
        Minimum size plot frame can be when shrunk.

        The value is a pair of floats. Defaults to (200, 150).
        
        """
        ...


    @PlotMinSize.setter
    def PlotMinSize(self, value : tuple[float, float] | None):
        ...


    @property
    def PlotPadding(self) -> tuple[float, float] | None:
        """
        Padding between widget frame and plot area, labels, or outside legends (i.e. main padding).

        The value is a pair of floats. Defaults to (10, 10).
        
        """
        ...


    @PlotPadding.setter
    def PlotPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_rounding(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables rounding (after scaling) to the
        closest integer the parameters. The rounding is only
        applied to parameters which impact item positioning
        in a way that would prevent a pixel perfect result.
        
        """
        ...


    @no_rounding.setter
    def no_rounding(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this theme
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self) -> tuple[float, float] | None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : tuple[float, float] | None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class TimeWatcher(uiItem):
    """
    A placeholder uiItem parent that doesn't draw or have any impact on rendering.
    This item calls the callback with times in ns.
    These times can be compared with the times in the metrics
    that can be obtained from the viewport in order to
    precisely figure out the time spent rendering specific items.

    The first time corresponds to the time this item is called
    for rendering

    The second time corresponds to the time after the
    children have finished rendering.

    The third time corresponds to the time when viewport
    started rendering items for this frame. It is
    given to prevent the user from having to keep track of the
    viewport metrics (since the callback might be called
    after or before the viewport updated its metrics for this
    frame or another one).

    The fourth number corresponds to the frame count
    at the the time the callback was issued.

    Note the times relate to CPU time (checking states, preparing
    GPU data, etc), not to GPU rendering time.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TimeWatcher:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class ToggledCloseHandler(baseHandler):
    """
    Handler that triggers the callback when the
    item switches from an opened state to a closed
    state.
    *Warning*: Does not mean an item is un-shown
    by a user interaction (what we usually mean
    by closing a window).
    Here Close/Open refers to being in a
    reduced state when the full content is not
    shown, but could be if the user clicked on
    a specific button. The doesn't mean that
    the object is show or not shown.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ToggledCloseHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ToggledOpenHandler(baseHandler):
    """
    Handler that triggers the callback when the
    item switches from an closed state to a opened
    state. Here Close/Open refers to being in a
    reduced state when the full content is not
    shown, but could be if the user clicked on
    a specific button. The doesn't mean that
    the object is show or not shown.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ToggledOpenHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Tooltip(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], condition_from_handler : Any = ..., delay : float = 0.0, enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, hide_on_activity : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, target : Any = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_from_handler: When set, the handler referenced in
            this field will be used to replace
            the target hovering check. It will
            apply to target, which must be set.
        delay: Delay in seconds with no motion before showing the tooltip
            -1: Use imgui defaults
            Has no effect if the target is not the previous sibling,
            or if condition_from_handler is set.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hide_on_activity: Hide the tooltip when the mouse moves
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        target: Target item which state will be checked
            to trigger the tooltip.
            Note if the item is after this tooltip
            in the rendering tree, there will be
            a frame delay.
            If no target is set, the previous sibling
            is the target.
            If the target is not the previous sibling,
            delay will have no effect.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], condition_from_handler : Any = ..., delay : float = 0.0, enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, hide_on_activity : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, target : Any = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_from_handler: When set, the handler referenced in
            this field will be used to replace
            the target hovering check. It will
            apply to target, which must be set.
        delay: Delay in seconds with no motion before showing the tooltip
            -1: Use imgui defaults
            Has no effect if the target is not the previous sibling,
            or if condition_from_handler is set.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hide_on_activity: Hide the tooltip when the mouse moves
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        target: Target item which state will be checked
            to trigger the tooltip.
            Note if the item is after this tooltip
            in the rendering tree, there will be
            a frame delay.
            If no target is set, the previous sibling
            is the target.
            If the target is not the previous sibling,
            delay will have no effect.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Tooltip:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def condition_from_handler(self):
        """
        When set, the handler referenced in
        this field will be used to replace
        the target hovering check. It will
        apply to target, which must be set.
        
        """
        ...


    @condition_from_handler.setter
    def condition_from_handler(self, value):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def delay(self) -> float:
        """
        Delay in seconds with no motion before showing the tooltip
        -1: Use imgui defaults
        Has no effect if the target is not the previous sibling,
        or if condition_from_handler is set.
        
        """
        ...


    @delay.setter
    def delay(self, value : float):
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hide_on_activity(self) -> float:
        """
        Hide the tooltip when the mouse moves
        
        """
        ...


    @hide_on_activity.setter
    def hide_on_activity(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def target(self):
        """
        Target item which state will be checked
        to trigger the tooltip.
        Note if the item is after this tooltip
        in the rendering tree, there will be
        a frame delay.
        If no target is set, the previous sibling
        is the target.
        If the target is not the previous sibling,
        delay will have no effect.
        
        """
        ...


    @target.setter
    def target(self, value):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class TreeNode(uiItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], default_open : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", leaf : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, open_on_arrow : bool = False, open_on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, selectable : bool = False, shareable_value : SharedBool = ..., show : bool = True, span_full_width : bool = False, span_text_width : bool = False, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bullet: Display a bullet instead of arrow.
            IMPORTANT: node can still be marked open/close if
            you don't set the _Leaf flag!
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        default_open: Default node to be open
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leaf: No collapsing, no arrow (use as a convenience for leaf nodes).
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        open_on_arrow: Only open when clicking on the arrow part.
            If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
            single-click arrow or double-click all box to open.
        open_on_double_click: Need double-click to open node
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        selectable: Draw the TreeNode as selected when opened
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        span_full_width: Extend hit box to the left-most
            and right-most edges (cover the indent area).
        span_text_width: Narrow hit box + narrow hovering
            highlight, will only cover the label text.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], default_open : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", leaf : bool = False, next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, open_on_arrow : bool = False, open_on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, selectable : bool = False, shareable_value : SharedBool = ..., show : bool = True, span_full_width : bool = False, span_text_width : bool = False, theme : Any = ..., user_data : Any = ..., value : bool = False, width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        bullet: Display a bullet instead of arrow.
            IMPORTANT: node can still be marked open/close if
            you don't set the _Leaf flag!
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        default_open: Default node to be open
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leaf: No collapsing, no arrow (use as a convenience for leaf nodes).
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        open_on_arrow: Only open when clicking on the arrow part.
            If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
            single-click arrow or double-click all box to open.
        open_on_double_click: Need double-click to open node
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        selectable: Draw the TreeNode as selected when opened
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        span_full_width: Extend hit box to the left-most
            and right-most edges (cover the indent area).
        span_text_width: Narrow hit box + narrow hovering
            highlight, will only cover the label text.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TreeNode:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def bullet(self) -> bool:
        """
        Writable attribute: Display a bullet instead of arrow.
        IMPORTANT: node can still be marked open/close if
        you don't set the _Leaf flag!
        
        """
        ...


    @bullet.setter
    def bullet(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def default_open(self) -> bool:
        """
        Writable attribute: Default node to be open
        
        """
        ...


    @default_open.setter
    def default_open(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def leaf(self) -> bool:
        """
        Writable attribute: No collapsing, no arrow (use as a convenience for leaf nodes).
        
        """
        ...


    @leaf.setter
    def leaf(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def open_on_arrow(self) -> bool:
        """
        Writable attribute:  Only open when clicking on the arrow part.
        If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
        single-click arrow or double-click all box to open.
        
        """
        ...


    @open_on_arrow.setter
    def open_on_arrow(self, value : bool):
        ...


    @property
    def open_on_double_click(self) -> bool:
        """
        Writable attribute: Need double-click to open node
        
        """
        ...


    @open_on_double_click.setter
    def open_on_double_click(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def selectable(self) -> bool:
        """
        Writable attribute: Draw the TreeNode as selected when opened
        
        """
        ...


    @selectable.setter
    def selectable(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def span_full_width(self) -> bool:
        """
        Writable attribute: Extend hit box to the left-most
        and right-most edges (cover the indent area).
        
        """
        ...


    @span_full_width.setter
    def span_full_width(self, value : bool):
        ...


    @property
    def span_text_width(self) -> bool:
        """
        Writable attribute: Narrow hit box + narrow hovering
        highlight, will only cover the label text.
        
        """
        ...


    @span_text_width.setter
    def span_text_width(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class VerticalLayout(Layout):
    """
    Same as HorizontalLayout but vertically
    
    """
    def __init__(self, context : Context, alignment_mode : Alignment = 0, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), positions : list = [], previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        alignment_mode: Vertical alignment mode of the items.
            TOP: items are appended from the top
            BOTTOM: items are appended from the BOTTOM
            CENTER: items are centered
            JUSTIFIED: spacing is organized such
            that items start at the TOP and end
            at the BOTTOM.
            MANUAL: items are positionned at the requested
            positions
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the y position starting
            from the top left of this item at which to
            place the children items.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, alignment_mode : Alignment = 0, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), positions : list = [], previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        alignment_mode: Vertical alignment mode of the items.
            TOP: items are appended from the top
            BOTTOM: items are appended from the BOTTOM
            CENTER: items are centered
            JUSTIFIED: spacing is organized such
            that items start at the TOP and end
            at the BOTTOM.
            MANUAL: items are positionned at the requested
            positions
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the y position starting
            from the top left of this item at which to
            place the children items.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        """
        Force an update of the layout next time the scene
        is rendered
        
        """
        ...


    def __enter__(self) -> VerticalLayout:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def alignment_mode(self) -> Alignment:
        """
        Vertical alignment mode of the items.
        TOP: items are appended from the top
        BOTTOM: items are appended from the BOTTOM
        CENTER: items are centered
        JUSTIFIED: spacing is organized such
        that items start at the TOP and end
        at the BOTTOM.
        MANUAL: items are positionned at the requested
        positions

        FOR TOP/BOTTOM/CENTER, ItemSpacing's style can
        be used to control spacing between the items.
        Default is TOP.
        
        """
        ...


    @alignment_mode.setter
    def alignment_mode(self, value : Alignment):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def positions(self) -> list:
        """
        When in MANUAL mode, the y position starting
        from the top left of this item at which to
        place the children items.

        If the positions are between 0 and 1, they are
        interpreted as percentages relative to the
        size of the Layout height.
        If the positions are negatives, they are interpreted
        as in reference to the bottom of the layout rather
        than the top. Items are still top aligned to
        the target position though.

        Setting this field sets the alignment mode to
        MANUAL.
        
        """
        ...


    @positions.setter
    def positions(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class Viewport(baseItem):
    """
    The viewport corresponds to the main item containing all the visuals.
    It is decorated by the operating system and can be minimized/maximized/made fullscreen.

    Attributes:
    - clear_color: Color used to clear the viewport.
    - small_icon: Small icon for the viewport.
    - large_icon: Large icon for the viewport.
    - x_pos: X position of the viewport.
    - y_pos: Y position of the viewport.
    - width: Width of the viewport.
    - height: Height of the viewport.
    - resizable: Boolean indicating if the viewport is resizable.
    - vsync: Boolean indicating if vsync is enabled.
    - dpi: Requested scaling (DPI) from the OS for this window.
    - scale: Multiplicative scale used to scale automatically all items.
    - min_width: Minimum width of the viewport.
    - max_width: Maximum width of the viewport.
    - min_height: Minimum height of the viewport.
    - max_height: Maximum height of the viewport.
    - always_on_top: Boolean indicating if the viewport is always on top.
    - decorated: Boolean indicating if the viewport is decorated.
    - handlers: Bound handler (or handlerList) for the viewport.
    - cursor: Mouse cursor for the viewport.
    - font: Global font for the viewport.
    - theme: Global theme for the viewport.
    - title: Title of the viewport.
    - disable_close: Boolean indicating if the close button is disabled.
    - fullscreen: Boolean indicating if the viewport is in fullscreen mode.
    - minimized: Boolean indicating if the viewport is minimized.
    - maximized: Boolean indicating if the viewport is maximized.
    - wait_for_input: Boolean indicating if rendering should wait for input.
    - shown: Boolean indicating if the viewport window has been created by the OS.
    - resize_callback: Callback to be issued when the viewport is resized.
    - close_callback: Callback to be issued when the viewport is closed.
    - metrics: Rendering related metrics relative to the last frame.
    
    """
    def __init__(self, context : Context, always_on_top : bool = False, attach : Any = ..., before : Any = ..., children : list[Window, ViewportDrawList, MenuBar] = [], clear_color : tuple = (0.0, 0.0, 0.0, 1.0), close_callback : Any = ..., cursor : MouseCursor = 0, decorated : bool = True, disable_close : bool = False, font : Font = None, fullscreen : bool = False, handlers : list = [], height : int = 800, large_icon : str = "b''", max_height : int = 10000, max_width : int = 10000, maximized : bool = False, min_height : int = 250, min_width : int = 250, minimized : bool = False, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, resizable : bool = True, resize_callback : Any = ..., retrieve_framebuffer : bool = False, scale : float = 1.0, small_icon : str = "b''", theme : Any = ..., title : str = "DearCyGui Window", user_data : Any = ..., vsync : bool = True, wait_for_input : bool = False, width : int = 1280, x_pos : int = 100, y_pos : int = 100):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        close_callback: Callback to be issued when the viewport is closed.
        cursor: Change the mouse cursor to one of MouseCursor.
            The mouse cursor is reset every frame.
        font: global font
        handlers: bound handler (or handlerList)
            for the viewport.
            Only Key and Mouse handlers are compatible.
            Handlers that check item states won't work.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resize_callback: Callback to be issued when the viewport is resized.
        retrieve_framebuffer: Whether to activate the framebuffer retrieval.
            If set to true, the framebuffer field will be
            populated. This has a performance cost.
        scale: Multiplicative scale that, multiplied by
            the value of dpi, is used to scale
            automatically all items.
        theme: global theme
        user_data: User data of any type.
        wait_for_input: When the app doesn't need to be
            refreshed, one can save power comsumption by not
            rendering. wait_for_input will pause rendering until
            a mouse or keyboard event is received.
            wake() can also be used to restart rendering
            for one frame.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_on_top : bool = False, attach : Any = ..., before : Any = ..., children : list[Window, ViewportDrawList, MenuBar] = [], clear_color : tuple = (0.0, 0.0, 0.0, 1.0), close_callback : Any = ..., cursor : MouseCursor = 0, decorated : bool = True, disable_close : bool = False, font : Font = None, fullscreen : bool = False, handlers : list = [], height : int = 800, large_icon : str = "b''", max_height : int = 10000, max_width : int = 10000, maximized : bool = False, min_height : int = 250, min_width : int = 250, minimized : bool = False, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, resizable : bool = True, resize_callback : Any = ..., retrieve_framebuffer : bool = False, scale : float = 1.0, small_icon : str = "b''", theme : Any = ..., title : str = "DearCyGui Window", user_data : Any = ..., vsync : bool = True, wait_for_input : bool = False, width : int = 1280, x_pos : int = 100, y_pos : int = 100):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        close_callback: Callback to be issued when the viewport is closed.
        cursor: Change the mouse cursor to one of MouseCursor.
            The mouse cursor is reset every frame.
        font: global font
        handlers: bound handler (or handlerList)
            for the viewport.
            Only Key and Mouse handlers are compatible.
            Handlers that check item states won't work.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resize_callback: Callback to be issued when the viewport is resized.
        retrieve_framebuffer: Whether to activate the framebuffer retrieval.
            If set to true, the framebuffer field will be
            populated. This has a performance cost.
        scale: Multiplicative scale that, multiplied by
            the value of dpi, is used to scale
            automatically all items.
        theme: global theme
        user_data: User data of any type.
        wait_for_input: When the app doesn't need to be
            refreshed, one can save power comsumption by not
            rendering. wait_for_input will pause rendering until
            a mouse or keyboard event is received.
            wake() can also be used to restart rendering
            for one frame.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def initialize(self, minimized=False, maximized=False, always_on_top : bool = False, attach : Any = ..., before : Any = ..., children : list[Window, ViewportDrawList, MenuBar] = [], clear_color : tuple = (0.0, 0.0, 0.0, 1.0), close_callback : Any = ..., cursor : MouseCursor = 0, decorated : bool = True, disable_close : bool = False, font : Font = None, fullscreen : bool = False, handlers : list = [], height : int = 800, large_icon : str = "b''", max_height : int = 10000, max_width : int = 10000, min_height : int = 250, min_width : int = 250, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, resizable : bool = True, resize_callback : Any = ..., retrieve_framebuffer : bool = False, scale : float = 1.0, small_icon : str = "b''", theme : Any = ..., title : str = "DearCyGui Window", user_data : Any = ..., vsync : bool = True, wait_for_input : bool = False, width : int = 1280, x_pos : int = 100, y_pos : int = 100):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        close_callback: Callback to be issued when the viewport is closed.
        cursor: Change the mouse cursor to one of MouseCursor.
            The mouse cursor is reset every frame.
        font: global font
        handlers: bound handler (or handlerList)
            for the viewport.
            Only Key and Mouse handlers are compatible.
            Handlers that check item states won't work.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resize_callback: Callback to be issued when the viewport is resized.
        retrieve_framebuffer: Whether to activate the framebuffer retrieval.
            If set to true, the framebuffer field will be
            populated. This has a performance cost.
        scale: Multiplicative scale that, multiplied by
            the value of dpi, is used to scale
            automatically all items.
        theme: global theme
        user_data: User data of any type.
        wait_for_input: When the app doesn't need to be
            refreshed, one can save power comsumption by not
            rendering. wait_for_input will pause rendering until
            a mouse or keyboard event is received.
            wake() can also be used to restart rendering
            for one frame.
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def render_frame(self, can_skip_presenting=False):
        """
        Render one frame.

        Rendering occurs in several separated steps:
        . Mouse/Keyboard events are processed. it's there
          that wait_for_input has an effect.
        . The viewport item, and then all the rendering tree are
          walked through to query their state and prepare the rendering
          commands using ImGui, ImPlot and ImNodes
        . The rendering commands are submitted to the GPU.
        . The submission is passed to the operating system to handle the
          window update. It's usually at this step that the system will
          apply vsync by making the application wait if it rendered faster
          than the screen refresh rate.

        can_skip_presenting: rendering will occur (handlers checked, etc),
            but the backend might decide, if this flag is set, to not
            submit the rendering commands to the GPU and refresh the
            window. Can be used to avoid using the GPU in response
            to a simple mouse motion.
            Fast checks are used to determine if presenting should occur
            or not. Thus set this only if you haven't updated any content
            on the screen.
            Note wake() will automatically force a redraw the next frame.

        Returns True if the frame was presented to the screen,
            False else (can_skip_presenting)
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def wake(self):
        """
        In case rendering is waiting for an input (waitForInputs),
        generate a fake input to force rendering.

        This is useful if you have updated the content asynchronously
        and want to show the update
        
        """
        ...


    def __enter__(self) -> Viewport:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def always_on_top(self) -> bool:
        ...


    @always_on_top.setter
    def always_on_top(self, value : bool):
        ...


    @property
    def children(self) -> list[Window, ViewportDrawList, MenuBar]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[Window, ViewportDrawList, MenuBar]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def clear_color(self) -> tuple:
        ...


    @clear_color.setter
    def clear_color(self, value : tuple):
        ...


    @property
    def close_callback(self):
        """
        Callback to be issued when the viewport is closed.
        
        """
        ...


    @close_callback.setter
    def close_callback(self, value):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def cursor(self) -> MouseCursor:
        """
        Change the mouse cursor to one of MouseCursor.
        The mouse cursor is reset every frame.
        
        """
        ...


    @cursor.setter
    def cursor(self, value : MouseCursor):
        ...


    @property
    def decorated(self) -> bool:
        ...


    @decorated.setter
    def decorated(self, value : bool):
        ...


    @property
    def disable_close(self) -> bool:
        ...


    @disable_close.setter
    def disable_close(self, value : bool):
        ...


    @property
    def dpi(self) -> float:
        """
        Requested scaling (DPI) from the OS for
        this window. The value is valid after
        initialize() and might change over time,
        for instance if the window is moved to another
        monitor.

        The DPI is used to scale all items automatically.
        From the developper point of view, everything behaves
        as if the DPI is 1. This behaviour can be disabled
        using the related scaling settings.
        
        """
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: global font
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def framebuffer(self):
        ...


    @property
    def fullscreen(self) -> bool:
        ...


    @fullscreen.setter
    def fullscreen(self, value : bool):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handler (or handlerList)
        for the viewport.
        Only Key and Mouse handlers are compatible.
        Handlers that check item states won't work.
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def large_icon(self) -> str:
        ...


    @large_icon.setter
    def large_icon(self, value : str):
        ...


    @property
    def max_height(self) -> int:
        ...


    @max_height.setter
    def max_height(self, value : int):
        ...


    @property
    def max_width(self) -> int:
        ...


    @max_width.setter
    def max_width(self, value : int):
        ...


    @property
    def maximized(self) -> bool:
        ...


    @maximized.setter
    def maximized(self, value : bool):
        ...


    @property
    def metrics(self) -> dict:
        ...


    @property
    def min_height(self) -> int:
        ...


    @min_height.setter
    def min_height(self, value : int):
        ...


    @property
    def min_width(self) -> int:
        ...


    @min_width.setter
    def min_width(self, value : int):
        ...


    @property
    def minimized(self) -> bool:
        ...


    @minimized.setter
    def minimized(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def resizable(self) -> bool:
        ...


    @resizable.setter
    def resizable(self, value : bool):
        ...


    @property
    def resize_callback(self):
        """
        Callback to be issued when the viewport is resized.

        The data returned is a tuple containing:
        . The width in pixels
        . The height in pixels
        . The width according to the OS (OS dependent)
        . The height according to the OS (OS dependent)
        
        """
        ...


    @resize_callback.setter
    def resize_callback(self, value):
        ...


    @property
    def retrieve_framebuffer(self) -> bool:
        """
        Whether to activate the framebuffer retrieval.
        If set to true, the framebuffer field will be
        populated. This has a performance cost.
        
        """
        ...


    @retrieve_framebuffer.setter
    def retrieve_framebuffer(self, value : bool):
        ...


    @property
    def scale(self) -> float:
        """
        Multiplicative scale that, multiplied by
        the value of dpi, is used to scale
        automatically all items.

        Defaults to 1.
        
        """
        ...


    @scale.setter
    def scale(self, value : float):
        ...


    @property
    def shown(self) -> bool:
        """
        Whether the viewport window has been created by the
        operating system.
        
        """
        ...


    @property
    def small_icon(self) -> str:
        ...


    @small_icon.setter
    def small_icon(self, value : str):
        ...


    @property
    def theme(self):
        """
        Writable attribute: global theme
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def title(self) -> str:
        ...


    @title.setter
    def title(self, value : str):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def vsync(self) -> bool:
        ...


    @vsync.setter
    def vsync(self, value : bool):
        ...


    @property
    def wait_for_input(self) -> bool:
        """
        Writable attribute: When the app doesn't need to be
        refreshed, one can save power comsumption by not
        rendering. wait_for_input will pause rendering until
        a mouse or keyboard event is received.
        wake() can also be used to restart rendering
        for one frame.
        
        """
        ...


    @wait_for_input.setter
    def wait_for_input(self, value : bool):
        ...


    @property
    def width(self) -> int:
        ...


    @width.setter
    def width(self, value : int):
        ...


    @property
    def x_pos(self) -> int:
        ...


    @x_pos.setter
    def x_pos(self, value : int):
        ...


    @property
    def y_pos(self) -> int:
        ...


    @y_pos.setter
    def y_pos(self, value : int):
        ...


class ViewportDrawList(drawingItem):
    """
    A drawing item that renders its children on the viewport's background or foreground.

    This is typically used to draw items that should always be visible,
    regardless of the current window or plot being displayed.

    Attributes:
        front (bool): When True, renders drawings in front of all items. When False, renders behind.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[drawingItem] = [], front : bool = True, next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        front: Display the drawings in front of all items (rather than behind)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[drawingItem] = [], front : bool = True, next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        front: Display the drawings in front of all items (rather than behind)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ViewportDrawList:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def front(self) -> bool:
        """Writable attribute: Display the drawings in front of all items (rather than behind)
        """
        ...


    @front.setter
    def front(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Window(uiItem):
    """
    Represents a window in the UI with various configurable properties.

    Attributes:
    - no_title_bar: Boolean indicating if the title bar should be hidden.
    - no_resize: Boolean indicating if resizing should be disabled.
    - no_move: Boolean indicating if moving should be disabled.
    - no_scrollbar: Boolean indicating if the scrollbar should be hidden.
    - no_scroll_with_mouse: Boolean indicating if scrolling with the mouse should be disabled.
    - no_collapse: Boolean indicating if collapsing should be disabled.
    - autosize: Boolean indicating if the window should autosize.
    - no_background: Boolean indicating if the background should be hidden.
    - no_saved_settings: Boolean indicating if saved settings should be disabled.
    - no_mouse_inputs: Boolean indicating if mouse inputs should be disabled.
    - no_keyboard_inputs: Boolean indicating if keyboard inputs should be disabled.
    - menubar: Boolean indicating if the menubar should be shown.
    - horizontal_scrollbar: Boolean indicating if the horizontal scrollbar should be shown.
    - no_focus_on_appearing: Boolean indicating if focus on appearing should be disabled.
    - no_bring_to_front_on_focus: Boolean indicating if bringing to front on focus should be disabled.
    - always_show_vertical_scrollvar: Boolean indicating if the vertical scrollbar should always be shown.
    - always_show_horizontal_scrollvar: Boolean indicating if the horizontal scrollbar should always be shown.
    - unsaved_document: Boolean indicating if the document is unsaved.
    - disallow_docking: Boolean indicating if docking should be disallowed.
    - no_open_over_existing_popup: Boolean indicating if opening over existing popup should be disabled.
    - modal: Boolean indicating if the window is modal.
    - popup: Boolean indicating if the window is a popup.
    - has_close_button: Boolean indicating if the close button should be shown.
    - collapsed: Boolean indicating if the window is collapsed.
    - on_close: Callback function for the close event.
    - primary: Boolean indicating if the window is primary.
    - min_size: Minimum size of the window.
    - max_size: Maximum size of the window.
    
    """
    def __init__(self, context : Context, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, attach : Any = ..., autosize : bool = False, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem, MenuBar] = [], collapsed : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], has_close_button : bool = True, height : float = 0.0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", max_size : Sequence[float] | tuple[float, float] | Coord = (30000.0, 30000.0), menubar : bool = False, min_size : Sequence[float] | tuple[float, float] | Coord = (100.0, 100.0), modal : bool = False, next_sibling : baseItem | None = None, no_background : bool = False, no_bring_to_front_on_focus : bool = False, no_collapse : bool = False, no_focus_on_appearing : bool = False, no_keyboard_inputs : bool = False, no_mouse_inputs : bool = False, no_move : bool = False, no_newline : bool = False, no_open_over_existing_popup : bool = True, no_resize : bool = False, no_saved_settings : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, no_title_bar : bool = False, on_close : Any = ..., on_drop : Any = ..., parent : Viewport | None = None, popup : bool = False, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, primary : bool = False, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., unsaved_document : bool = False, user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        attach: Whether to attach the item to a parent. Default is None (auto)
        autosize: Writable attribute to tell the window should
               automatically resize to fit its content
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        collapsed: Writable attribute to collapse (~minimize) or uncollapse the window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        has_close_button: Writable attribute to indicate the window has a close button.
            Has effect only for normal and modal windows.
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_size: Writable attribute to indicate the maximum window size
        menubar: Writable attribute to indicate whether the window has a menu bar.
        min_size: Writable attribute to indicate the minimum window size
        modal: Writable attribute to indicate the window is a modal window.
            Modal windows are similar to popup windows, but they have a close
            button and are not closed by clicking outside.
            Clicking has no effect of items outside the modal window until it is closed.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_background: Writable attribute to disable drawing background
            color and outside border
        no_bring_to_front_on_focus: Writable attribute to indicate when the window takes focus (click on it, etc)
            it shouldn't be shown in front of other windows
        no_collapse: Writable attribute to disable user collapsing window by double-clicking on it
        no_focus_on_appearing: Writable attribute to indicate when the windows moves from
            an un-shown to a shown item shouldn't be made automatically
            focused
        no_keyboard_inputs: Writable attribute to disable keyboard manipulation (scroll).
            The window will not take focus of the keyboard.
            Does not affect items inside the window.
        no_mouse_inputs: Writable attribute to disable mouse input event catching of the window.
            Events such as clicked, hovering, etc will be passed to items behind the
            window.
        no_move: Writable attribute the window to be move with interactions
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_open_over_existing_popup: Writable attribute for modal and popup windows to prevent them from
            showing if there is already an existing popup/modal window
        no_resize: Writable attribute to block resizing
        no_saved_settings: Writable attribute to never load/save settings in .ini file
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: Writable attribute to indicate the mouse wheel
               should have no effect on scrolling of this window
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        no_title_bar: Writable attribute to disable the title-bar
        on_close: Callback to call when the window is closed.
            Note closing the window does not destroy or unattach the item.
            Instead it is switched to a show=False state.
        on_drop: Callback to call when the window receives a system
            drag&drop operation.
            The callback takes as input (sender, target, data),
            where sender and target are always the viewport in
            this context. data is a tuple of two elements.
            The first one is 0 (for text) or 1 (for file) depending on the
            type of dropped data, and the second is a list of
            strings corresponding to the dropped content.
        parent: parent of the item in the rendering tree.
        popup: Writable attribute to indicate the window is a popup window.
            Popup windows are centered (unless a pos is set), do not have a
            close button, and are closed when they lose focus (clicking outside the
            window).
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        primary: Indicate if the window is the primary window.
            There is maximum one primary window. The primary window covers the whole
            viewport and can be used to draw on the background.
            It is equivalent to setting:
            no_bring_to_front_on_focus
            no_saved_settings
            no_resize
            no_collapse
            no_title_bar
            and running item.focused = True on all the other windows
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        unsaved_document: Writable attribute to display a dot next to the title, as if the window
            contains unsaved changes.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, attach : Any = ..., autosize : bool = False, before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem, MenuBar] = [], collapsed : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], has_close_button : bool = True, height : float = 0.0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", max_size : Sequence[float] | tuple[float, float] | Coord = (30000.0, 30000.0), menubar : bool = False, min_size : Sequence[float] | tuple[float, float] | Coord = (100.0, 100.0), modal : bool = False, next_sibling : baseItem | None = None, no_background : bool = False, no_bring_to_front_on_focus : bool = False, no_collapse : bool = False, no_focus_on_appearing : bool = False, no_keyboard_inputs : bool = False, no_mouse_inputs : bool = False, no_move : bool = False, no_newline : bool = False, no_open_over_existing_popup : bool = True, no_resize : bool = False, no_saved_settings : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, no_title_bar : bool = False, on_close : Any = ..., on_drop : Any = ..., parent : Viewport | None = None, popup : bool = False, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, primary : bool = False, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., unsaved_document : bool = False, user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        attach: Whether to attach the item to a parent. Default is None (auto)
        autosize: Writable attribute to tell the window should
               automatically resize to fit its content
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        collapsed: Writable attribute to collapse (~minimize) or uncollapse the window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        has_close_button: Writable attribute to indicate the window has a close button.
            Has effect only for normal and modal windows.
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_size: Writable attribute to indicate the maximum window size
        menubar: Writable attribute to indicate whether the window has a menu bar.
        min_size: Writable attribute to indicate the minimum window size
        modal: Writable attribute to indicate the window is a modal window.
            Modal windows are similar to popup windows, but they have a close
            button and are not closed by clicking outside.
            Clicking has no effect of items outside the modal window until it is closed.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_background: Writable attribute to disable drawing background
            color and outside border
        no_bring_to_front_on_focus: Writable attribute to indicate when the window takes focus (click on it, etc)
            it shouldn't be shown in front of other windows
        no_collapse: Writable attribute to disable user collapsing window by double-clicking on it
        no_focus_on_appearing: Writable attribute to indicate when the windows moves from
            an un-shown to a shown item shouldn't be made automatically
            focused
        no_keyboard_inputs: Writable attribute to disable keyboard manipulation (scroll).
            The window will not take focus of the keyboard.
            Does not affect items inside the window.
        no_mouse_inputs: Writable attribute to disable mouse input event catching of the window.
            Events such as clicked, hovering, etc will be passed to items behind the
            window.
        no_move: Writable attribute the window to be move with interactions
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_open_over_existing_popup: Writable attribute for modal and popup windows to prevent them from
            showing if there is already an existing popup/modal window
        no_resize: Writable attribute to block resizing
        no_saved_settings: Writable attribute to never load/save settings in .ini file
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: Writable attribute to indicate the mouse wheel
               should have no effect on scrolling of this window
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        no_title_bar: Writable attribute to disable the title-bar
        on_close: Callback to call when the window is closed.
            Note closing the window does not destroy or unattach the item.
            Instead it is switched to a show=False state.
        on_drop: Callback to call when the window receives a system
            drag&drop operation.
            The callback takes as input (sender, target, data),
            where sender and target are always the viewport in
            this context. data is a tuple of two elements.
            The first one is 0 (for text) or 1 (for file) depending on the
            type of dropped data, and the second is a list of
            strings corresponding to the dropped content.
        parent: parent of the item in the rendering tree.
        popup: Writable attribute to indicate the window is a popup window.
            Popup windows are centered (unless a pos is set), do not have a
            close button, and are closed when they lose focus (clicking outside the
            window).
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        primary: Indicate if the window is the primary window.
            There is maximum one primary window. The primary window covers the whole
            viewport and can be used to draw on the background.
            It is equivalent to setting:
            no_bring_to_front_on_focus
            no_saved_settings
            no_resize
            no_collapse
            no_title_bar
            and running item.focused = True on all the other windows
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        unsaved_document: Writable attribute to display a dot next to the title, as if the window
            contains unsaved changes.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Window:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def always_show_horizontal_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a horizontal scrollbar
        even when the size does not require it (only if horizontal scrollbar
        are enabled)
        
        """
        ...


    @always_show_horizontal_scrollvar.setter
    def always_show_horizontal_scrollvar(self, value : bool):
        ...


    @property
    def always_show_vertical_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a vertical scrollbar
        even when the size does not require it
        
        """
        ...


    @always_show_vertical_scrollvar.setter
    def always_show_vertical_scrollvar(self, value : bool):
        ...


    @property
    def autosize(self) -> bool:
        """Writable attribute to tell the window should
           automatically resize to fit its content
        
        """
        ...


    @autosize.setter
    def autosize(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem, MenuBar]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem, MenuBar]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def collapsed(self) -> bool:
        """
        Writable attribute to collapse (~minimize) or uncollapse the window
        
        """
        ...


    @collapsed.setter
    def collapsed(self, value : bool):
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def has_close_button(self) -> bool:
        """
        Writable attribute to indicate the window has a close button.
        Has effect only for normal and modal windows.
        
        """
        ...


    @has_close_button.setter
    def has_close_button(self, value : bool):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def horizontal_scrollbar(self) -> bool:
        """
        Writable attribute to enable having an horizontal scrollbar
        
        """
        ...


    @horizontal_scrollbar.setter
    def horizontal_scrollbar(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def max_size(self) -> Coord:
        """
        Writable attribute to indicate the maximum window size
        
        """
        ...


    @max_size.setter
    def max_size(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def menubar(self) -> bool:
        """
        Writable attribute to indicate whether the window has a menu bar.

        There will be menubar if either the user has asked for it,
        or there is a menubar child.
        
        """
        ...


    @menubar.setter
    def menubar(self, value : bool):
        ...


    @property
    def min_size(self) -> Coord:
        """
        Writable attribute to indicate the minimum window size
        
        """
        ...


    @min_size.setter
    def min_size(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def modal(self) -> bool:
        """
        Writable attribute to indicate the window is a modal window.
        Modal windows are similar to popup windows, but they have a close
        button and are not closed by clicking outside.
        Clicking has no effect of items outside the modal window until it is closed.
        
        """
        ...


    @modal.setter
    def modal(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_background(self) -> bool:
        """
        Writable attribute to disable drawing background
        color and outside border
        
        """
        ...


    @no_background.setter
    def no_background(self, value : bool):
        ...


    @property
    def no_bring_to_front_on_focus(self) -> bool:
        """
        Writable attribute to indicate when the window takes focus (click on it, etc)
        it shouldn't be shown in front of other windows
        
        """
        ...


    @no_bring_to_front_on_focus.setter
    def no_bring_to_front_on_focus(self, value : bool):
        ...


    @property
    def no_collapse(self) -> bool:
        """Writable attribute to disable user collapsing window by double-clicking on it
        
        """
        ...


    @no_collapse.setter
    def no_collapse(self, value : bool):
        ...


    @property
    def no_focus_on_appearing(self) -> bool:
        """
        Writable attribute to indicate when the windows moves from
        an un-shown to a shown item shouldn't be made automatically
        focused
        
        """
        ...


    @no_focus_on_appearing.setter
    def no_focus_on_appearing(self, value : bool):
        ...


    @property
    def no_keyboard_inputs(self) -> bool:
        """
        Writable attribute to disable keyboard manipulation (scroll).
        The window will not take focus of the keyboard.
        Does not affect items inside the window.
        
        """
        ...


    @no_keyboard_inputs.setter
    def no_keyboard_inputs(self, value : bool):
        ...


    @property
    def no_mouse_inputs(self) -> bool:
        """
        Writable attribute to disable mouse input event catching of the window.
        Events such as clicked, hovering, etc will be passed to items behind the
        window.
        
        """
        ...


    @no_mouse_inputs.setter
    def no_mouse_inputs(self, value : bool):
        ...


    @property
    def no_move(self) -> bool:
        """Writable attribute the window to be move with interactions
        """
        ...


    @no_move.setter
    def no_move(self, value : bool):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_open_over_existing_popup(self) -> bool:
        """
        Writable attribute for modal and popup windows to prevent them from
        showing if there is already an existing popup/modal window
        
        """
        ...


    @no_open_over_existing_popup.setter
    def no_open_over_existing_popup(self, value : bool):
        ...


    @property
    def no_resize(self) -> bool:
        """Writable attribute to block resizing
        """
        ...


    @no_resize.setter
    def no_resize(self, value : bool):
        ...


    @property
    def no_saved_settings(self) -> bool:
        """
        Writable attribute to never load/save settings in .ini file
        
        """
        ...


    @no_saved_settings.setter
    def no_saved_settings(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_scroll_with_mouse(self) -> bool:
        """Writable attribute to indicate the mouse wheel
           should have no effect on scrolling of this window
        
        """
        ...


    @no_scroll_with_mouse.setter
    def no_scroll_with_mouse(self, value : bool):
        ...


    @property
    def no_scrollbar(self) -> bool:
        """Writable attribute to indicate the window should have no scrollbar
           Does not disable scrolling via mouse or keyboard
        
        """
        ...


    @no_scrollbar.setter
    def no_scrollbar(self, value : bool):
        ...


    @property
    def no_title_bar(self) -> bool:
        """Writable attribute to disable the title-bar
        """
        ...


    @no_title_bar.setter
    def no_title_bar(self, value : bool):
        ...


    @property
    def on_close(self):
        """
        Callback to call when the window is closed.
        Note closing the window does not destroy or unattach the item.
        Instead it is switched to a show=False state.
        
        """
        ...


    @on_close.setter
    def on_close(self, value):
        ...


    @property
    def on_drop(self):
        """
        Callback to call when the window receives a system
        drag&drop operation.
        The callback takes as input (sender, target, data),
        where sender and target are always the viewport in
        this context. data is a tuple of two elements.
        The first one is 0 (for text) or 1 (for file) depending on the
        type of dropped data, and the second is a list of
        strings corresponding to the dropped content.
        
        """
        ...


    @on_drop.setter
    def on_drop(self, value):
        ...


    @property
    def parent(self) -> Viewport | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Viewport | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def popup(self) -> bool:
        """
        Writable attribute to indicate the window is a popup window.
        Popup windows are centered (unless a pos is set), do not have a
        close button, and are closed when they lose focus (clicking outside the
        window).
        
        """
        ...


    @popup.setter
    def popup(self, value : bool):
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def primary(self) -> bool:
        """
        Writable attribute: Indicate if the window is the primary window.
        There is maximum one primary window. The primary window covers the whole
        viewport and can be used to draw on the background.
        It is equivalent to setting:
        no_bring_to_front_on_focus
        no_saved_settings
        no_resize
        no_collapse
        no_title_bar
        and running item.focused = True on all the other windows
        
        """
        ...


    @primary.setter
    def primary(self, value : bool):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def unsaved_document(self) -> bool:
        """
        Writable attribute to display a dot next to the title, as if the window
        contains unsaved changes.
        
        """
        ...


    @unsaved_document.setter
    def unsaved_document(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class WindowHorizontalLayout(WindowLayout):
    """
    Layout to organize windows horizontally.

    Similar to HorizontalLayout but handles window positioning.
    Windows will be arranged left-to-right with customizable alignment
    and spacing.

    Attributes:
    ----------
    alignment_mode : Alignment
        Horizontal alignment of windows.
        LEFT: Windows start from left edge
        RIGHT: Windows start from right edge  
        CENTER: Windows are centered
        JUSTIFIED: Space is distributed evenly between windows
        MANUAL: Windows positioned at specified positions
    positions : list[float]
        When in MANUAL mode, the x positions for each window
    
    """
    def __init__(self, context : Context, alignment_mode : Alignment = 0, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), positions : list = [], previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        alignment_mode: Horizontal alignment mode of the windows.
            LEFT: windows are appended from the left
            RIGHT: windows are appended from the right
            CENTER: windows are centered
            JUSTIFIED: spacing is organized such
            that windows start at the left and end
            at the right.
            MANUAL: windows are positionned at the requested
            positions
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the x position starting
            from the top left of this item at which to
            place the windows.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, alignment_mode : Alignment = 0, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), positions : list = [], previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        alignment_mode: Horizontal alignment mode of the windows.
            LEFT: windows are appended from the left
            RIGHT: windows are appended from the right
            CENTER: windows are centered
            JUSTIFIED: spacing is organized such
            that windows start at the left and end
            at the right.
            MANUAL: windows are positionned at the requested
            positions
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the x position starting
            from the top left of this item at which to
            place the windows.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        ...


    def __enter__(self) -> WindowHorizontalLayout:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def alignment_mode(self) -> Alignment:
        """
        Horizontal alignment mode of the windows.
        LEFT: windows are appended from the left
        RIGHT: windows are appended from the right
        CENTER: windows are centered
        JUSTIFIED: spacing is organized such
        that windows start at the left and end
        at the right.
        MANUAL: windows are positionned at the requested
        positions

        The default is LEFT.
        
        """
        ...


    @alignment_mode.setter
    def alignment_mode(self, value : Alignment):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def positions(self) -> list:
        """
        When in MANUAL mode, the x position starting
        from the top left of this item at which to
        place the windows.

        If the positions are between 0 and 1, they are
        interpreted as percentages relative to the
        available viewport width.
        If the positions are negatives, they are interpreted
        as in reference to the right of the viewport rather
        than the left.

        Setting this field sets the alignment mode to
        MANUAL.
        
        """
        ...


    @positions.setter
    def positions(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class WindowLayout(uiItem):
    """
    Same as Layout, but for windows.
    Unlike Layout, WindowLayout doesn't
    have any accessible state, except
    for the position and rect size.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        ...


    def __enter__(self) -> WindowLayout:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class WindowVerticalLayout(WindowLayout):
    """
    Layout to organize windows vertically.

    Similar to VerticalLayout but handles window positioning.
    Windows will be arranged top-to-bottom with customizable alignment
    and spacing.

    Attributes:
    ----------
    alignment_mode : Alignment
        Vertical alignment of windows.
        TOP: Windows start from top edge
        BOTTOM: Windows start from bottom edge  
        CENTER: Windows are centered
        JUSTIFIED: Space is distributed evenly between windows
        MANUAL: Windows positioned at specified positions
    positions : list[float]
        When in MANUAL mode, the y positions for each window.
        Values between 0-1 are interpreted as percentages.
        Negative values reference from bottom edge.
    
    """
    def __init__(self, context : Context, alignment_mode : Alignment = 0, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), positions : list = [], previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        alignment_mode: Vertical alignment mode of the windows.
            TOP: windows are appended from the top
            BOTTOM: windows are appended from the bottom 
            CENTER: windows are centered
            JUSTIFIED: spacing is organized such 
            that windows start at the TOP and end
            at the BOTTOM.
            MANUAL: windows are positionned at the requested
            positions
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the y position starting
            from the top left of this item at which to
            place the windows.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, alignment_mode : Alignment = 0, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), positions : list = [], previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        alignment_mode: Vertical alignment mode of the windows.
            TOP: windows are appended from the top
            BOTTOM: windows are appended from the bottom 
            CENTER: windows are centered
            JUSTIFIED: spacing is organized such 
            that windows start at the TOP and end
            at the BOTTOM.
            MANUAL: windows are positionned at the requested
            positions
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the y position starting
            from the top left of this item at which to
            place the windows.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        ...


    def __enter__(self) -> WindowVerticalLayout:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def alignment_mode(self) -> Alignment:
        """
        Vertical alignment mode of the windows.
        TOP: windows are appended from the top
        BOTTOM: windows are appended from the bottom 
        CENTER: windows are centered
        JUSTIFIED: spacing is organized such 
        that windows start at the TOP and end
        at the BOTTOM.
        MANUAL: windows are positionned at the requested
        positions

        FOR TOP/BOTTOM/CENTER, ItemSpacing's style can
        be used to control spacing between the windows.
        Default is TOP.
        
        """
        ...


    @alignment_mode.setter
    def alignment_mode(self, value : Alignment):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def content_pos(self) -> Coord:
        """
        Readable attribute indicating the top left starting
        position of the item's content in viewport coordinates.

        Only available for items with a content area.
        The size of the content area is available with
        content_region_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> Coord:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def positions(self) -> list:
        """
        When in MANUAL mode, the y position starting
        from the top left of this item at which to
        place the windows.

        If the positions are between 0 and 1, they are
        interpreted as percentages relative to the
        size of the Layout height.
        If the positions are negatives, they are interpreted
        as in reference to the bottom of the layout rather
        than the top. Items are still top aligned to
        the target position though.

        Setting this field sets the alignment mode to
        MANUAL.
        
        """
        ...


    @positions.setter
    def positions(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...


class baseFont(baseItem):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseFont:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class baseHandler(baseItem):
    """
    Base class for UI input event handlers.

    Attributes:
    - enabled: Boolean indicating if the handler is enabled.
    - callback: Callback function for the handler.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseHandler:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class baseItem(object):
    """
Base class for all items (except shared values).

    To be rendered, an item must be in the child tree of the viewport (context.viewport).

    Parent-Child Relationships:
    -------------------------
    The parent of an item can be set in several ways:
    1. Using the parent attribute: `item.parent = target_item`
    2. Passing `parent=target_item` during item creation 
    3. Using the context manager ('with' statement) - if no parent is explicitly set, the last item in the 'with' block becomes the parent
    4. Setting previous_sibling or next_sibling attributes to insert the item between existing siblings

    Tree Structure:
    --------------
    - Items are rendered in order from first child to last child
    - New items are inserted last by default unless previous_sibling/next_sibling is used
    - Items can be manually detached by setting parent = None
    - Most items have restrictions on what parents/children they can have
    - Some items can have multiple incompatible child lists that are concatenated when reading item.children

    Special Cases:
    -------------
    Some items cannot be children in the rendering tree:
    - PlaceHolderParent: Can be parent to any item but cannot be in rendering tree
    - Textures, themes, colormaps and fonts: Cannot be children but can be bound to items

    Attributes:
        context (Context): The context this item belongs to
        user_data (Any): Custom user data that can be attached to the item
        uuid (int): Unique identifier for this item
        parent (baseItem): Parent item in the rendering tree
        previous_sibling (baseItem): Previous sibling in parent's child list
        next_sibling (baseItem): Next sibling in parent's child list
        children (List[baseItem]): List of child items in rendering order
        children_types (ChildType): Bitmask of allowed child types
        item_type (ChildType): Type of this item as a child

    The parent, previous_sibling and next_sibling relationships form a doubly-linked tree structure that determines rendering order and hierarchy.
    The children attribute provides access to all child items.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseItem:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class baseTheme(baseItem):
    """
    Base theme element. Contains a set of theme elements to apply for a given category (color, style)/(imgui/implot/imnode).

    Attributes:
    - enabled: Boolean indicating if the theme is enabled.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseTheme:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class baseThemeColor(baseTheme):
    """
    Base class for theme colors that provides common color-related functionality.
    
    This class provides the core implementation for managing color themes in different 
    contexts (ImGui/ImPlot/ImNodes). Color themes allow setting colors for various UI 
    elements using different color formats:
    - unsigned int (encodes rgba little-endian)
    - (r, g, b, a) with values as integers [0-255]  
    - (r, g, b, a) with values as normalized floats [0.0-1.0]
    - If alpha is omitted, it defaults to 255

    The class implements common dictionary-style access to colors through string names
    or numeric indices.
    
    """
    def __init__(self, context : Context, attach : Color| None = None, before : Color| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Color| None = None):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Color| None = None, before : Color| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : Color| None = None):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseThemeColor:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self) -> Color| None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : Color| None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class baseThemeStyle(baseTheme):
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : tuple[float, float] | None = None):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, user_data : tuple[float, float] | None = None):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseThemeStyle:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_rounding(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables rounding (after scaling) to the
        closest integer the parameters. The rounding is only
        applied to parameters which impact item positioning
        in a way that would prevent a pixel perfect result.
        
        """
        ...


    @no_rounding.setter
    def no_rounding(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this theme
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def user_data(self) -> tuple[float, float] | None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : tuple[float, float] | None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class drawingItem(baseItem):
    """
    A simple item with no UI state that inherits from the drawing area of its parent.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., children : None  = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., children : None  = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> drawingItem:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElement(baseItem):
    """
    Base class for plot children.

    Attributes:
    - show: Boolean indicating if the plot element should be shown.
    - axes: Axes for the plot element.
    - label: Label for the plot element.
    - theme: Theme for the plot element.
    
    """
    def __init__(self, context : Context, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : None  = [], label : str = "", next_sibling : baseItem | None = None, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        label: label assigned to the element
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : None  = [], label : str = "", next_sibling : baseItem | None = None, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        label: label assigned to the element
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElement:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElementWithLegend(plotElement):
    """
    Base class for plot children with a legend.

    Children of plot elements are rendered on a legend
    popup entry that gets shown on a right click (by default).
    
    """
    def __init__(self, context : Context, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElementWithLegend:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElementX(plotElementWithLegend):
    def __init__(self, context : Context, X : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElementX:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElementXY(plotElementWithLegend):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElementXY:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElementXYY(plotElementWithLegend):
    def __init__(self, context : Context, X : ndarray = [0.], Y1 : ndarray = [0.], Y2 : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y1 : ndarray = [0.], Y2 : ndarray = [0.], attach : Any = ..., axes : tuple = (0, 3), before : Any = ..., children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        attach: Whether to attach the item to a parent. Default is None (auto)
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        before: Attach the item just before the target item. Default is None (disabled)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElementXYY:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y1(self) -> ndarray:
        ...


    @Y1.setter
    def Y1(self, value : ndarray):
        ...


    @property
    def Y2(self) -> ndarray:
        ...


    @Y2.setter
    def Y2(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class uiItem(baseItem):
    """
Base class for UI items with various properties and states.

    Core class for items that can be interacted with and displayed in the UI. Handles positioning,
    state tracking, themes, callbacks, and layout management.

    State Properties:
    ---------------
    - active: Whether the item is currently active (pressed, selected, etc.)
    - activated: Whether the item just became active this frame  
    - clicked: Whether any mouse button was clicked on the item
    - double_clicked: Whether any mouse button was double-clicked
    - deactivated: Whether the item just became inactive
    - deactivated_after_edited: Whether the item was edited and then deactivated
    - edited: Whether the item's value was modified
    - focused: Whether the item has keyboard focus
    - hovered: Whether the mouse is over the item
    - resized: Whether the item's size changed
    - toggled: Whether a menu/tree node was opened/closed
    - visible: Whether the item is currently rendered

    Appearance Properties:
    -------------------
    - enabled: Whether the item is interactive or greyed out
    - font: Font used for text rendering
    - theme: Visual theme/style settings
    - show: Whether the item should be drawn
    - no_scaling: Disable DPI/viewport scaling
    
    Layout Properties:
    ----------------
    - pos_to_viewport: Position relative to viewport top-left
    - pos_to_window: Position relative to containing window 
    - pos_to_parent: Position relative to parent item
    - pos_to_default: Position relative to default layout flow
    - rect_size: Current size in pixels including padding
    - content_region_avail: Available content area within item for children
    - pos_policy: How the item should be positioned
    - height/width: Requested size of the item
    - indent: Left indentation amount
    - no_newline: Don't advance position after item

    Value Properties:
    ---------------
    - value: Main value stored by the item 
    - shareable_value: Allows sharing values between items
    - label: Text label shown with the item

    Event Properties:  
    ---------------
    - handlers: Event handlers attached to the item
    - callbacks: Functions called when value changes

    Positioning Rules:
    ----------------
    Items use a combination of absolute and relative positioning:
    - Default flow places items vertically with automatic width
    - pos_policy controls how position attributes are enforced
    - Positions can be relative to viewport, window, parent or flow
    - Size can be fixed, automatic, or stretch to fill space
    - indent and no_newline provide fine-grained layout control

    All attributes are protected by mutexes to enable thread-safe access.
    
    """
    def __init__(self, context : Context, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """

        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, attach : Any = ..., before : Any = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : tuple[Positioning, Positioning] = ..., pos_to_default : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_parent : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_viewport : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), pos_to_window : Sequence[float] | tuple[float, float] | Coord = (0.0, 0.0), previous_sibling : baseItem | None = None, scaling_factor : float = 1.0, shareable_value : SharedValue = ..., show : bool = True, theme : Any = ..., user_data : Any = ..., value : Any = ..., width : float = 0.0):
        """
        attach: Whether to attach the item to a parent. Default is None (auto)
        before: Attach the item just before the target item. Default is None (disabled)
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scaling_factor: scaling factor
            that multiplies the global viewport scaling and
            applies to this item and its children.
            The global scaling (thus this parameter as well)
            impacts themes, sizes and fonts. Themes and fonts
            that were applied by a parent are unaffected.
            Defaults to 1.0.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> uiItem:
        ...


    def __exit__(self, exc_type : Any, exc_value : Any, traceback : Any) -> bool:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def children_types(self) -> ChildType:
        """Returns which types of children can be attached to this item
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> float:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def item_type(self) -> ChildType:
        """Returns which type of child this item is
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> bool:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> tuple[Positioning, Positioning]:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, while
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : tuple[Positioning, Positioning]):
        ...


    @property
    def pos_to_default(self) -> Coord:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_parent(self) -> Coord:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_viewport(self) -> Coord:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def pos_to_window(self) -> Coord:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : Sequence[float] | tuple[float, float] | Coord):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> Coord:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scaling_factor(self) -> float:
        """
        Writable attribute: scaling factor
        that multiplies the global viewport scaling and
        applies to this item and its children.
        The global scaling (thus this parameter as well)
        impacts themes, sizes and fonts. Themes and fonts
        that were applied by a parent are unaffected.
        Defaults to 1.0.
        
        """
        ...


    @scaling_factor.setter
    def scaling_factor(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> float:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : float):
        ...

