from typing import Any
from enum import IntEnum
from typing import Protocol

class DCGCallable0(Protocol):
    def __call__(self, **kwargs) -> None:
        ...

class DCGCallable1(Protocol):
    def __call__(self, sender : baseHandler | uiItem, **kwargs) -> None:
        ...

class DCGCallable2(Protocol):
    def __call__(self,
                 sender : baseHandler | uiItem,
                 target : baseItem,
                 **kwargs) -> None:
        ...

class DCGCallable3(Protocol):
    def __call__(self,
                 sender : baseHandler | uiItem,
                 target : baseItem,
                 value : Any,
                 **kwargs) -> None:
        ...

DCGCallable = DCGCallable0 | DCGCallable1 | DCGCallable2 | DCGCallable3

class constants:
    mvGraphicsBackend_D3D11 = ...
    mvGraphicsBackend_D3D12 = ...
    mvGraphicsBackend_VULKAN = ...
    mvGraphicsBackend_METAL = ...
    mvGraphicsBackend_OPENGL = ...
    mvMouseButton_Left = ...
    mvMouseButton_Right = ...
    mvMouseButton_Middle = ...
    mvMouseButton_X1 = ...
    mvMouseButton_X2 = ...
    mvKey_ModDisabled = ...
    mvKey_None = ...
    mvKey_0 = ...
    mvKey_1 = ...
    mvKey_2 = ...
    mvKey_3 = ...
    mvKey_4 = ...
    mvKey_5 = ...
    mvKey_6 = ...
    mvKey_7 = ...
    mvKey_8 = ...
    mvKey_9 = ...
    mvKey_A = ...
    mvKey_B = ...
    mvKey_C = ...
    mvKey_D = ...
    mvKey_E = ...
    mvKey_F = ...
    mvKey_G = ...
    mvKey_H = ...
    mvKey_I = ...
    mvKey_J = ...
    mvKey_K = ...
    mvKey_L = ...
    mvKey_M = ...
    mvKey_N = ...
    mvKey_O = ...
    mvKey_P = ...
    mvKey_Q = ...
    mvKey_R = ...
    mvKey_S = ...
    mvKey_T = ...
    mvKey_U = ...
    mvKey_V = ...
    mvKey_W = ...
    mvKey_X = ...
    mvKey_Y = ...
    mvKey_Z = ...
    mvKey_Back = ...
    mvKey_Tab = ...
    mvKey_Return = ...
    mvKey_LShift = ...
    mvKey_RShift = ...
    mvKey_LControl = ...
    mvKey_RControl = ...
    mvKey_LAlt = ...
    mvKey_RAlt = ...
    mvKey_Pause = ...
    mvKey_CapsLock = ...
    mvKey_Escape = ...
    mvKey_Spacebar = ...
    mvKey_End = ...
    mvKey_Home = ...
    mvKey_Left = ...
    mvKey_Up = ...
    mvKey_Right = ...
    mvKey_Down = ...
    mvKey_Print = ...
    mvKey_Insert = ...
    mvKey_Delete = ...
    mvKey_NumPad0 = ...
    mvKey_NumPad1 = ...
    mvKey_NumPad2 = ...
    mvKey_NumPad3 = ...
    mvKey_NumPad4 = ...
    mvKey_NumPad5 = ...
    mvKey_NumPad6 = ...
    mvKey_NumPad7 = ...
    mvKey_NumPad8 = ...
    mvKey_NumPad9 = ...
    mvKey_Subtract = ...
    mvKey_Decimal = ...
    mvKey_Divide = ...
    mvKey_Multiply = ...
    mvKey_Add = ...
    mvKey_F1 = ...
    mvKey_F2 = ...
    mvKey_F3 = ...
    mvKey_F4 = ...
    mvKey_F5 = ...
    mvKey_F6 = ...
    mvKey_F7 = ...
    mvKey_F8 = ...
    mvKey_F9 = ...
    mvKey_F10 = ...
    mvKey_F11 = ...
    mvKey_F12 = ...
    mvKey_F13 = ...
    mvKey_F14 = ...
    mvKey_F15 = ...
    mvKey_F16 = ...
    mvKey_F17 = ...
    mvKey_F18 = ...
    mvKey_F19 = ...
    mvKey_F20 = ...
    mvKey_F21 = ...
    mvKey_F22 = ...
    mvKey_F23 = ...
    mvKey_F24 = ...
    mvKey_NumLock = ...
    mvKey_ScrollLock = ...
    mvKey_Period = ...
    mvKey_Slash = ...
    mvKey_Backslash = ...
    mvKey_Open_Brace = ...
    mvKey_Close_Brace = ...
    mvKey_Browser_Back = ...
    mvKey_Browser_Forward = ...
    mvKey_Comma = ...
    mvKey_Minus = ...
    mvKey_Menu = ...
    mvKey_ModSuper = ...
    mvKey_ModShift = ...
    mvKey_ModAlt = ...
    mvKey_ModCtrl = ...
    mvAll = ...
    mvTool_About = ...
    mvTool_Debug = ...
    mvTool_Doc = ...
    mvTool_ItemRegistry = ...
    mvTool_Metrics = ...
    mvTool_Stack = ...
    mvTool_Style = ...
    mvTool_Font = ...
    mvFontAtlas = ...
    mvAppUUID = ...
    mvInvalidUUID = ...
    mvDir_None = ...
    mvDir_Left = ...
    mvDir_Right = ...
    mvDir_Up = ...
    mvDir_Down = ...
    mvComboHeight_Small = ...
    mvComboHeight_Regular = ...
    mvComboHeight_Large = ...
    mvComboHeight_Largest = ...
    mvPlatform_Windows = ...
    mvPlatform_Apple = ...
    mvPlatform_Linux = ...
    mvColorEdit_AlphaPreviewNone = ...
    mvColorEdit_AlphaPreview = ...
    mvColorEdit_AlphaPreviewHalf = ...
    mvColorEdit_uint8 = ...
    mvColorEdit_float = ...
    mvColorEdit_rgb = ...
    mvColorEdit_hsv = ...
    mvColorEdit_hex = ...
    mvColorEdit_input_rgb = ...
    mvColorEdit_input_hsv = ...
    mvPlotColormap_Default = ...
    mvPlotColormap_Deep = ...
    mvPlotColormap_Dark = ...
    mvPlotColormap_Pastel = ...
    mvPlotColormap_Paired = ...
    mvPlotColormap_Viridis = ...
    mvPlotColormap_Plasma = ...
    mvPlotColormap_Hot = ...
    mvPlotColormap_Cool = ...
    mvPlotColormap_Pink = ...
    mvPlotColormap_Jet = ...
    mvPlotColormap_Twilight = ...
    mvPlotColormap_RdBu = ...
    mvPlotColormap_BrBG = ...
    mvPlotColormap_PiYG = ...
    mvPlotColormap_Spectral = ...
    mvPlotColormap_Greys = ...
    mvColorPicker_bar = ...
    mvColorPicker_wheel = ...
    mvTabOrder_Reorderable = ...
    mvTabOrder_Fixed = ...
    mvTabOrder_Leading = ...
    mvTabOrder_Trailing = ...
    mvTimeUnit_Us = ...
    mvTimeUnit_Ms = ...
    mvTimeUnit_S = ...
    mvTimeUnit_Min = ...
    mvTimeUnit_Hr = ...
    mvTimeUnit_Day = ...
    mvTimeUnit_Mo = ...
    mvTimeUnit_Yr = ...
    mvDatePickerLevel_Day = ...
    mvDatePickerLevel_Month = ...
    mvDatePickerLevel_Year = ...
    mvCullMode_None = ...
    mvCullMode_Back = ...
    mvCullMode_Front = ...
    mvFontRangeHint_Default = ...
    mvFontRangeHint_Japanese = ...
    mvFontRangeHint_Korean = ...
    mvFontRangeHint_Chinese_Full = ...
    mvFontRangeHint_Chinese_Simplified_Common = ...
    mvFontRangeHint_Cyrillic = ...
    mvFontRangeHint_Thai = ...
    mvFontRangeHint_Vietnamese = ...
    mvNode_PinShape_Circle = ...
    mvNode_PinShape_CircleFilled = ...
    mvNode_PinShape_Triangle = ...
    mvNode_PinShape_TriangleFilled = ...
    mvNode_PinShape_Quad = ...
    mvNode_PinShape_QuadFilled = ...
    mvNode_Attr_Input = ...
    mvNode_Attr_Output = ...
    mvNode_Attr_Static = ...
    mvPlotBin_Sqrt = ...
    mvPlotBin_Sturges = ...
    mvPlotBin_Rice = ...
    mvPlotBin_Scott = ...
    mvXAxis = ...
    mvXAxis2 = ...
    mvXAxis3 = ...
    mvYAxis = ...
    mvYAxis2 = ...
    mvYAxis3 = ...
    mvPlotScale_Linear = ...
    mvPlotScale_Time = ...
    mvPlotScale_Log10 = ...
    mvPlotScale_SymLog = ...
    mvPlotMarker_None = ...
    mvPlotMarker_Circle = ...
    mvPlotMarker_Square = ...
    mvPlotMarker_Diamond = ...
    mvPlotMarker_Up = ...
    mvPlotMarker_Down = ...
    mvPlotMarker_Left = ...
    mvPlotMarker_Right = ...
    mvPlotMarker_Cross = ...
    mvPlotMarker_Plus = ...
    mvPlotMarker_Asterisk = ...
    mvPlot_Location_Center = ...
    mvPlot_Location_North = ...
    mvPlot_Location_South = ...
    mvPlot_Location_West = ...
    mvPlot_Location_East = ...
    mvPlot_Location_NorthWest = ...
    mvPlot_Location_NorthEast = ...
    mvPlot_Location_SouthWest = ...
    mvPlot_Location_SouthEast = ...
    mvNodeMiniMap_Location_BottomLeft = ...
    mvNodeMiniMap_Location_BottomRight = ...
    mvNodeMiniMap_Location_TopLeft = ...
    mvNodeMiniMap_Location_TopRight = ...
    mvTable_SizingFixedFit = ...
    mvTable_SizingFixedSame = ...
    mvTable_SizingStretchProp = ...
    mvTable_SizingStretchSame = ...
    mvFormat_Float_rgba = ...
    mvFormat_Float_rgb = ...
    mvThemeCat_Core = ...
    mvThemeCat_Plots = ...
    mvThemeCat_Nodes = ...
    mvThemeCol_Text = ...
    mvThemeCol_TextDisabled = ...
    mvThemeCol_WindowBg = ...
    mvThemeCol_ChildBg = ...
    mvThemeCol_Border = ...
    mvThemeCol_PopupBg = ...
    mvThemeCol_BorderShadow = ...
    mvThemeCol_FrameBg = ...
    mvThemeCol_FrameBgHovered = ...
    mvThemeCol_FrameBgActive = ...
    mvThemeCol_TitleBg = ...
    mvThemeCol_TitleBgActive = ...
    mvThemeCol_TitleBgCollapsed = ...
    mvThemeCol_MenuBarBg = ...
    mvThemeCol_ScrollbarBg = ...
    mvThemeCol_ScrollbarGrab = ...
    mvThemeCol_ScrollbarGrabHovered = ...
    mvThemeCol_ScrollbarGrabActive = ...
    mvThemeCol_CheckMark = ...
    mvThemeCol_SliderGrab = ...
    mvThemeCol_SliderGrabActive = ...
    mvThemeCol_Button = ...
    mvThemeCol_ButtonHovered = ...
    mvThemeCol_ButtonActive = ...
    mvThemeCol_Header = ...
    mvThemeCol_HeaderHovered = ...
    mvThemeCol_HeaderActive = ...
    mvThemeCol_Separator = ...
    mvThemeCol_SeparatorHovered = ...
    mvThemeCol_SeparatorActive = ...
    mvThemeCol_ResizeGrip = ...
    mvThemeCol_ResizeGripHovered = ...
    mvThemeCol_ResizeGripActive = ...
    mvThemeCol_Tab = ...
    mvThemeCol_TabHovered = ...
    mvThemeCol_TabActive = ...
    mvThemeCol_TabUnfocused = ...
    mvThemeCol_TabUnfocusedActive = ...
    mvThemeCol_PlotLines = ...
    mvThemeCol_PlotLinesHovered = ...
    mvThemeCol_PlotHistogram = ...
    mvThemeCol_PlotHistogramHovered = ...
    mvThemeCol_TableHeaderBg = ...
    mvThemeCol_TableBorderStrong = ...
    mvThemeCol_TableBorderLight = ...
    mvThemeCol_TableRowBg = ...
    mvThemeCol_TableRowBgAlt = ...
    mvThemeCol_TextSelectedBg = ...
    mvThemeCol_DragDropTarget = ...
    mvThemeCol_NavHighlight = ...
    mvThemeCol_NavWindowingHighlight = ...
    mvThemeCol_NavWindowingDimBg = ...
    mvThemeCol_ModalWindowDimBg = ...
    mvPlotCol_Line = ...
    mvPlotCol_Fill = ...
    mvPlotCol_MarkerOutline = ...
    mvPlotCol_MarkerFill = ...
    mvPlotCol_ErrorBar = ...
    mvPlotCol_FrameBg = ...
    mvPlotCol_PlotBg = ...
    mvPlotCol_PlotBorder = ...
    mvPlotCol_LegendBg = ...
    mvPlotCol_LegendBorder = ...
    mvPlotCol_LegendText = ...
    mvPlotCol_TitleText = ...
    mvPlotCol_InlayText = ...
    mvPlotCol_AxisBg = ...
    mvPlotCol_AxisBgActive = ...
    mvPlotCol_AxisBgHovered = ...
    mvPlotCol_AxisGrid = ...
    mvPlotCol_AxisText = ...
    mvPlotCol_Selection = ...
    mvPlotCol_Crosshairs = ...
    mvNodeCol_NodeBackground = ...
    mvNodeCol_NodeBackgroundHovered = ...
    mvNodeCol_NodeBackgroundSelected = ...
    mvNodeCol_NodeOutline = ...
    mvNodeCol_TitleBar = ...
    mvNodeCol_TitleBarHovered = ...
    mvNodeCol_TitleBarSelected = ...
    mvNodeCol_Link = ...
    mvNodeCol_LinkHovered = ...
    mvNodeCol_LinkSelected = ...
    mvNodeCol_Pin = ...
    mvNodeCol_PinHovered = ...
    mvNodeCol_BoxSelector = ...
    mvNodeCol_BoxSelectorOutline = ...
    mvNodeCol_GridBackground = ...
    mvNodeCol_GridLine = ...
    mvNodesCol_GridLinePrimary = ...
    mvNodesCol_MiniMapBackground = ...
    mvNodesCol_MiniMapBackgroundHovered = ...
    mvNodesCol_MiniMapOutline = ...
    mvNodesCol_MiniMapOutlineHovered = ...
    mvNodesCol_MiniMapNodeBackground = ...
    mvNodesCol_MiniMapNodeBackgroundHovered = ...
    mvNodesCol_MiniMapNodeBackgroundSelected = ...
    mvNodesCol_MiniMapNodeOutline = ...
    mvNodesCol_MiniMapLink = ...
    mvNodesCol_MiniMapLinkSelected = ...
    mvNodesCol_MiniMapCanvas = ...
    mvNodesCol_MiniMapCanvasOutline = ...
    mvStyleVar_Alpha = ...
    mvStyleVar_DisabledAlpha = ...
    mvStyleVar_WindowPadding = ...
    mvStyleVar_WindowRounding = ...
    mvStyleVar_WindowBorderSize = ...
    mvStyleVar_WindowMinSize = ...
    mvStyleVar_WindowTitleAlign = ...
    mvStyleVar_ChildRounding = ...
    mvStyleVar_ChildBorderSize = ...
    mvStyleVar_PopupRounding = ...
    mvStyleVar_PopupBorderSize = ...
    mvStyleVar_FramePadding = ...
    mvStyleVar_FrameRounding = ...
    mvStyleVar_FrameBorderSize = ...
    mvStyleVar_ItemSpacing = ...
    mvStyleVar_ItemInnerSpacing = ...
    mvStyleVar_IndentSpacing = ...
    mvStyleVar_CellPadding = ...
    mvStyleVar_ScrollbarSize = ...
    mvStyleVar_ScrollbarRounding = ...
    mvStyleVar_GrabMinSize = ...
    mvStyleVar_GrabRounding = ...
    mvStyleVar_TabRounding = ...
    mvStyleVar_TabBorderSize = ...
    mvStyleVar_TabBarBorderSize = ...
    mvStyleVar_TableAngledHeadersAngle = ...
    mvStyleVar_TableAngledHeadersTextAlign = ...
    mvStyleVar_ButtonTextAlign = ...
    mvStyleVar_SelectableTextAlign = ...
    mvStyleVar_SeparatorTextBorderSize = ...
    mvStyleVar_SeparatorTextAlign = ...
    mvStyleVar_SeparatorTextPadding = ...
    mvPlotStyleVar_LineWeight = ...
    mvPlotStyleVar_Marker = ...
    mvPlotStyleVar_MarkerSize = ...
    mvPlotStyleVar_MarkerWeight = ...
    mvPlotStyleVar_FillAlpha = ...
    mvPlotStyleVar_ErrorBarSize = ...
    mvPlotStyleVar_ErrorBarWeight = ...
    mvPlotStyleVar_DigitalBitHeight = ...
    mvPlotStyleVar_DigitalBitGap = ...
    mvPlotStyleVar_PlotBorderSize = ...
    mvPlotStyleVar_MinorAlpha = ...
    mvPlotStyleVar_MajorTickLen = ...
    mvPlotStyleVar_MinorTickLen = ...
    mvPlotStyleVar_MajorTickSize = ...
    mvPlotStyleVar_MinorTickSize = ...
    mvPlotStyleVar_MajorGridSize = ...
    mvPlotStyleVar_MinorGridSize = ...
    mvPlotStyleVar_PlotPadding = ...
    mvPlotStyleVar_LabelPadding = ...
    mvPlotStyleVar_LegendPadding = ...
    mvPlotStyleVar_LegendInnerPadding = ...
    mvPlotStyleVar_LegendSpacing = ...
    mvPlotStyleVar_MousePosPadding = ...
    mvPlotStyleVar_AnnotationPadding = ...
    mvPlotStyleVar_FitPadding = ...
    mvPlotStyleVar_PlotDefaultSize = ...
    mvPlotStyleVar_PlotMinSize = ...
    mvNodeStyleVar_GridSpacing = ...
    mvNodeStyleVar_NodeCornerRounding = ...
    mvNodeStyleVar_NodePadding = ...
    mvNodeStyleVar_NodeBorderThickness = ...
    mvNodeStyleVar_LinkThickness = ...
    mvNodeStyleVar_LinkLineSegmentsPerLength = ...
    mvNodeStyleVar_LinkHoverDistance = ...
    mvNodeStyleVar_PinCircleRadius = ...
    mvNodeStyleVar_PinQuadSideLength = ...
    mvNodeStyleVar_PinTriangleSideLength = ...
    mvNodeStyleVar_PinLineThickness = ...
    mvNodeStyleVar_PinHoverRadius = ...
    mvNodeStyleVar_PinOffset = ...
    mvNodesStyleVar_MiniMapPadding = ...
    mvNodesStyleVar_MiniMapOffset = ...
    mvKey_Clear = ...
    mvKey_Prior = ...
    mvKey_Next = ...
    mvKey_Select = ...
    mvKey_Execute = ...
    mvKey_LWin = ...
    mvKey_RWin = ...
    mvKey_Apps = ...
    mvKey_Sleep = ...
    mvKey_Help = ...
    mvKey_Browser_Refresh = ...
    mvKey_Browser_Stop = ...
    mvKey_Browser_Search = ...
    mvKey_Browser_Favorites = ...
    mvKey_Browser_Home = ...
    mvKey_Volume_Mute = ...
    mvKey_Volume_Down = ...
    mvKey_Volume_Up = ...
    mvKey_Media_Next_Track = ...
    mvKey_Media_Prev_Track = ...
    mvKey_Media_Stop = ...
    mvKey_Media_Play_Pause = ...
    mvKey_Launch_Mail = ...
    mvKey_Launch_Media_Select = ...
    mvKey_Launch_App1 = ...
    mvKey_Launch_App2 = ...
    mvKey_Colon = ...
    mvKey_Plus = ...
    mvKey_Tilde = ...
    mvKey_Quote = ...
    mvKey_F25 = ...


class wrap_mutex:
    def __init__(self, target) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...
    


class wrap_this_and_parents_mutex:
    def __init__(self, target) -> None:
        ...
    
    def __enter__(self): # -> None:
        ...
    
    def __exit__(self, exc_type, exc_value, traceback): # -> Literal[False]:
        ...

class ActivatedHandler(baseHandler):
    """
    Handler for when the target item turns from
    the non-active to the active state. For instance
    buttons turn active when the mouse is pressed on them.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ActivatedHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ActivatedHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ActivatedHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ActivatedHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ActivatedHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ActiveHandler(baseHandler):
    """
    Handler for when the target item is active.
    For instance buttons turn active when the mouse
    is pressed on them, and stop being active when
    the mouse is released.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ActiveHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ActiveHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ActiveHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ActiveHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ActiveHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class AxesResizeHandler(baseHandler):
    """
    Handler that can only be bound to a plot,
    and that triggers the callback whenever the
    axes min/max OR the plot region box changes.
    Basically whenever the size
    of a pixel within plot coordinate has likely changed.

    The data field passed to the callback contains
    ((min, max, scale), (min, max, scale)) where
    scale = (max-min) / num_real_pixels
    and the first tuple is for the target X axis (default X1),
    and the second tuple for the target Y axis (default Y1)
    
    """
    def __init__(self, context : Context, axes : tuple = (0, 3), callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : AxesResizeHandler = ..., user_data : Any = ...):
        """

        axes: (X axis, Y axis)
            used for this handler.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, axes : tuple = (0, 3), callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : AxesResizeHandler = ..., user_data : Any = ...):
        """
        axes: (X axis, Y axis)
            used for this handler.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> AxesResizeHandler:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this handler.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> AxesResizeHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : AxesResizeHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Button(uiItem):
    def __init__(self, context : Context, arrow : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], direction : int = 2, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, repeat : bool = False, shareable_value : SharedBool = ..., show : bool = True, small : bool = False, tag : Button = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """

        arrow: Whether to display an arrow.
            Not compatible with small
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        direction: Direction of the arrow if any
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        repeat: Whether to generate many clicked events
            when the button is held repeatedly, instead of a single.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        small: Whether to display a small button
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, arrow : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], direction : int = 2, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, repeat : bool = False, shareable_value : SharedBool = ..., show : bool = True, small : bool = False, tag : Button = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """
        arrow: Whether to display an arrow.
            Not compatible with small
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        direction: Direction of the arrow if any
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        repeat: Whether to generate many clicked events
            when the button is held repeatedly, instead of a single.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        small: Whether to display a small button
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Button:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def arrow(self) -> bool:
        """
        Writable attribute: Whether to display an arrow.
        Not compatible with small
        
        """
        ...


    @arrow.setter
    def arrow(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def direction(self) -> int:
        """
        Writable attribute: Direction of the arrow if any
        
        """
        ...


    @direction.setter
    def direction(self, value : int):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def repeat(self) -> bool:
        """
        Writable attribute: Whether to generate many clicked events
        when the button is held repeatedly, instead of a single.
        
        """
        ...


    @repeat.setter
    def repeat(self, value : bool):
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def small(self) -> bool:
        """
        Writable attribute: Whether to display a small button
        
        """
        ...


    @small.setter
    def small(self, value : bool):
        ...


    @property
    def tag(self) -> Button:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Button):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class Callback(object):
    """
    Wrapper class that automatically encapsulate
    callbacks.

    Callbacks in DCG mode can take up to 3 arguments:
    . source_item: the item to which the callback was attached
    . target_item: the item for which the callback was raised.
        Is only different to source_item for handlers' callback.
    . call_info: If applicable information about the call (key button, etc)
    
    """
    def __init__(self, callback : DCGCallable):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


class Checkbox(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : Checkbox = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : Checkbox = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Checkbox:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Checkbox:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Checkbox):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ChildWindow(uiItem):
    def __init__(self, context : Context, always_auto_resize : bool = False, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, always_use_window_padding : bool = False, auto_resize_x : bool = False, auto_resize_y : bool = False, border : bool = True, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, flattened_navigation : bool = True, focused : bool = False, font : Font = None, frame_style : bool = False, handlers : list = [], height : int = 0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", menubar : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, resizable_x : bool = False, resizable_y : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : ChildWindow = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        always_auto_resize: combined with AutoResizeX/AutoResizeY.
            Always measure size even when child is hidden,
            Note the item will render its children even if hidden.
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        always_use_window_padding: pad with style WindowPadding even if
            no border are drawn (no padding by default for non-bordered
            child windows)
        auto_resize_x: enable auto-resizing width based on the content
            Set instead width to 0 to use the remaining size of the parent
        auto_resize_y: enable auto-resizing height based on the content
            Set instead height to 0 to use the remaining size of the parent
        border: show an outer border and enable WindowPadding.
            Defaults to True.
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        flattened_navigation: share focus scope, allow gamepad/keyboard
            navigation to cross over parent border to this child or
            between sibling child windows.
            Defaults to True.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        frame_style: if set, style the child window like a framed item.
            That is: use FrameBg, FrameRounding, FrameBorderSize, FramePadding
            instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        menubar: Writable attribute to indicate whether the window has a menu bar.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: mouse wheel will be forwarded to the parent
            unless NoScrollbar is also set.
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resizable_x: allow resize from right border (layout direction).
        resizable_y: allow resize from bottom border (layout direction).
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_auto_resize : bool = False, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, always_use_window_padding : bool = False, auto_resize_x : bool = False, auto_resize_y : bool = False, border : bool = True, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, flattened_navigation : bool = True, focused : bool = False, font : Font = None, frame_style : bool = False, handlers : list = [], height : int = 0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", menubar : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, resizable_x : bool = False, resizable_y : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : ChildWindow = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        always_auto_resize: combined with AutoResizeX/AutoResizeY.
            Always measure size even when child is hidden,
            Note the item will render its children even if hidden.
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        always_use_window_padding: pad with style WindowPadding even if
            no border are drawn (no padding by default for non-bordered
            child windows)
        auto_resize_x: enable auto-resizing width based on the content
            Set instead width to 0 to use the remaining size of the parent
        auto_resize_y: enable auto-resizing height based on the content
            Set instead height to 0 to use the remaining size of the parent
        border: show an outer border and enable WindowPadding.
            Defaults to True.
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        flattened_navigation: share focus scope, allow gamepad/keyboard
            navigation to cross over parent border to this child or
            between sibling child windows.
            Defaults to True.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        frame_style: if set, style the child window like a framed item.
            That is: use FrameBg, FrameRounding, FrameBorderSize, FramePadding
            instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        menubar: Writable attribute to indicate whether the window has a menu bar.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: mouse wheel will be forwarded to the parent
            unless NoScrollbar is also set.
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resizable_x: allow resize from right border (layout direction).
        resizable_y: allow resize from bottom border (layout direction).
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ChildWindow:
        ...


    @property
    def always_auto_resize(self) -> bool:
        """
        Writable attribute: combined with AutoResizeX/AutoResizeY.
        Always measure size even when child is hidden,
        Note the item will render its children even if hidden.
        
        """
        ...


    @always_auto_resize.setter
    def always_auto_resize(self, value : bool):
        ...


    @property
    def always_show_horizontal_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a horizontal scrollbar
        even when the size does not require it (only if horizontal scrollbar
        are enabled)
        
        """
        ...


    @always_show_horizontal_scrollvar.setter
    def always_show_horizontal_scrollvar(self, value : bool):
        ...


    @property
    def always_show_vertical_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a vertical scrollbar
        even when the size does not require it
        
        """
        ...


    @always_show_vertical_scrollvar.setter
    def always_show_vertical_scrollvar(self, value : bool):
        ...


    @property
    def always_use_window_padding(self) -> bool:
        """
        Writable attribute: pad with style WindowPadding even if
        no border are drawn (no padding by default for non-bordered
        child windows)
        
        """
        ...


    @always_use_window_padding.setter
    def always_use_window_padding(self, value : bool):
        ...


    @property
    def auto_resize_x(self) -> bool:
        """
        Writable attribute: enable auto-resizing width based on the content
        Set instead width to 0 to use the remaining size of the parent
        
        """
        ...


    @auto_resize_x.setter
    def auto_resize_x(self, value : bool):
        ...


    @property
    def auto_resize_y(self) -> bool:
        """
        Writable attribute: enable auto-resizing height based on the content
        Set instead height to 0 to use the remaining size of the parent
        
        """
        ...


    @auto_resize_y.setter
    def auto_resize_y(self, value : bool):
        ...


    @property
    def border(self) -> bool:
        """
        Writable attribute: show an outer border and enable WindowPadding.
        Defaults to True.
        
        """
        ...


    @border.setter
    def border(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_region_avail(self) -> tuple:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def flattened_navigation(self) -> bool:
        """
        Writable attribute: share focus scope, allow gamepad/keyboard
        navigation to cross over parent border to this child or
        between sibling child windows.
        Defaults to True.
        
        """
        ...


    @flattened_navigation.setter
    def flattened_navigation(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def frame_style(self) -> bool:
        """
        Writable attribute: if set, style the child window like a framed item.
        That is: use FrameBg, FrameRounding, FrameBorderSize, FramePadding
        instead of ChildBg, ChildRounding, ChildBorderSize, WindowPadding.
        
        """
        ...


    @frame_style.setter
    def frame_style(self, value : bool):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def horizontal_scrollbar(self) -> bool:
        """
        Writable attribute to enable having an horizontal scrollbar
        
        """
        ...


    @horizontal_scrollbar.setter
    def horizontal_scrollbar(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def menubar(self) -> bool:
        """
        Writable attribute to indicate whether the window has a menu bar.

        There will be menubar if either the user has asked for it,
        or there is a menubar child.
        
        """
        ...


    @menubar.setter
    def menubar(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_scroll_with_mouse(self) -> bool:
        """
        Writable attribute: mouse wheel will be forwarded to the parent
        unless NoScrollbar is also set.
        
        """
        ...


    @no_scroll_with_mouse.setter
    def no_scroll_with_mouse(self, value : bool):
        ...


    @property
    def no_scrollbar(self) -> bool:
        """Writable attribute to indicate the window should have no scrollbar
           Does not disable scrolling via mouse or keyboard
        
        """
        ...


    @no_scrollbar.setter
    def no_scrollbar(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resizable_x(self) -> bool:
        """
        Writable attribute: allow resize from right border (layout direction).
        
        """
        ...


    @resizable_x.setter
    def resizable_x(self, value : bool):
        ...


    @property
    def resizable_y(self) -> bool:
        """
        Writable attribute: allow resize from bottom border (layout direction).
        
        """
        ...


    @resizable_y.setter
    def resizable_y(self, value : bool):
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ChildWindow:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ChildWindow):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ClickedHandler(baseHandler):
    """
    Handler for when a hovered item is clicked on.
    The item doesn't have to be interactable,
    it can be Text for example.
    
    """
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ClickedHandler = ..., user_data : Any = ...):
        """

        button: Target mouse button
            0: left click
            1: right click
            2: middle click
            3, 4: other buttons
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ClickedHandler = ..., user_data : Any = ...):
        """
        button: Target mouse button
            0: left click
            1: right click
            2: middle click
            3, 4: other buttons
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ClickedHandler:
        ...


    @property
    def button(self) -> MouseButton:
        """
        Target mouse button
        0: left click
        1: right click
        2: middle click
        3, 4: other buttons
        
        """
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ClickedHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ClickedHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class CloseHandler(baseHandler):
    """
    Handler that triggers the callback when the
    item is in an closed state.
    *Warning*: Does not mean an item is un-shown
    by a user interaction (what we usually mean
    by closing a window).
    Here Close/Open refers to being in a
    reduced state when the full content is not
    shown, but could be if the user clicked on
    a specific button. The doesn't mean that
    the object is show or not shown.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : CloseHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : CloseHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> CloseHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> CloseHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : CloseHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class CollapsingHeader(uiItem):
    def __init__(self, context : Context, bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], closable : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", leaf : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, open_on_arrow : bool = False, open_on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : CollapsingHeader = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """

        bullet: Display a bullet instead of arrow.
            IMPORTANT: node can still be marked open/close if
            you don't set the _Leaf flag!
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closable: Display a close button
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leaf: No collapsing, no arrow (use as a convenience for leaf nodes).
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        open_on_arrow: Only open when clicking on the arrow part.
            If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
            single-click arrow or double-click all box to open.
        open_on_double_click: Need double-click to open node
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], closable : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", leaf : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, open_on_arrow : bool = False, open_on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : CollapsingHeader = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """
        bullet: Display a bullet instead of arrow.
            IMPORTANT: node can still be marked open/close if
            you don't set the _Leaf flag!
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closable: Display a close button
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leaf: No collapsing, no arrow (use as a convenience for leaf nodes).
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        open_on_arrow: Only open when clicking on the arrow part.
            If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
            single-click arrow or double-click all box to open.
        open_on_double_click: Need double-click to open node
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> CollapsingHeader:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def bullet(self) -> bool:
        """
        Writable attribute: Display a bullet instead of arrow.
        IMPORTANT: node can still be marked open/close if
        you don't set the _Leaf flag!
        
        """
        ...


    @bullet.setter
    def bullet(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def closable(self) -> bool:
        """
        Writable attribute: Display a close button
        
        """
        ...


    @closable.setter
    def closable(self, value : bool):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def leaf(self) -> bool:
        """
        Writable attribute: No collapsing, no arrow (use as a convenience for leaf nodes).
        
        """
        ...


    @leaf.setter
    def leaf(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def open_on_arrow(self) -> bool:
        """
        Writable attribute:  Only open when clicking on the arrow part.
        If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
        single-click arrow or double-click all box to open.
        
        """
        ...


    @open_on_arrow.setter
    def open_on_arrow(self, value : bool):
        ...


    @property
    def open_on_double_click(self) -> bool:
        """
        Writable attribute: Need double-click to open node
        
        """
        ...


    @open_on_double_click.setter
    def open_on_double_click(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> CollapsingHeader:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : CollapsingHeader):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ColorButton(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_border : bool = False, no_drag_drop : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedColor = ..., show : bool = True, tag : ColorButton = ..., theme : Any = ..., user_data : Any = ..., value : int = 0, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_border: disable the default border
        no_drag_drop: disable drag and drop source
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_border : bool = False, no_drag_drop : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedColor = ..., show : bool = True, tag : ColorButton = ..., theme : Any = ..., user_data : Any = ..., value : int = 0, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_border: disable the default border
        no_drag_drop: disable drag and drop source
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ColorButton:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_alpha(self) -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        
        """
        ...


    @no_alpha.setter
    def no_alpha(self, value : bool):
        ...


    @property
    def no_border(self) -> bool:
        """
        Writable attribute: disable the default border
        
        """
        ...


    @no_border.setter
    def no_border(self, value : bool):
        ...


    @property
    def no_drag_drop(self) -> bool:
        """
        Writable attribute: disable drag and drop source
        
        """
        ...


    @no_drag_drop.setter
    def no_drag_drop(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedColor:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedColor):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ColorButton:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ColorButton):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> int:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : int):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ColorEdit(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_drag_drop : bool = False, no_inputs : bool = False, no_label : bool = False, no_newline : float = 0.0, no_options : bool = False, no_picker : bool = False, no_scaling : bool = False, no_small_preview : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedColor = ..., show : bool = True, tag : ColorEdit = ..., theme : Any = ..., user_data : Any = ..., value : int = 0, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_drag_drop: disable drag and drop target
        no_inputs: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        no_label: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_options: disable toggling options menu when right-clicking on inputs/small preview.
        no_picker: disable picker when clicking on color square.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_small_preview: disable color square preview next to the inputs. (e.g. to show only the inputs)
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_drag_drop : bool = False, no_inputs : bool = False, no_label : bool = False, no_newline : float = 0.0, no_options : bool = False, no_picker : bool = False, no_scaling : bool = False, no_small_preview : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedColor = ..., show : bool = True, tag : ColorEdit = ..., theme : Any = ..., user_data : Any = ..., value : int = 0, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_drag_drop: disable drag and drop target
        no_inputs: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        no_label: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_options: disable toggling options menu when right-clicking on inputs/small preview.
        no_picker: disable picker when clicking on color square.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_small_preview: disable color square preview next to the inputs. (e.g. to show only the inputs)
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ColorEdit:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_alpha(self) -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        
        """
        ...


    @no_alpha.setter
    def no_alpha(self, value : bool):
        ...


    @property
    def no_drag_drop(self) -> bool:
        """
        Writable attribute: disable drag and drop target
        
        """
        ...


    @no_drag_drop.setter
    def no_drag_drop(self, value : bool):
        ...


    @property
    def no_inputs(self) -> bool:
        """
        Writable attribute: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        
        """
        ...


    @no_inputs.setter
    def no_inputs(self, value : bool):
        ...


    @property
    def no_label(self) -> bool:
        """
        Writable attribute: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        
        """
        ...


    @no_label.setter
    def no_label(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_options(self) -> bool:
        """
        Writable attribute: disable toggling options menu when right-clicking on inputs/small preview.
        
        """
        ...


    @no_options.setter
    def no_options(self, value : bool):
        ...


    @property
    def no_picker(self) -> bool:
        """
        Writable attribute: disable picker when clicking on color square.
        
        """
        ...


    @no_picker.setter
    def no_picker(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_small_preview(self) -> bool:
        """
        Writable attribute: disable color square preview next to the inputs. (e.g. to show only the inputs)
        
        """
        ...


    @no_small_preview.setter
    def no_small_preview(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedColor:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedColor):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ColorEdit:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ColorEdit):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> int:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : int):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ColorPicker(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_inputs : bool = False, no_label : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_side_preview : bool = False, no_small_preview : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedColor = ..., show : bool = True, tag : ColorPicker = ..., theme : Any = ..., user_data : Any = ..., value : int = 0, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_inputs: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        no_label: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_side_preview: disable bigger color preview on right side of the picker, use small color square preview instead.
        no_small_preview: disable color square preview next to the inputs. (e.g. to show only the inputs)
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_alpha : bool = False, no_inputs : bool = False, no_label : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_side_preview : bool = False, no_small_preview : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedColor = ..., show : bool = True, tag : ColorPicker = ..., theme : Any = ..., user_data : Any = ..., value : int = 0, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_alpha: ignore Alpha component (will only read 3 components from the input pointer)
        no_inputs: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        no_label: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_side_preview: disable bigger color preview on right side of the picker, use small color square preview instead.
        no_small_preview: disable color square preview next to the inputs. (e.g. to show only the inputs)
        no_tooltip: disable default tooltip when hovering the preview
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ColorPicker:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_alpha(self) -> bool:
        """
        Writable attribute: ignore Alpha component (will only read 3 components from the input pointer)
        
        """
        ...


    @no_alpha.setter
    def no_alpha(self, value : bool):
        ...


    @property
    def no_inputs(self) -> bool:
        """
        Writable attribute: disable inputs sliders/text widgets (e.g. to show only the small preview color square).
        
        """
        ...


    @no_inputs.setter
    def no_inputs(self, value : bool):
        ...


    @property
    def no_label(self) -> bool:
        """
        Writable attribute: disable display of inline text label (the label is still forwarded to the tooltip and picker).
        
        """
        ...


    @no_label.setter
    def no_label(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_side_preview(self) -> bool:
        """
        Writable attribute: disable bigger color preview on right side of the picker, use small color square preview instead.
        
        """
        ...


    @no_side_preview.setter
    def no_side_preview(self, value : bool):
        ...


    @property
    def no_small_preview(self) -> bool:
        """
        Writable attribute: disable color square preview next to the inputs. (e.g. to show only the inputs)
        
        """
        ...


    @no_small_preview.setter
    def no_small_preview(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: disable default tooltip when hovering the preview
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedColor:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedColor):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ColorPicker:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ColorPicker):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> int:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : int):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class Combo(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, fit_width : bool = False, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, height_mode : str = "regular", indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_arrow_button : bool = False, no_newline : float = 0.0, no_preview : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, popup_align_left : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedStr = ..., show : bool = True, tag : Combo = ..., theme : Any = ..., user_data : Any = ..., value : str = "", width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        fit_width: Whether the combo should fit available width
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        height_mode: height mode of the combo.
            Supported values are
            "small"
            "regular"
            "large"
            "largest"
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_arrow_button: Whether the combo should not display an arrow on top
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_preview: Whether the preview should be disabled
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        popup_align_left: Whether to align left
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, fit_width : bool = False, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, height_mode : str = "regular", indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_arrow_button : bool = False, no_newline : float = 0.0, no_preview : bool = False, no_scaling : bool = False, parent : uiItem | plotElement | None = None, popup_align_left : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedStr = ..., show : bool = True, tag : Combo = ..., theme : Any = ..., user_data : Any = ..., value : str = "", width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        fit_width: Whether the combo should fit available width
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        height_mode: height mode of the combo.
            Supported values are
            "small"
            "regular"
            "large"
            "largest"
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_arrow_button: Whether the combo should not display an arrow on top
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_preview: Whether the preview should be disabled
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        popup_align_left: Whether to align left
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Combo:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def fit_width(self) -> bool:
        """
        Writable attribute: Whether the combo should fit available width
        
        """
        ...


    @fit_width.setter
    def fit_width(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def height_mode(self) -> str:
        """
        Writable attribute: height mode of the combo.
        Supported values are
        "small"
        "regular"
        "large"
        "largest"
        
        """
        ...


    @height_mode.setter
    def height_mode(self, value : str):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def items(self) -> list:
        """
        Writable attribute: List of text values to select
        
        """
        ...


    @items.setter
    def items(self, value : list):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_arrow_button(self) -> bool:
        """
        Writable attribute: Whether the combo should not display an arrow on top
        
        """
        ...


    @no_arrow_button.setter
    def no_arrow_button(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_preview(self) -> bool:
        """
        Writable attribute: Whether the preview should be disabled
        
        """
        ...


    @no_preview.setter
    def no_preview(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def popup_align_left(self) -> bool:
        """
        Writable attribute: Whether to align left
        
        """
        ...


    @popup_align_left.setter
    def popup_align_left(self, value : bool):
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Combo:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Combo):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ConditionalHandler(baseHandler):
    """
    A handler that runs the handler of his FIRST handler
    child if the other ones have their condition checked.
    The other handlers are not run. Just their condition
    is checked.

    For example this is useful to combine conditions. For example
    detecting clicks when a key is pressed. The interest
    of using this handler, rather than handling it yourself, is
    that if the callback queue is laggy the condition might not
    hold true anymore by the time you process the handler.
    In this case this handler enables to test right away
    the intended conditions.

    Note that handlers that get their condition checked do
    not call their callbacks.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ConditionalHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ConditionalHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ConditionalHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> list[baseHandler]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseHandler]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ConditionalHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ConditionalHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Context(object):
    """
    Main class managing the DearCyGui items and imgui context.
    There is exactly one viewport per context.

    Items are assigned an uuid and eventually a user tag.
    indexing the context with the uuid or the tag returns
    the object associated.

    The last created context can be accessed as deacygui.C
    
    """
    def fetch_last_created_container(self):
        """
        Return the last item which can have children
        created in this thread.
        Returns None if the last such item has been
        deleted.
        
        """
        ...


    def fetch_last_created_item(self):
        """
        Return the last item created in this thread.
        Returns None if the last item created has been
        deleted.
        
        """
        ...


    def fetch_parent_queue_back(self):
        """
        Retrieve the last item from the potential parent list
        
        """
        ...


    def fetch_parent_queue_front(self):
        """
        Retrieve the top item from the potential parent list
        
        """
        ...


    def get_mouse_clicked_count(self, button):
        """
how many times a mouse button is clicked in a row
        """
        ...


    def get_mouse_drag_delta(self, button, lock_threshold=-1.0):
        """
        Return the delta (dx, dy) from the initial clicking position while the mouse button is pressed or was just released.
        
        This is locked and return 0.0f until the mouse moves past a distance threshold at least once
        (uses default distance if lock_threshold < 0.0f)
        """
        ...


    def get_mouse_position(self):
        """
Retrieves the mouse position (x, y). Raises KeyError if there is no mouse
        """
        ...


    def is_key_down(self, key, keymod=-1):
        """
        Is key being held.

        key is a key constant (see constants)
        keymod is a mask if keymod constants (ctrl, shift, alt, super)
        if keymod is negative, ignores any key modifiers.
        If non-negative, returns True only if the modifiers
        correspond as well as the key.
        
        """
        ...


    def is_key_pressed(self, key, keymod=-1, repeat=True):
        """
        Was key pressed (went from !Down to Down)?
        
        if repeat=true, the pressed state is repeated
        if the user continue pressing the key.
        If keymod is non-negative, returns True only if the modifiers
        correspond as well as the key.

        
        """
        ...


    def is_key_released(self, key, keymod=-1):
        """
        Was key released (went from Down to !Down)?
        
        If keymod is non-negative, returns True also if the
        required modifiers are not pressed.
        
        """
        ...


    def is_mouse_clicked(self, button, repeat=False):
        """
did mouse button clicked? (went from !Down to Down). Same as get_mouse_clicked_count() >= 1.
        """
        ...


    def is_mouse_double_clicked(self, button):
        """
did mouse button double-clicked?. Same as get_mouse_clicked_count() == 2.
        """
        ...


    def is_mouse_down(self, button):
        """
is mouse button held?
        """
        ...


    def is_mouse_dragging(self, button, lock_threshold=-1.0):
        """
is mouse dragging? (uses default distance threshold if lock_threshold < 0.0f
        """
        ...


    def is_mouse_released(self, button):
        """
did mouse button released? (went from Down to !Down)
        """
        ...


    def pop_next_parent(self):
        """
        Remove an item from the potential parent list.
        
        """
        ...


    def push_next_parent(self, next_parent):
        """
        Each time 'with' is used on an item, it is pushed
        to the list of potentialy parents to use if
        no parent (or before) is set when an item is created.
        If the list is empty, items are left unattached and
        can be attached later.

        In order to enable multiple threads from using
        the 'with' syntax, thread local storage is used,
        such that each thread has its own list.
        
        """
        ...


    def reset_mouse_drag_delta(self, button):
        """
Reset to 0 the drag delta for the target button
        """
        ...


    @property
    def clipboard(self) -> str:
        """Writable attribute: content of the clipboard
        """
        ...


    @clipboard.setter
    def clipboard(self, value : str):
        ...


    @property
    def running(self) -> bool:
        ...


    @running.setter
    def running(self, value : bool):
        ...


    @property
    def viewport(self) -> Viewport:
        """Readonly attribute: root item from where rendering starts
        """
        ...


class CustomHandler(baseHandler):
    """
    A base class to be subclassed in python
    for custom state checking.
    As this is called every frame rendered,
    and locks the GIL, be careful not do perform
    anything heavy.

    The functions that need to be implemented by
    subclasses are:
    -> check_can_bind(self, item)
    = Must return a boolean to indicate
    if this handler can be bound to
    the target item. Use isinstance to check
    the target class of the item.
    Note isinstance can recognize parent classes as
    well as subclasses. You can raise an exception.

    -> check_status(self, item)
    = Must return a boolean to indicate if the
    condition this handler looks at is met.
    Should not perform any action.

    -> run(self, item)
    Optional. If implemented, must perform
    the check this handler is meant to do,
    and take the appropriate actions in response
    (callbacks, etc). returns None.
    Note even if you implement run, check_status
    is still required. But it will not trigger calls
    to the callback. If you don't implement run(),
    returning True in check_status will trigger
    the callback.
    As a good practice try to not perform anything
    heavy to not block rendering.

    Warning: DO NOT change any item's parent, sibling
    or child. Rendering might rely on the tree being
    unchanged.
    You can change item values or status (show, theme, etc),
    except for parents of the target item.
    If you want to do that, delay the changes to when
    you are outside render_frame() or queue the change
    to be executed in another thread (mutexes protect
    states that need to not change during rendering,
    when accessed from a different thread). 

    If you need to access specific DCG internal item states,
    you must use Cython and subclass baseHandler instead.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : CustomHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : CustomHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> CustomHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> CustomHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : CustomHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DPGCallback(Callback):
    """
    Used to run callbacks created for DPG
    
    """
    def __init__(self, callback : DCGCallable):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


class DeactivatedAfterEditHandler(baseHandler):
    """
    However for editable items when the item loses
    activation after having been edited.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DeactivatedAfterEditHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DeactivatedAfterEditHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DeactivatedAfterEditHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DeactivatedAfterEditHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DeactivatedAfterEditHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DeactivatedHandler(baseHandler):
    """
    Handler for when an active item loses activation.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DeactivatedHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DeactivatedHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DeactivatedHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DeactivatedHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DeactivatedHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DoubleClickedHandler(baseHandler):
    """
    Handler for when a hovered item is double clicked on.
    
    """
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DoubleClickedHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DoubleClickedHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DoubleClickedHandler:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DoubleClickedHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DoubleClickedHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DragPoint(DrawingList):
    def __init__(self, context: dearcygui.core.Context, context : Context, _clamp_inside : bool = False, _on_dragged : Any = ..., _on_dragging : Any = ..., _on_hover : Any = ..., _radius : float = 4.0, capture_mouse : bool = True, children : list[drawingItem] = ..., clamp_inside : bool = False, color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 1.0, 0.0, 1.0], handlers : list = ..., invisible : DrawInvisibleButton = ..., next_sibling : baseItem | None = None, no_input : bool = False, on_dragged : Any = ..., on_dragging : Any = ..., on_hover : Any = ..., parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : float = 4.0, show : bool = True, tag : DragPoint = ..., user_data : Any = ..., visible : DrawCircle = ..., was_dragging : bool = False, x : float = 0.0, y : float = 0.0):
        """
        capture_mouse: See DrawInvisibleButton for a detailed description
        children: List of all the children of the item,
            from first rendered, to last rendered.
        clamp_inside: If set, the point will be forced to remain
            in the plot visible area.
        color: Color of the displayed circle
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: Disable taking user inputs
        on_dragged: Callback that is called whenever the item
            changes position due to user interaction and
            the user releases his interaction.
        on_dragging: Callback that is called whenever the item
            changes position due to user interaction
        on_hover: Callback that is called whenever the item
            is hovered
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        radius: Radius of the draggable point
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        x: X coordinate in screen space
        y: Y coordinate in screen space
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, _clamp_inside : bool = False, _on_dragged : Any = ..., _on_dragging : Any = ..., _on_hover : Any = ..., _radius : float = 4.0, capture_mouse : bool = True, children : list[drawingItem] = ..., clamp_inside : bool = False, color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 1.0, 0.0, 1.0], handlers : list = ..., invisible : DrawInvisibleButton = ..., next_sibling : baseItem | None = None, no_input : bool = False, on_dragged : Any = ..., on_dragging : Any = ..., on_hover : Any = ..., parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : float = 4.0, show : bool = True, tag : DragPoint = ..., user_data : Any = ..., visible : DrawCircle = ..., was_dragging : bool = False, x : float = 0.0, y : float = 0.0):
        """
        capture_mouse: See DrawInvisibleButton for a detailed description
        children: List of all the children of the item,
            from first rendered, to last rendered.
        clamp_inside: If set, the point will be forced to remain
            in the plot visible area.
        color: Color of the displayed circle
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: Disable taking user inputs
        on_dragged: Callback that is called whenever the item
            changes position due to user interaction and
            the user releases his interaction.
        on_dragging: Callback that is called whenever the item
            changes position due to user interaction
        on_hover: Callback that is called whenever the item
            is hovered
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        radius: Radius of the draggable point
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        x: X coordinate in screen space
        y: Y coordinate in screen space
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DragPoint:
        ...


    @property
    def _clamp_inside(self) -> bool:
        ...


    @_clamp_inside.setter
    def _clamp_inside(self, value : bool):
        ...


    @property
    def _on_dragged(self):
        ...


    @_on_dragged.setter
    def _on_dragged(self, value):
        ...


    @property
    def _on_dragging(self):
        ...


    @_on_dragging.setter
    def _on_dragging(self, value):
        ...


    @property
    def _on_hover(self):
        ...


    @_on_hover.setter
    def _on_hover(self, value):
        ...


    @property
    def _radius(self) -> float:
        ...


    @_radius.setter
    def _radius(self, value : float):
        ...


    @property
    def activated(self) -> bool:
        ...


    @property
    def active(self) -> bool:
        ...


    @property
    def capture_mouse(self) -> bool:
        """See DrawInvisibleButton for a detailed description
        """
        ...


    @capture_mouse.setter
    def capture_mouse(self, value : bool):
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def clamp_inside(self) -> bool:
        """
        If set, the point will be forced to remain
        in the plot visible area.
        
        """
        ...


    @clamp_inside.setter
    def clamp_inside(self, value : bool):
        ...


    @property
    def clicked(self) -> tuple:
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        """Color of the displayed circle
        """
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        ...


    @property
    def double_clicked(self) -> list:
        ...


    @property
    def handlers(self) -> list:
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def invisible(self) -> DrawInvisibleButton:
        ...


    @invisible.setter
    def invisible(self, value : DrawInvisibleButton):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_input(self) -> bool:
        """
        Disable taking user inputs
        
        """
        ...


    @no_input.setter
    def no_input(self, value : bool):
        ...


    @property
    def on_dragged(self):
        """
        Callback that is called whenever the item
        changes position due to user interaction and
        the user releases his interaction.
        
        """
        ...


    @on_dragged.setter
    def on_dragged(self, value):
        ...


    @property
    def on_dragging(self):
        """
        Callback that is called whenever the item
        changes position due to user interaction
        
        """
        ...


    @on_dragging.setter
    def on_dragging(self, value):
        ...


    @property
    def on_hover(self):
        """
        Callback that is called whenever the item
        is hovered
        
        """
        ...


    @on_hover.setter
    def on_hover(self, value):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_to_parent(self) -> tuple:
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        ...


    @property
    def pos_to_window(self) -> tuple:
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def radius(self) -> float:
        """Radius of the draggable point
        """
        ...


    @radius.setter
    def radius(self, value : float):
        ...


    @property
    def rect_size(self) -> tuple:
        ...


    @property
    def resized(self) -> bool:
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DragPoint:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DragPoint):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def visible(self) -> DrawCircle:
        ...


    @visible.setter
    def visible(self, value : DrawCircle):
        ...


    @property
    def was_dragging(self) -> bool:
        ...


    @was_dragging.setter
    def was_dragging(self, value : bool):
        ...


    @property
    def x(self) -> float:
        """X coordinate in screen space
        """
        ...


    @x.setter
    def x(self, value : float):
        ...


    @property
    def y(self) -> float:
        """Y coordinate in screen space
        """
        ...


    @y.setter
    def y(self, value : float):
        ...


class DraggedHandler(baseHandler):
    """
    Same as DraggingHandler, but only
    triggers the callback when the dragging
    has ended, instead of every frame during
    the dragging.
    
    """
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DraggedHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DraggedHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DraggedHandler:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DraggedHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DraggedHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DraggingHandler(baseHandler):
    """
    Handler to catch when the item is hovered
    and the mouse is dragging (click + motion) ?
    Note that if the item is not a button configured
    to catch the target button, it will not be
    considered being dragged as soon as it is not
    hovered anymore.
    
    """
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DraggingHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DraggingHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DraggingHandler:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DraggingHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DraggingHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawArrow(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, size : float = 4.0, tag : DrawArrow = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, size : float = 4.0, tag : DrawArrow = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawArrow:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> list:
        ...


    @p1.setter
    def p1(self, value : list):
        ...


    @property
    def p2(self) -> list:
        ...


    @p2.setter
    def p2(self, value : list):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def size(self) -> float:
        ...


    @size.setter
    def size(self, value : float):
        ...


    @property
    def tag(self) -> DrawArrow:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawArrow):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawBezierCubic(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], p4 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, tag : DrawBezierCubic = ..., thickness : float = 0.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], p4 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, tag : DrawBezierCubic = ..., thickness : float = 0.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawBezierCubic:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> list:
        ...


    @p1.setter
    def p1(self, value : list):
        ...


    @property
    def p2(self) -> list:
        ...


    @p2.setter
    def p2(self, value : list):
        ...


    @property
    def p3(self) -> list:
        ...


    @p3.setter
    def p3(self, value : list):
        ...


    @property
    def p4(self) -> list:
        ...


    @p4.setter
    def p4(self, value : list):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def segments(self) -> int:
        ...


    @segments.setter
    def segments(self, value : int):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawBezierCubic:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawBezierCubic):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawBezierQuadratic(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, tag : DrawBezierQuadratic = ..., thickness : float = 0.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, tag : DrawBezierQuadratic = ..., thickness : float = 0.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawBezierQuadratic:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> list:
        ...


    @p1.setter
    def p1(self, value : list):
        ...


    @property
    def p2(self) -> list:
        ...


    @p2.setter
    def p2(self, value : list):
        ...


    @property
    def p3(self) -> list:
        ...


    @p3.setter
    def p3(self, value : list):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def segments(self) -> int:
        ...


    @segments.setter
    def segments(self, value : int):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawBezierQuadratic:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawBezierQuadratic):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawCircle(drawingItem):
    def __init__(self, context : Context, center : list = [0.0, 0.0], children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : Any = ..., segments : int = 0, show : bool = True, tag : DrawCircle = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, center : list = [0.0, 0.0], children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, radius : Any = ..., segments : int = 0, show : bool = True, tag : DrawCircle = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawCircle:
        ...


    @property
    def center(self) -> list:
        ...


    @center.setter
    def center(self, value : list):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @fill.setter
    def fill(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def radius(self):
        ...


    @radius.setter
    def radius(self, value):
        ...


    @property
    def segments(self) -> int:
        ...


    @segments.setter
    def segments(self, value : int):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawCircle:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawCircle):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawEllipse(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : list = [0.0, 0.0], pmin : list = [0.0, 0.0], previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, tag : DrawEllipse = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : list = [0.0, 0.0], pmin : list = [0.0, 0.0], previous_sibling : baseItem | None = None, segments : int = 0, show : bool = True, tag : DrawEllipse = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawEllipse:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @fill.setter
    def fill(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pmax(self) -> list:
        ...


    @pmax.setter
    def pmax(self, value : list):
        ...


    @property
    def pmin(self) -> list:
        ...


    @pmin.setter
    def pmin(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def segments(self) -> int:
        ...


    @segments.setter
    def segments(self, value : int):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawEllipse:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawEllipse):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawImage(drawingItem):
    def __init__(self, context : Context, children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : list = [0.0, 0.0], pmin : list = [0.0, 0.0], previous_sibling : baseItem | None = None, show : bool = True, tag : DrawImage = ..., texture : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 1.0, 1.0]):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : list = [0.0, 0.0], pmin : list = [0.0, 0.0], previous_sibling : baseItem | None = None, show : bool = True, tag : DrawImage = ..., texture : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 1.0, 1.0]):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawImage:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color_multiplier(self) -> list:
        ...


    @color_multiplier.setter
    def color_multiplier(self, value : list):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pmax(self) -> list:
        ...


    @pmax.setter
    def pmax(self, value : list):
        ...


    @property
    def pmin(self) -> list:
        ...


    @pmin.setter
    def pmin(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawImage:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawImage):
        ...


    @property
    def texture(self):
        ...


    @texture.setter
    def texture(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def uv(self) -> list:
        ...


    @uv.setter
    def uv(self, value : list):
        ...


class DrawImageQuad(drawingItem):
    def __init__(self, context : Context, children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], p4 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawImageQuad = ..., texture : Any = ..., user_data : Any = ..., uv1 : list = [0.0, 0.0], uv2 : list = [0.0, 0.0], uv3 : list = [0.0, 0.0], uv4 : list = [0.0, 0.0]):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], p4 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawImageQuad = ..., texture : Any = ..., user_data : Any = ..., uv1 : list = [0.0, 0.0], uv2 : list = [0.0, 0.0], uv3 : list = [0.0, 0.0], uv4 : list = [0.0, 0.0]):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawImageQuad:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color_multiplier(self) -> list:
        ...


    @color_multiplier.setter
    def color_multiplier(self, value : list):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> list:
        ...


    @p1.setter
    def p1(self, value : list):
        ...


    @property
    def p2(self) -> list:
        ...


    @p2.setter
    def p2(self, value : list):
        ...


    @property
    def p3(self) -> list:
        ...


    @p3.setter
    def p3(self, value : list):
        ...


    @property
    def p4(self) -> list:
        ...


    @p4.setter
    def p4(self, value : list):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawImageQuad:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawImageQuad):
        ...


    @property
    def texture(self):
        ...


    @texture.setter
    def texture(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def uv1(self) -> list:
        ...


    @uv1.setter
    def uv1(self, value : list):
        ...


    @property
    def uv2(self) -> list:
        ...


    @uv2.setter
    def uv2(self, value : list):
        ...


    @property
    def uv3(self) -> list:
        ...


    @uv3.setter
    def uv3(self, value : list):
        ...


    @property
    def uv4(self) -> list:
        ...


    @uv4.setter
    def uv4(self, value : list):
        ...


class DrawInPlot(plotElementWithLegend):
    """
    A plot element that enables to insert Draw* items
    inside a plot in plot coordinates.

    defaults to no_legend = True
    
    """
    def __init__(self, context : Context, axes : tuple = (0, 3), children : list[drawingItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = True, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawInPlot = ..., theme : Any = ..., user_data : Any = ...):
        """

        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, axes : tuple = (0, 3), children : list[drawingItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = True, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawInPlot = ..., theme : Any = ..., user_data : Any = ...):
        """
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawInPlot:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawInPlot:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawInPlot):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawInWindow(uiItem):
    """
    An UI item that contains a region for Draw* elements.
    Enables to insert Draw* Elements inside a window.

    Inside a DrawInWindow elements, the (0, 0) coordinate
    starts at the top left of the DrawWindow and y increases
    when going down.
    The drawing region is clipped by the available width/height
    of the item (set manually, or deduced).

    An invisible button is created to span the entire drawing
    area, which is used to retrieve button states on the area
    (hovering, active, etc). If set, the callback is called when
    the mouse is pressed inside the area with any of the left,
    middle or right button.
    In addition, the use of an invisible button enables the drag
    and drop behaviour proposed by imgui.

    If you intend on dragging elements inside the drawing area,
    you can either implement yourself a hovering test for your
    specific items and use the context's is_mouse_dragging, or
    add invisible buttons on top of the elements you want to
    interact with, and combine the active and mouse dragging
    handlers. Note if you intend to make an element draggable
    that way, you must not make the element source of a Drag
    and Drop, as it impacts the hovering tests.

    Note that Drawing items do not have any hovering/clicked/
    visible/etc tests maintained and thus do not have a callback.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[drawingItem] = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : DrawInWindow = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[drawingItem] = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : DrawInWindow = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawInWindow:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawInWindow:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawInWindow):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class DrawInvisibleButton(drawingItem):
    """
    Invisible rectangular area, parallel to axes, behaving
    like a button (using imgui default handling of buttons).

    Unlike other Draw items, this item accepts handlers and callbacks.

    DrawInvisibleButton can be overlapped on top of each other. In that
    case only one will be considered hovered. This one corresponds to the
    last one of the rendering tree that is hovered. If the button is
    considered active (see below), it retains the hover status to itself.
    Thus if you drag an invisible button on top of items later in the
    rendering tree, they will not be considered hovered.

    Note that only the mouse button(s) that trigger activation will
    have the above described behaviour for hover tests. If the mouse
    doesn't hover anymore the item, it will remain active as long
    as the configured buttons are pressed.

    When inside a plot, drag deltas are returned in plot coordinates,
    that is the deltas correspond to the deltas you must apply
    to your drawing coordinates compared to their original position
    to apply the dragging. When not in a plot, the drag deltas are
    in screen coordinates, and you must convert yourself to drawing
    coordinates if you are applying matrix transforms to your data.
    Generally matrix transforms are not well supported by
    DrawInvisibleButtons, and the shifted position that is updated
    during dragging might be invalid.

    Dragging handlers will not be triggered if the item is not active
    (unlike normal imgui items).

    If you create a DrawInvisibleButton in front of the mouse while
    the mouse is clicked with one of the activation buttons, it will
    steal hovering and activation tests. This is not the case of other
    gui items (except modal windows).

    If your Draw Button is not part of a window (ViewportDrawList),
    the hovering test might not be reliable (except specific case above).

    DrawInvisibleButton accepts children. In that case, the children
    are drawn relative to the coordinates of the DrawInvisibleButton,
    where top left is (0, 0) and bottom right is (1, 1).
    
    """
    def __init__(self, context : Context, button : MouseButtonMask = 1, capture_mouse : bool = True, children : list[drawingItem] = [], handlers : list = [], max_side : float = inf, min_side : float = 0.0, next_sibling : baseItem | None = None, no_input : bool = False, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawInvisibleButton = ..., user_data : Any = ...):
        """

        button: Mouse button mask that makes the invisible button
            active and triggers the item's callback.
        capture_mouse: If set, the item will
            capture the mouse if hovered even if another
            item was already active.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        max_side: If the rectangle width or height after
            coordinate transform is higher than this,
            resize the screen space transformed coordinates
            such that the width/height are at max max_side.
            Retains original ratio.
        min_side: If the rectangle width or height after
            coordinate transform is lower than this,
            resize the screen space transformed coordinates
            such that the width/height are at least min_side.
            Retains original ratio.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: If enabled, this item will not
            detect hovering or activation, thus letting other
            items taking the inputs.
        p1: Corner of the invisible button in plot/drawing
            space
        p2: Opposite corner of the invisible button in plot/drawing
            space
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButtonMask = 1, capture_mouse : bool = True, children : list[drawingItem] = [], handlers : list = [], max_side : float = inf, min_side : float = 0.0, next_sibling : baseItem | None = None, no_input : bool = False, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawInvisibleButton = ..., user_data : Any = ...):
        """
        button: Mouse button mask that makes the invisible button
            active and triggers the item's callback.
        capture_mouse: If set, the item will
            capture the mouse if hovered even if another
            item was already active.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        max_side: If the rectangle width or height after
            coordinate transform is higher than this,
            resize the screen space transformed coordinates
            such that the width/height are at max max_side.
            Retains original ratio.
        min_side: If the rectangle width or height after
            coordinate transform is lower than this,
            resize the screen space transformed coordinates
            such that the width/height are at least min_side.
            Retains original ratio.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: If enabled, this item will not
            detect hovering or activation, thus letting other
            items taking the inputs.
        p1: Corner of the invisible button in plot/drawing
            space
        p2: Opposite corner of the invisible button in plot/drawing
            space
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawInvisibleButton:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the button just been pressed
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the button held
        
        """
        ...


    @property
    def button(self) -> MouseButtonMask:
        """
        Mouse button mask that makes the invisible button
        active and triggers the item's callback.

        Default is left-click.

        The mask is an (OR) combination of
        1: left button
        2: right button
        4: middle button
        (See also MouseButtonMask)
        
        """
        ...


    @button.setter
    def button(self, value : MouseButtonMask):
        ...


    @property
    def capture_mouse(self) -> bool:
        """
        Writable attribute: If set, the item will
        capture the mouse if hovered even if another
        item was already active.

        As it is not in general a good behaviour (and
        will not behave well if several items with this
        state are overlapping),
        this is reset to False every frame.

        Default is True on creation. Thus creating an item
        in front of the mouse will capture it.
        
        """
        ...


    @capture_mouse.setter
    def capture_mouse(self, value : bool):
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the button just been unpressed
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside area
        
        """
        ...


    @property
    def max_side(self) -> float:
        """
        If the rectangle width or height after
        coordinate transform is higher than this,
        resize the screen space transformed coordinates
        such that the width/height are at max max_side.
        Retains original ratio.
        
        """
        ...


    @max_side.setter
    def max_side(self, value : float):
        ...


    @property
    def min_side(self) -> float:
        """
        If the rectangle width or height after
        coordinate transform is lower than this,
        resize the screen space transformed coordinates
        such that the width/height are at least min_side.
        Retains original ratio.
        
        """
        ...


    @min_side.setter
    def min_side(self, value : float):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_input(self) -> bool:
        """
        Writable attribute: If enabled, this item will not
        detect hovering or activation, thus letting other
        items taking the inputs.

        This is useful to use no_input - rather than show=False,
        if you want to still have handlers run if the item
        is in the visible region.
        
        """
        ...


    @no_input.setter
    def no_input(self, value : bool):
        ...


    @property
    def p1(self) -> list:
        """
        Corner of the invisible button in plot/drawing
        space
        
        """
        ...


    @p1.setter
    def p1(self, value : list):
        ...


    @property
    def p2(self) -> list:
        """
        Opposite corner of the invisible button in plot/drawing
        space
        
        """
        ...


    @p2.setter
    def p2(self, value : list):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Readonly attribute:
        Relative position to latest non-drawing parent
        
        """
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Readonly attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.
        
        """
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Readonly attribute:
        Relative position to the window's starting inner
        content area.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) in pixels of the item on screen
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawInvisibleButton:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawInvisibleButton):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawLine(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawLine = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawLine = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawLine:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> list:
        ...


    @p1.setter
    def p1(self, value : list):
        ...


    @property
    def p2(self) -> list:
        ...


    @p2.setter
    def p2(self, value : list):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawLine:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawLine):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawPolygon(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, points : list = [], previous_sibling : baseItem | None = None, show : bool = True, tag : DrawPolygon = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, points : list = [], previous_sibling : baseItem | None = None, show : bool = True, tag : DrawPolygon = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawPolygon:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @fill.setter
    def fill(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def points(self) -> list:
        ...


    @points.setter
    def points(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawPolygon:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawPolygon):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawPolyline(drawingItem):
    def __init__(self, context : Context, children : None  = [], closed : bool = False, color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, points : list = [], previous_sibling : baseItem | None = None, show : bool = True, tag : DrawPolyline = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], closed : bool = False, color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, points : list = [], previous_sibling : baseItem | None = None, show : bool = True, tag : DrawPolyline = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawPolyline:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def closed(self) -> bool:
        ...


    @closed.setter
    def closed(self, value : bool):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def points(self) -> list:
        ...


    @points.setter
    def points(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawPolyline:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawPolyline):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawQuad(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], p4 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawQuad = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], p4 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawQuad = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawQuad:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @fill.setter
    def fill(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> list:
        ...


    @p1.setter
    def p1(self, value : list):
        ...


    @property
    def p2(self) -> list:
        ...


    @p2.setter
    def p2(self, value : list):
        ...


    @property
    def p3(self) -> list:
        ...


    @p3.setter
    def p3(self, value : list):
        ...


    @property
    def p4(self) -> list:
        ...


    @p4.setter
    def p4(self, value : list):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawQuad:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawQuad):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawRect(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], color_bottom_left : list = [0.0, 0.0, 0.0, 0.0], color_bottom_right : list = [0.0, 0.0, 0.0, 0.0], color_upper_left : list = [0.0, 0.0, 0.0, 0.0], color_upper_right : list = [0.0, 0.0, 0.0, 0.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], multicolor : bool = False, next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : list = [1.0, 1.0], pmin : list = [0.0, 0.0], previous_sibling : baseItem | None = None, rounding : float = 0.0, show : bool = True, tag : DrawRect = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], color_bottom_left : list = [0.0, 0.0, 0.0, 0.0], color_bottom_right : list = [0.0, 0.0, 0.0, 0.0], color_upper_left : list = [0.0, 0.0, 0.0, 0.0], color_upper_right : list = [0.0, 0.0, 0.0, 0.0], fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], multicolor : bool = False, next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pmax : list = [1.0, 1.0], pmin : list = [0.0, 0.0], previous_sibling : baseItem | None = None, rounding : float = 0.0, show : bool = True, tag : DrawRect = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawRect:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def color_bottom_left(self) -> list:
        ...


    @color_bottom_left.setter
    def color_bottom_left(self, value : list):
        ...


    @property
    def color_bottom_right(self) -> list:
        ...


    @color_bottom_right.setter
    def color_bottom_right(self, value : list):
        ...


    @property
    def color_upper_left(self) -> list:
        ...


    @color_upper_left.setter
    def color_upper_left(self, value : list):
        ...


    @property
    def color_upper_right(self) -> list:
        ...


    @color_upper_right.setter
    def color_upper_right(self, value : list):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def fill(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @fill.setter
    def fill(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def multicolor(self) -> bool:
        ...


    @multicolor.setter
    def multicolor(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pmax(self) -> list:
        ...


    @pmax.setter
    def pmax(self, value : list):
        ...


    @property
    def pmin(self) -> list:
        ...


    @pmin.setter
    def pmin(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rounding(self) -> float:
        ...


    @rounding.setter
    def rounding(self, value : float):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawRect:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawRect):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawText(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], font : Font = None, next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pos : list = [0.0, 0.0], previous_sibling : baseItem | None = None, show : bool = True, size : float = 0.0, tag : DrawText = ..., text : str = "", user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        font: font used for the text rendered
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], font : Font = None, next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, pos : list = [0.0, 0.0], previous_sibling : baseItem | None = None, show : bool = True, size : float = 0.0, tag : DrawText = ..., text : str = "", user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        font: font used for the text rendered
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawText:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos(self) -> list:
        ...


    @pos.setter
    def pos(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def size(self) -> float:
        ...


    @size.setter
    def size(self, value : float):
        ...


    @property
    def tag(self) -> DrawText:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawText):
        ...


    @property
    def text(self) -> str:
        ...


    @text.setter
    def text(self, value : str):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawTriangle(drawingItem):
    def __init__(self, context : Context, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], cull_mode : int = 0, fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawTriangle = ..., thickness : float = 1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [1.0, 1.0, 1.0, 1.0], cull_mode : int = 0, fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = [0.0, 0.0, 0.0, 0.0], next_sibling : baseItem | None = None, p1 : list = [0.0, 0.0], p2 : list = [0.0, 0.0], p3 : list = [0.0, 0.0], parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawTriangle = ..., thickness : float = 1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawTriangle:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def cull_mode(self) -> int:
        ...


    @cull_mode.setter
    def cull_mode(self, value : int):
        ...


    @property
    def fill(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        ...


    @fill.setter
    def fill(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def p1(self) -> list:
        ...


    @p1.setter
    def p1(self, value : list):
        ...


    @property
    def p2(self) -> list:
        ...


    @p2.setter
    def p2(self, value : list):
        ...


    @property
    def p3(self) -> list:
        ...


    @p3.setter
    def p3(self, value : list):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawTriangle:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawTriangle):
        ...


    @property
    def thickness(self) -> float:
        ...


    @thickness.setter
    def thickness(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawingList(drawingItem):
    """
    A simple drawing item that renders its children.
    Useful to arrange your items and quickly
    hide/show/delete them by manipulating the list.
    
    """
    def __init__(self, context : Context, children : list[drawingItem] = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawingList = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[drawingItem] = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : DrawingList = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawingList:
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawingList:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawingList):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class DrawingListScale(drawingItem):
    """
    Similar to a DrawingList, but
    can apply shift and scale to the data
    
    """
    def __init__(self, context : Context, children : list[drawingItem] = [], next_sibling : baseItem | None = None, no_parent_scale : bool = False, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, scales : list = [1.0, 1.0], shifts : list = [0.0, 0.0], show : bool = True, tag : DrawingListScale = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_parent_scale: Resets any previous scaling to screen space.
            shifts are transformed to screen space using
            the parent transform and serves as origin (0, 0)
            for the child coordinates.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scales: Scales applied to the x and y axes
            Default is (1., 1.).
            The scales multiply any previous scales
            already set (including plot scales).
            Use no_parent_scale to remove that behaviour.
        shifts: Shifts applied to the x and y axes.
            Default is (0., 0.)
            The shifts are applied any previous
            shift and scale.
            For instance on x, the transformation to
            screen space is:
            parent_x_transform(x * scales[0] + shifts[0])
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[drawingItem] = [], next_sibling : baseItem | None = None, no_parent_scale : bool = False, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, scales : list = [1.0, 1.0], shifts : list = [0.0, 0.0], show : bool = True, tag : DrawingListScale = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_parent_scale: Resets any previous scaling to screen space.
            shifts are transformed to screen space using
            the parent transform and serves as origin (0, 0)
            for the child coordinates.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scales: Scales applied to the x and y axes
            Default is (1., 1.).
            The scales multiply any previous scales
            already set (including plot scales).
            Use no_parent_scale to remove that behaviour.
        shifts: Shifts applied to the x and y axes.
            Default is (0., 0.)
            The shifts are applied any previous
            shift and scale.
            For instance on x, the transformation to
            screen space is:
            parent_x_transform(x * scales[0] + shifts[0])
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> DrawingListScale:
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_parent_scale(self) -> bool:
        """
        Resets any previous scaling to screen space.
        shifts are transformed to screen space using
        the parent transform and serves as origin (0, 0)
        for the child coordinates.
        
        """
        ...


    @no_parent_scale.setter
    def no_parent_scale(self, value : bool):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def scales(self) -> list:
        """
        Scales applied to the x and y axes
        Default is (1., 1.).
        The scales multiply any previous scales
        already set (including plot scales).
        Use no_parent_scale to remove that behaviour.
        
        """
        ...


    @scales.setter
    def scales(self, value : list):
        ...


    @property
    def shifts(self) -> list:
        """
        Shifts applied to the x and y axes.
        Default is (0., 0.)
        The shifts are applied any previous
        shift and scale.
        For instance on x, the transformation to
        screen space is:
        parent_x_transform(x * scales[0] + shifts[0])
        
        """
        ...


    @shifts.setter
    def shifts(self, value : list):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> DrawingListScale:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : DrawingListScale):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class EditedHandler(baseHandler):
    """
    Handler to catch when a field is edited.
    Only the frames when a field is changed
    triggers the callback.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : EditedHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : EditedHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> EditedHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> EditedHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : EditedHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class FocusHandler(baseHandler):
    """
    Handler for windows or sub-windows that is called
    when they have focus, or for items when they
    have focus (for instance keyboard navigation,
    or editing a field).
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : FocusHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : FocusHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> FocusHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> FocusHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : FocusHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Font(baseItem):
    def __init__(self, context : Context, children : list[baseItem] = [], next_sibling : baseItem | None = None, no_scaling : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, scale : float = 1.0, size : Any = ..., tag : Font = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this font.
            The manual user-set scale is still applied.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        size: native height of characters
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[baseItem] = [], next_sibling : baseItem | None = None, no_scaling : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, scale : float = 1.0, size : Any = ..., tag : Font = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this font.
            The manual user-set scale is still applied.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        size: native height of characters
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Font:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this font.
        The manual user-set scale is still applied.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def scale(self) -> float:
        ...


    @scale.setter
    def scale(self, value : float):
        ...


    @property
    def size(self):
        """Readonly attribute: native height of characters
        """
        ...


    @size.setter
    def size(self, value):
        ...


    @property
    def tag(self) -> Font:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Font):
        ...


    @property
    def texture(self):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class FontTexture(baseItem):
    """
    Packs one or several fonts into
    a texture for internal use by ImGui.

    In order to have sharp fonts with various screen
    dpi scalings, two options are available:
    1) Handle scaling yourself:
        Whenever the global scale changes, make
        a new font using a scaled size, and
        set no_scaling to True
    2) Handle scaling yourself at init only:
        In most cases it is reasonnable to
        assume the dpi scale will not change.
        In that case the easiest is to check
        the viewport dpi scale after initialization,
        load the scaled font size, and then set
        font.scale to the inverse of the dpi scale.
        This will render at the intended size
        as long as the dpi scale is not changed,
        and will scale if it changes (but will be
        slightly blurry).

    Currently the default font uses option 2). Call
    fonts.make_extended_latin_font(your_size) and
    add_custom_font to get the default font at a different
    scale, and implement 1) or 2) yourself.
    
    """
    def __init__(self, context : Context, children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, tag : FontTexture = ..., texture : Any = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        texture: Readonly texture containing the font data.
            build() must be called first
        user_data: User data of any type.
        """
        ...


    def add_custom_font(self, font_height, character_images, character_Positioning):
        """
        See fonts.py for a detailed explanation of
        the input arguments.

        Currently add_custom_font calls build()
        and thus prevents adding new fonts, but
        this might not be true in the future, thus
        you should still call build().
        
        """
        ...


    def add_font_file(self, path, size=13.0, index_in_file=0, density_scale=1.0, align_to_pixel=False):
        """
        Prepare the target font file to be added to the FontTexture,
        using ImGui's font loader.

        path: path to the input font file (ttf, otf, etc).
        size: Target pixel size at which the font will be rendered by default.
        index_in_file: index of the target font in the font file.
        density_scale: rasterizer oversampling to better render when
            the font scale is not 1. Not a miracle solution though,
            as it causes blurry inputs if the actual scale used
            during rendering is less than density_scale.
        align_to_pixel: For sharp fonts, will prevent blur by
            aligning font rendering to the pixel. The spacing
            between characters might appear slightly odd as
            a result, so don't enable when not needed.
        
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def build(self):
        """
        Packs all the fonts appended with add_font_file
        into a readonly texture. 
        
        """
        ...


    def configure(self, children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, tag : FontTexture = ..., texture : Any = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        texture: Readonly texture containing the font data.
            build() must be called first
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> FontTexture:
        ...


    @property
    def built(self) -> bool:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> FontTexture:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : FontTexture):
        ...


    @property
    def texture(self):
        """
        Readonly texture containing the font data.
        build() must be called first
        
        """
        ...


    @texture.setter
    def texture(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class GotFocusHandler(baseHandler):
    """
    Handler for when windows or sub-windows get
    focus.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : GotFocusHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : GotFocusHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> GotFocusHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> GotFocusHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : GotFocusHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class GotHoverHandler(baseHandler):
    """
    Handler that calls the callback when
    the target item has just been hovered.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : GotHoverHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : GotHoverHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> GotHoverHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> GotHoverHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : GotHoverHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class GotRenderHandler(baseHandler):
    """
    Same as RenderHandler, but only calls the
    callback when the item switches from a
    non-rendered to a rendered state.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : GotRenderHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : GotRenderHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> GotRenderHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> GotRenderHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : GotRenderHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class HandlerList(baseHandler):
    """
    A list of handlers in order to attach several
    handlers to an item.
    In addition if you attach a callback to this handler,
    it will be issued if ALL or ANY of the children handler
    states are met. NONE is also possible.
    Note however that the handlers are not checked if an item
    is not rendered. This corresponds to the visible state.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, op : HandlerListOP = 0, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : HandlerList = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        op: HandlerListOP that defines which condition
            is required to trigger the callback of this
            handler.
            Default is ALL
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, op : HandlerListOP = 0, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : HandlerList = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        op: HandlerListOP that defines which condition
            is required to trigger the callback of this
            handler.
            Default is ALL
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> HandlerList:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> list[baseHandler]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseHandler]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def op(self) -> HandlerListOP:
        """
        HandlerListOP that defines which condition
        is required to trigger the callback of this
        handler.
        Default is ALL
        
        """
        ...


    @op.setter
    def op(self, value : HandlerListOP):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> HandlerList:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : HandlerList):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class HorizontalLayout(Layout):
    """
    A basic layout to organize the items
    horizontally.
    
    """
    def __init__(self, context : Context, alignment_mode : Alignment = 0, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), positions : list = [], previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : HorizontalLayout = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        alignment_mode: Horizontal alignment mode of the items.
            LEFT: items are appended from the left
            RIGHT: items are appended from the right
            CENTER: items are centered
            JUSTIFIED: spacing is organized such
            that items start at the left and end
            at the right.
            MANUAL: items are positionned at the requested
            positions
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the x position starting
            from the top left of this item at which to
            place the children items.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, alignment_mode : Alignment = 0, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), positions : list = [], previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : HorizontalLayout = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        alignment_mode: Horizontal alignment mode of the items.
            LEFT: items are appended from the left
            RIGHT: items are appended from the right
            CENTER: items are centered
            JUSTIFIED: spacing is organized such
            that items start at the left and end
            at the right.
            MANUAL: items are positionned at the requested
            positions
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the x position starting
            from the top left of this item at which to
            place the children items.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        ...


    def __enter__(self) -> HorizontalLayout:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def alignment_mode(self) -> Alignment:
        """
        Horizontal alignment mode of the items.
        LEFT: items are appended from the left
        RIGHT: items are appended from the right
        CENTER: items are centered
        JUSTIFIED: spacing is organized such
        that items start at the left and end
        at the right.
        MANUAL: items are positionned at the requested
        positions

        FOR LEFT/RIGHT/CENTER, ItemSpacing's style can
        be used to control spacing between the items.
        Default is LEFT.
        
        """
        ...


    @alignment_mode.setter
    def alignment_mode(self, value : Alignment):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def positions(self) -> list:
        """
        When in MANUAL mode, the x position starting
        from the top left of this item at which to
        place the children items.

        If the positions are between 0 and 1, they are
        interpreted as percentages relative to the
        size of the Layout width.
        If the positions are negatives, they are interpreted
        as in reference to the right of the layout rather
        than the left. Items are still left aligned to
        the target position though.

        Setting this field sets the alignment mode to
        MANUAL.
        
        """
        ...


    @positions.setter
    def positions(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> HorizontalLayout:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : HorizontalLayout):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class HoverHandler(baseHandler):
    """
    Handler that calls the callback when
    the target item is hovered.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : HoverHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : HoverHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> HoverHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> HoverHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : HoverHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Image(uiItem):
    def __init__(self, context : Context, border_color : list = [0.0, 0.0, 0.0, 0.0], callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Image = ..., texture : Any = ..., theme : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 1.0, 1.0], value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, border_color : list = [0.0, 0.0, 0.0, 0.0], callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Image = ..., texture : Any = ..., theme : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 1.0, 1.0], value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Image:
        ...


    @property
    def border_color(self) -> list:
        ...


    @border_color.setter
    def border_color(self, value : list):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def color_multiplier(self) -> list:
        ...


    @color_multiplier.setter
    def color_multiplier(self, value : list):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Image:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Image):
        ...


    @property
    def texture(self):
        ...


    @texture.setter
    def texture(self, value):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def uv(self) -> list:
        ...


    @uv.setter
    def uv(self, value : list):
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ImageButton(uiItem):
    def __init__(self, context : Context, background_color : list = [0.0, 0.0, 0.0, 0.0], callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], enabled : bool = True, focused : bool = False, font : Font = None, frame_padding : int = -1, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : ImageButton = ..., texture : Any = ..., theme : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 0.0, 0.0], value : bool = False, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, background_color : list = [0.0, 0.0, 0.0, 0.0], callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color_multiplier : list = [1.0, 1.0, 1.0, 1.0], enabled : bool = True, focused : bool = False, font : Font = None, frame_padding : int = -1, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : ImageButton = ..., texture : Any = ..., theme : Any = ..., user_data : Any = ..., uv : list = [0.0, 0.0, 0.0, 0.0], value : bool = False, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ImageButton:
        ...


    @property
    def background_color(self) -> list:
        ...


    @background_color.setter
    def background_color(self, value : list):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def color_multiplier(self) -> list:
        ...


    @color_multiplier.setter
    def color_multiplier(self, value : list):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def frame_padding(self) -> int:
        ...


    @frame_padding.setter
    def frame_padding(self, value : int):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ImageButton:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ImageButton):
        ...


    @property
    def texture(self):
        ...


    @texture.setter
    def texture(self, value):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def uv(self) -> list:
        ...


    @uv.setter
    def uv(self, value : list):
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class InputText(uiItem):
    def __init__(self, context : Context, always_overwrite : bool = False, auto_select_all : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], ctrl_enter_for_new_line : bool = False, decimal : bool = False, enabled : bool = True, escape_clears_all : bool = False, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, hexadecimal : bool = False, hint : str = "", indent : float = 0.0, label : str = "", max_characters : int = 1024, multiline : bool = False, next_sibling : baseItem | None = None, no_horizontal_scroll : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_spaces : bool = False, no_undo_redo : bool = False, on_enter : bool = False, parent : uiItem | plotElement | None = None, password : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, readonly : bool = False, scientific : bool = False, shareable_value : SharedStr = ..., show : bool = True, tab_input : bool = False, tag : InputText = ..., theme : Any = ..., uppercase : bool = False, user_data : Any = ..., value : str = "", width : int = 0):
        """

        always_overwrite: Overwrite mode
        auto_select_all: Select entire text when first taking mouse focus
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        ctrl_enter_for_new_line: In multi-line mode, validate with Enter,
            add new line with Ctrl+Enter
            (default is opposite: validate with Ctrl+Enter, add line with Enter).
        decimal: Allow 0123456789.+-
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        escape_clears_all: Escape key clears content if not empty,
            and deactivate otherwise
            (contrast to default behavior of Escape to revert)
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hexadecimal: Allow 0123456789ABCDEFabcdef
        hint: text hint.
            Doesn't work with multiline.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_characters: Maximal number of characters that can be written
        multiline: multiline text input.
            Doesn't work with non-empty hint.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_horizontal_scroll: Disable following the scroll horizontally
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_spaces: Filter out spaces, tabs
        no_undo_redo: Disable undo/redo.
        on_enter: Callback called everytime Enter is pressed,
            not just when the value is modified.
        parent: parent of the item in the rendering tree.
        password: Password mode, display all characters as '*', disable copy
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        readonly: Read-only mode
        scientific: Allow 0123456789.+-*/eE
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tab_input: Pressing TAB input a '	' character into the text field
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        uppercase: Turn a..z into A..Z
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_overwrite : bool = False, auto_select_all : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], ctrl_enter_for_new_line : bool = False, decimal : bool = False, enabled : bool = True, escape_clears_all : bool = False, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, hexadecimal : bool = False, hint : str = "", indent : float = 0.0, label : str = "", max_characters : int = 1024, multiline : bool = False, next_sibling : baseItem | None = None, no_horizontal_scroll : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_spaces : bool = False, no_undo_redo : bool = False, on_enter : bool = False, parent : uiItem | plotElement | None = None, password : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, readonly : bool = False, scientific : bool = False, shareable_value : SharedStr = ..., show : bool = True, tab_input : bool = False, tag : InputText = ..., theme : Any = ..., uppercase : bool = False, user_data : Any = ..., value : str = "", width : int = 0):
        """
        always_overwrite: Overwrite mode
        auto_select_all: Select entire text when first taking mouse focus
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        ctrl_enter_for_new_line: In multi-line mode, validate with Enter,
            add new line with Ctrl+Enter
            (default is opposite: validate with Ctrl+Enter, add line with Enter).
        decimal: Allow 0123456789.+-
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        escape_clears_all: Escape key clears content if not empty,
            and deactivate otherwise
            (contrast to default behavior of Escape to revert)
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hexadecimal: Allow 0123456789ABCDEFabcdef
        hint: text hint.
            Doesn't work with multiline.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_characters: Maximal number of characters that can be written
        multiline: multiline text input.
            Doesn't work with non-empty hint.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_horizontal_scroll: Disable following the scroll horizontally
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_spaces: Filter out spaces, tabs
        no_undo_redo: Disable undo/redo.
        on_enter: Callback called everytime Enter is pressed,
            not just when the value is modified.
        parent: parent of the item in the rendering tree.
        password: Password mode, display all characters as '*', disable copy
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        readonly: Read-only mode
        scientific: Allow 0123456789.+-*/eE
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tab_input: Pressing TAB input a '	' character into the text field
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        uppercase: Turn a..z into A..Z
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> InputText:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def always_overwrite(self) -> bool:
        """
        Writable attribute: Overwrite mode
        
        """
        ...


    @always_overwrite.setter
    def always_overwrite(self, value : bool):
        ...


    @property
    def auto_select_all(self) -> bool:
        """
        Writable attribute: Select entire text when first taking mouse focus
        
        """
        ...


    @auto_select_all.setter
    def auto_select_all(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def ctrl_enter_for_new_line(self) -> bool:
        """
        Writable attribute: In multi-line mode, validate with Enter,
        add new line with Ctrl+Enter
        (default is opposite: validate with Ctrl+Enter, add line with Enter).
        
        """
        ...


    @ctrl_enter_for_new_line.setter
    def ctrl_enter_for_new_line(self, value : bool):
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def decimal(self) -> bool:
        """
        Writable attribute: Allow 0123456789.+-
        
        """
        ...


    @decimal.setter
    def decimal(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def escape_clears_all(self) -> bool:
        """
        Writable attribute: Escape key clears content if not empty,
        and deactivate otherwise
        (contrast to default behavior of Escape to revert)
        
        """
        ...


    @escape_clears_all.setter
    def escape_clears_all(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hexadecimal(self) -> bool:
        """
        Writable attribute:  Allow 0123456789ABCDEFabcdef
        
        """
        ...


    @hexadecimal.setter
    def hexadecimal(self, value : bool):
        ...


    @property
    def hint(self) -> str:
        """
        Writable attribute: text hint.
        Doesn't work with multiline.
        
        """
        ...


    @hint.setter
    def hint(self, value : str):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def max_characters(self) -> int:
        """
        Writable attribute: Maximal number of characters that can be written
        
        """
        ...


    @max_characters.setter
    def max_characters(self, value : int):
        ...


    @property
    def multiline(self) -> bool:
        """
        Writable attribute: multiline text input.
        Doesn't work with non-empty hint.
        
        """
        ...


    @multiline.setter
    def multiline(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_horizontal_scroll(self) -> bool:
        """
        Writable attribute: Disable following the scroll horizontally
        
        """
        ...


    @no_horizontal_scroll.setter
    def no_horizontal_scroll(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_spaces(self) -> bool:
        """
        Writable attribute: Filter out spaces, tabs
        
        """
        ...


    @no_spaces.setter
    def no_spaces(self, value : bool):
        ...


    @property
    def no_undo_redo(self) -> bool:
        """
        Writable attribute: Disable undo/redo.
        
        """
        ...


    @no_undo_redo.setter
    def no_undo_redo(self, value : bool):
        ...


    @property
    def on_enter(self) -> bool:
        """
        Writable attribute: Callback called everytime Enter is pressed,
        not just when the value is modified.
        
        """
        ...


    @on_enter.setter
    def on_enter(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def password(self) -> bool:
        """
        Writable attribute: Password mode, display all characters as '*', disable copy
        
        """
        ...


    @password.setter
    def password(self, value : bool):
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def readonly(self) -> bool:
        """
        Writable attribute: Read-only mode
        
        """
        ...


    @readonly.setter
    def readonly(self, value : bool):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scientific(self) -> bool:
        """
        Writable attribute: Allow 0123456789.+-*/eE
        
        """
        ...


    @scientific.setter
    def scientific(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tab_input(self) -> bool:
        """
        Writable attribute: Pressing TAB input a '	' character into the text field
        
        """
        ...


    @tab_input.setter
    def tab_input(self, value : bool):
        ...


    @property
    def tag(self) -> InputText:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : InputText):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def uppercase(self) -> bool:
        """
        Writable attribute: Turn a..z into A..Z
        
        """
        ...


    @uppercase.setter
    def uppercase(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class InputValue(uiItem):
    def __init__(self, context : Context, always_overwrite : bool = False, auto_select_all : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], decimal : bool = False, empty_as_zero : bool = False, empty_if_zero : bool = False, enabled : bool = True, escape_clears_all : bool = False, focused : bool = False, font : Font = None, format : str = "float", handlers : list = [], height : int = 0, hexadecimal : bool = False, indent : float = 0.0, label : str = "", max_value : float = inf, min_value : float = -inf, next_sibling : baseItem | None = None, no_horizontal_scroll : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_undo_redo : bool = False, on_enter : bool = False, parent : uiItem | plotElement | None = None, password : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, print_format : str = "%.3f", readonly : bool = False, scientific : bool = False, shareable_value : SharedFloat = ..., show : bool = True, size : int = 1, step : float = 0.1, step_fast : float = 1.0, tag : InputValue = ..., theme : Any = ..., user_data : Any = ..., value : float = 0.0, width : int = 0):
        """

        always_overwrite: Overwrite mode
        auto_select_all: Select entire text when first taking mouse focus
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        decimal: Allow 0123456789.+-
        empty_as_zero: parse empty string as zero value
        empty_if_zero: when value is zero, do not display it
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        escape_clears_all: Escape key clears content if not empty,
            and deactivate otherwise
            (contrast to default behavior of Escape to revert)
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        format: Format of the slider.
            Must be "int", "float" or "double".
            Note that float here means the 32 bits version.
            The python float corresponds to a double.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hexadecimal: Allow 0123456789ABCDEFabcdef
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_value: Maximum value the input
            will be clamped to.
        min_value: Minimum value the input
            will be clamped to.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_horizontal_scroll: Disable following the scroll horizontally
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_undo_redo: Disable undo/redo.
        on_enter: Callback called everytime Enter is pressed,
            not just when the value is modified.
        parent: parent of the item in the rendering tree.
        password: Password mode, display all characters as '*', disable copy
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        print_format: format string
            for the value -> string conversion
            for display. If round_to_format is
            enabled, the value is converted
            back and thus appears rounded.
        readonly: Read-only mode
        scientific: Allow 0123456789.+-*/eE
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Size of the slider.
            Can be 1, 2, 3 or 4.
            When 1 the item's value is held with
            a scalar shared value, else it is held
            with a vector of 4 elements (even for
            size 2 and 3)
        step: 
        step_fast: 
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_overwrite : bool = False, auto_select_all : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], decimal : bool = False, empty_as_zero : bool = False, empty_if_zero : bool = False, enabled : bool = True, escape_clears_all : bool = False, focused : bool = False, font : Font = None, format : str = "float", handlers : list = [], height : int = 0, hexadecimal : bool = False, indent : float = 0.0, label : str = "", max_value : float = inf, min_value : float = -inf, next_sibling : baseItem | None = None, no_horizontal_scroll : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_undo_redo : bool = False, on_enter : bool = False, parent : uiItem | plotElement | None = None, password : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, print_format : str = "%.3f", readonly : bool = False, scientific : bool = False, shareable_value : SharedFloat = ..., show : bool = True, size : int = 1, step : float = 0.1, step_fast : float = 1.0, tag : InputValue = ..., theme : Any = ..., user_data : Any = ..., value : float = 0.0, width : int = 0):
        """
        always_overwrite: Overwrite mode
        auto_select_all: Select entire text when first taking mouse focus
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        decimal: Allow 0123456789.+-
        empty_as_zero: parse empty string as zero value
        empty_if_zero: when value is zero, do not display it
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        escape_clears_all: Escape key clears content if not empty,
            and deactivate otherwise
            (contrast to default behavior of Escape to revert)
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        format: Format of the slider.
            Must be "int", "float" or "double".
            Note that float here means the 32 bits version.
            The python float corresponds to a double.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hexadecimal: Allow 0123456789ABCDEFabcdef
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_value: Maximum value the input
            will be clamped to.
        min_value: Minimum value the input
            will be clamped to.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_horizontal_scroll: Disable following the scroll horizontally
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_undo_redo: Disable undo/redo.
        on_enter: Callback called everytime Enter is pressed,
            not just when the value is modified.
        parent: parent of the item in the rendering tree.
        password: Password mode, display all characters as '*', disable copy
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        print_format: format string
            for the value -> string conversion
            for display. If round_to_format is
            enabled, the value is converted
            back and thus appears rounded.
        readonly: Read-only mode
        scientific: Allow 0123456789.+-*/eE
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Size of the slider.
            Can be 1, 2, 3 or 4.
            When 1 the item's value is held with
            a scalar shared value, else it is held
            with a vector of 4 elements (even for
            size 2 and 3)
        step: 
        step_fast: 
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> InputValue:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def always_overwrite(self) -> bool:
        """
        Writable attribute: Overwrite mode
        
        """
        ...


    @always_overwrite.setter
    def always_overwrite(self, value : bool):
        ...


    @property
    def auto_select_all(self) -> bool:
        """
        Writable attribute: Select entire text when first taking mouse focus
        
        """
        ...


    @auto_select_all.setter
    def auto_select_all(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def decimal(self) -> bool:
        """
        Writable attribute: Allow 0123456789.+-
        
        """
        ...


    @decimal.setter
    def decimal(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def empty_as_zero(self) -> bool:
        """
        Writable attribute: parse empty string as zero value
        
        """
        ...


    @empty_as_zero.setter
    def empty_as_zero(self, value : bool):
        ...


    @property
    def empty_if_zero(self) -> bool:
        """
        Writable attribute: when value is zero, do not display it
        
        """
        ...


    @empty_if_zero.setter
    def empty_if_zero(self, value : bool):
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def escape_clears_all(self) -> bool:
        """
        Writable attribute: Escape key clears content if not empty,
        and deactivate otherwise
        (contrast to default behavior of Escape to revert)
        
        """
        ...


    @escape_clears_all.setter
    def escape_clears_all(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def format(self) -> str:
        """
        Writable attribute: Format of the slider.
        Must be "int", "float" or "double".
        Note that float here means the 32 bits version.
        The python float corresponds to a double.
        
        """
        ...


    @format.setter
    def format(self, value : str):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hexadecimal(self) -> bool:
        """
        Writable attribute:  Allow 0123456789ABCDEFabcdef
        
        """
        ...


    @hexadecimal.setter
    def hexadecimal(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def max_value(self) -> float:
        """
        Writable attribute: Maximum value the input
        will be clamped to.
        
        """
        ...


    @max_value.setter
    def max_value(self, value : float):
        ...


    @property
    def min_value(self) -> float:
        """
        Writable attribute: Minimum value the input
        will be clamped to.
        
        """
        ...


    @min_value.setter
    def min_value(self, value : float):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_horizontal_scroll(self) -> bool:
        """
        Writable attribute: Disable following the scroll horizontally
        
        """
        ...


    @no_horizontal_scroll.setter
    def no_horizontal_scroll(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_undo_redo(self) -> bool:
        """
        Writable attribute: Disable undo/redo.
        
        """
        ...


    @no_undo_redo.setter
    def no_undo_redo(self, value : bool):
        ...


    @property
    def on_enter(self) -> bool:
        """
        Writable attribute: Callback called everytime Enter is pressed,
        not just when the value is modified.
        
        """
        ...


    @on_enter.setter
    def on_enter(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def password(self) -> bool:
        """
        Writable attribute: Password mode, display all characters as '*', disable copy
        
        """
        ...


    @password.setter
    def password(self, value : bool):
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def print_format(self) -> str:
        """
        Writable attribute: format string
        for the value -> string conversion
        for display. If round_to_format is
        enabled, the value is converted
        back and thus appears rounded.
        
        """
        ...


    @print_format.setter
    def print_format(self, value : str):
        ...


    @property
    def readonly(self) -> bool:
        """
        Writable attribute: Read-only mode
        
        """
        ...


    @readonly.setter
    def readonly(self, value : bool):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scientific(self) -> bool:
        """
        Writable attribute: Allow 0123456789.+-*/eE
        
        """
        ...


    @scientific.setter
    def scientific(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedFloat:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedFloat):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def size(self) -> int:
        """
        Writable attribute: Size of the slider.
        Can be 1, 2, 3 or 4.
        When 1 the item's value is held with
        a scalar shared value, else it is held
        with a vector of 4 elements (even for
        size 2 and 3)
        
        """
        ...


    @size.setter
    def size(self, value : int):
        ...


    @property
    def step(self) -> float:
        """
        Writable attribute: 
        
        """
        ...


    @step.setter
    def step(self, value : float):
        ...


    @property
    def step_fast(self) -> float:
        """
        Writable attribute: 
        
        """
        ...


    @step_fast.setter
    def step_fast(self, value : float):
        ...


    @property
    def tag(self) -> InputValue:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : InputValue):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> float:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : float):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ItemInspecter(Window):
    def __init__(self, context: dearcygui.core.Context, width=0, height=0, context : Context, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, autosize : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem, MenuBar] = ..., collapsed : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], has_close_button : bool = True, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", max_size : tuple = (30000, 30000), menubar : bool = False, min_size : tuple = (100, 100), modal : bool = False, next_sibling : baseItem | None = None, no_background : bool = False, no_bring_to_front_on_focus : bool = False, no_collapse : bool = False, no_focus_on_appearing : bool = False, no_keyboard_inputs : bool = False, no_mouse_inputs : bool = False, no_move : bool = False, no_newline : float = 0.0, no_open_over_existing_popup : bool = True, no_resize : bool = False, no_saved_settings : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, no_title_bar : bool = False, on_close : Any = ..., parent : Viewport | None = None, popup : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, primary : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : ItemInspecter = ..., theme : Any = ..., unsaved_document : bool = False, user_data : Any = ..., value : Any = ...):
        """
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        autosize: Writable attribute to tell the window should
               automatically resize to fit its content
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        collapsed: Writable attribute to collapse (~minimize) or uncollapse the window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        has_close_button: Writable attribute to indicate the window has a close button.
            Has effect only for normal and modal windows.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_size: Writable attribute to indicate the maximum window size
        menubar: Writable attribute to indicate whether the window has a menu bar.
        min_size: Writable attribute to indicate the minimum window size
        modal: Writable attribute to indicate the window is a modal window.
            Modal windows are similar to popup windows, but they have a close
            button and are not closed by clicking outside.
            Clicking has no effect of items outside the modal window until it is closed.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_background: Writable attribute to disable drawing background
            color and outside border
        no_bring_to_front_on_focus: Writable attribute to indicate when the window takes focus (click on it, etc)
            it shouldn't be shown in front of other windows
        no_collapse: Writable attribute to disable user collapsing window by double-clicking on it
        no_focus_on_appearing: Writable attribute to indicate when the windows moves from
            an un-shown to a shown item shouldn't be made automatically
            focused
        no_keyboard_inputs: Writable attribute to disable keyboard manipulation (scroll).
            The window will not take focus of the keyboard.
            Does not affect items inside the window.
        no_mouse_inputs: Writable attribute to disable mouse input event catching of the window.
            Events such as clicked, hovering, etc will be passed to items behind the
            window.
        no_move: Writable attribute the window to be move with interactions
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_open_over_existing_popup: Writable attribute for modal and popup windows to prevent them from
            showing if there is already an existing popup/modal window
        no_resize: Writable attribute to block resizing
        no_saved_settings: Writable attribute to never load/save settings in .ini file
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: Writable attribute to indicate the mouse wheel
               should have no effect on scrolling of this window
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        no_title_bar: Writable attribute to disable the title-bar
        on_close: Callback to call when the window is closed.
            Note closing the window does not destroy or unattach the item.
            Instead it is switched to a show=False state.
        parent: parent of the item in the rendering tree.
        popup: Writable attribute to indicate the window is a popup window.
            Popup windows are centered (unless a pos is set), do not have a
            close button, and are closed when they lose focus (clicking outside the
            window).
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        primary: Indicate if the window is the primary window.
            There is maximum one primary window. The primary window covers the whole
            viewport and can be used to draw on the background.
            It is equivalent to setting:
            no_bring_to_front_on_focus
            no_saved_settings
            no_resize
            no_collapse
            no_title_bar
            and running item.focused = True on all the other windows
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        unsaved_document: Writable attribute to display a dot next to the title, as if the window
            contains unsaved changes.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, autosize : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem, MenuBar] = ..., collapsed : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], has_close_button : bool = True, height : int = 0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", max_size : tuple = (30000, 30000), menubar : bool = False, min_size : tuple = (100, 100), modal : bool = False, next_sibling : baseItem | None = None, no_background : bool = False, no_bring_to_front_on_focus : bool = False, no_collapse : bool = False, no_focus_on_appearing : bool = False, no_keyboard_inputs : bool = False, no_mouse_inputs : bool = False, no_move : bool = False, no_newline : float = 0.0, no_open_over_existing_popup : bool = True, no_resize : bool = False, no_saved_settings : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, no_title_bar : bool = False, on_close : Any = ..., parent : Viewport | None = None, popup : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, primary : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : ItemInspecter = ..., theme : Any = ..., unsaved_document : bool = False, user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        autosize: Writable attribute to tell the window should
               automatically resize to fit its content
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        collapsed: Writable attribute to collapse (~minimize) or uncollapse the window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        has_close_button: Writable attribute to indicate the window has a close button.
            Has effect only for normal and modal windows.
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_size: Writable attribute to indicate the maximum window size
        menubar: Writable attribute to indicate whether the window has a menu bar.
        min_size: Writable attribute to indicate the minimum window size
        modal: Writable attribute to indicate the window is a modal window.
            Modal windows are similar to popup windows, but they have a close
            button and are not closed by clicking outside.
            Clicking has no effect of items outside the modal window until it is closed.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_background: Writable attribute to disable drawing background
            color and outside border
        no_bring_to_front_on_focus: Writable attribute to indicate when the window takes focus (click on it, etc)
            it shouldn't be shown in front of other windows
        no_collapse: Writable attribute to disable user collapsing window by double-clicking on it
        no_focus_on_appearing: Writable attribute to indicate when the windows moves from
            an un-shown to a shown item shouldn't be made automatically
            focused
        no_keyboard_inputs: Writable attribute to disable keyboard manipulation (scroll).
            The window will not take focus of the keyboard.
            Does not affect items inside the window.
        no_mouse_inputs: Writable attribute to disable mouse input event catching of the window.
            Events such as clicked, hovering, etc will be passed to items behind the
            window.
        no_move: Writable attribute the window to be move with interactions
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_open_over_existing_popup: Writable attribute for modal and popup windows to prevent them from
            showing if there is already an existing popup/modal window
        no_resize: Writable attribute to block resizing
        no_saved_settings: Writable attribute to never load/save settings in .ini file
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: Writable attribute to indicate the mouse wheel
               should have no effect on scrolling of this window
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        no_title_bar: Writable attribute to disable the title-bar
        on_close: Callback to call when the window is closed.
            Note closing the window does not destroy or unattach the item.
            Instead it is switched to a show=False state.
        parent: parent of the item in the rendering tree.
        popup: Writable attribute to indicate the window is a popup window.
            Popup windows are centered (unless a pos is set), do not have a
            close button, and are closed when they lose focus (clicking outside the
            window).
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        primary: Indicate if the window is the primary window.
            There is maximum one primary window. The primary window covers the whole
            viewport and can be used to draw on the background.
            It is equivalent to setting:
            no_bring_to_front_on_focus
            no_saved_settings
            no_resize
            no_collapse
            no_title_bar
            and running item.focused = True on all the other windows
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        unsaved_document: Writable attribute to display a dot next to the title, as if the window
            contains unsaved changes.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ItemInspecter:
        ...


    @property
    def always_show_horizontal_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a horizontal scrollbar
        even when the size does not require it (only if horizontal scrollbar
        are enabled)
        
        """
        ...


    @always_show_horizontal_scrollvar.setter
    def always_show_horizontal_scrollvar(self, value : bool):
        ...


    @property
    def always_show_vertical_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a vertical scrollbar
        even when the size does not require it
        
        """
        ...


    @always_show_vertical_scrollvar.setter
    def always_show_vertical_scrollvar(self, value : bool):
        ...


    @property
    def autosize(self) -> bool:
        """Writable attribute to tell the window should
           automatically resize to fit its content
        
        """
        ...


    @autosize.setter
    def autosize(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem, MenuBar]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem, MenuBar]):
        ...


    @property
    def collapsed(self) -> bool:
        """
        Writable attribute to collapse (~minimize) or uncollapse the window
        
        """
        ...


    @collapsed.setter
    def collapsed(self, value : bool):
        ...


    @property
    def content_region_avail(self) -> tuple:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def has_close_button(self) -> bool:
        """
        Writable attribute to indicate the window has a close button.
        Has effect only for normal and modal windows.
        
        """
        ...


    @has_close_button.setter
    def has_close_button(self, value : bool):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def horizontal_scrollbar(self) -> bool:
        """
        Writable attribute to enable having an horizontal scrollbar
        
        """
        ...


    @horizontal_scrollbar.setter
    def horizontal_scrollbar(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def max_size(self) -> tuple:
        """
        Writable attribute to indicate the maximum window size
        
        """
        ...


    @max_size.setter
    def max_size(self, value : tuple):
        ...


    @property
    def menubar(self) -> bool:
        """
        Writable attribute to indicate whether the window has a menu bar.

        There will be menubar if either the user has asked for it,
        or there is a menubar child.
        
        """
        ...


    @menubar.setter
    def menubar(self, value : bool):
        ...


    @property
    def min_size(self) -> tuple:
        """
        Writable attribute to indicate the minimum window size
        
        """
        ...


    @min_size.setter
    def min_size(self, value : tuple):
        ...


    @property
    def modal(self) -> bool:
        """
        Writable attribute to indicate the window is a modal window.
        Modal windows are similar to popup windows, but they have a close
        button and are not closed by clicking outside.
        Clicking has no effect of items outside the modal window until it is closed.
        
        """
        ...


    @modal.setter
    def modal(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_background(self) -> bool:
        """
        Writable attribute to disable drawing background
        color and outside border
        
        """
        ...


    @no_background.setter
    def no_background(self, value : bool):
        ...


    @property
    def no_bring_to_front_on_focus(self) -> bool:
        """
        Writable attribute to indicate when the window takes focus (click on it, etc)
        it shouldn't be shown in front of other windows
        
        """
        ...


    @no_bring_to_front_on_focus.setter
    def no_bring_to_front_on_focus(self, value : bool):
        ...


    @property
    def no_collapse(self) -> bool:
        """Writable attribute to disable user collapsing window by double-clicking on it
        
        """
        ...


    @no_collapse.setter
    def no_collapse(self, value : bool):
        ...


    @property
    def no_focus_on_appearing(self) -> bool:
        """
        Writable attribute to indicate when the windows moves from
        an un-shown to a shown item shouldn't be made automatically
        focused
        
        """
        ...


    @no_focus_on_appearing.setter
    def no_focus_on_appearing(self, value : bool):
        ...


    @property
    def no_keyboard_inputs(self) -> bool:
        """
        Writable attribute to disable keyboard manipulation (scroll).
        The window will not take focus of the keyboard.
        Does not affect items inside the window.
        
        """
        ...


    @no_keyboard_inputs.setter
    def no_keyboard_inputs(self, value : bool):
        ...


    @property
    def no_mouse_inputs(self) -> bool:
        """
        Writable attribute to disable mouse input event catching of the window.
        Events such as clicked, hovering, etc will be passed to items behind the
        window.
        
        """
        ...


    @no_mouse_inputs.setter
    def no_mouse_inputs(self, value : bool):
        ...


    @property
    def no_move(self) -> bool:
        """Writable attribute the window to be move with interactions
        """
        ...


    @no_move.setter
    def no_move(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_open_over_existing_popup(self) -> bool:
        """
        Writable attribute for modal and popup windows to prevent them from
        showing if there is already an existing popup/modal window
        
        """
        ...


    @no_open_over_existing_popup.setter
    def no_open_over_existing_popup(self, value : bool):
        ...


    @property
    def no_resize(self) -> bool:
        """Writable attribute to block resizing
        """
        ...


    @no_resize.setter
    def no_resize(self, value : bool):
        ...


    @property
    def no_saved_settings(self) -> bool:
        """
        Writable attribute to never load/save settings in .ini file
        
        """
        ...


    @no_saved_settings.setter
    def no_saved_settings(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_scroll_with_mouse(self) -> bool:
        """Writable attribute to indicate the mouse wheel
           should have no effect on scrolling of this window
        
        """
        ...


    @no_scroll_with_mouse.setter
    def no_scroll_with_mouse(self, value : bool):
        ...


    @property
    def no_scrollbar(self) -> bool:
        """Writable attribute to indicate the window should have no scrollbar
           Does not disable scrolling via mouse or keyboard
        
        """
        ...


    @no_scrollbar.setter
    def no_scrollbar(self, value : bool):
        ...


    @property
    def no_title_bar(self) -> bool:
        """Writable attribute to disable the title-bar
        """
        ...


    @no_title_bar.setter
    def no_title_bar(self, value : bool):
        ...


    @property
    def on_close(self):
        """
        Callback to call when the window is closed.
        Note closing the window does not destroy or unattach the item.
        Instead it is switched to a show=False state.
        
        """
        ...


    @on_close.setter
    def on_close(self, value):
        ...


    @property
    def parent(self) -> Viewport | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Viewport | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def popup(self) -> bool:
        """
        Writable attribute to indicate the window is a popup window.
        Popup windows are centered (unless a pos is set), do not have a
        close button, and are closed when they lose focus (clicking outside the
        window).
        
        """
        ...


    @popup.setter
    def popup(self, value : bool):
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def primary(self) -> bool:
        """
        Writable attribute: Indicate if the window is the primary window.
        There is maximum one primary window. The primary window covers the whole
        viewport and can be used to draw on the background.
        It is equivalent to setting:
        no_bring_to_front_on_focus
        no_saved_settings
        no_resize
        no_collapse
        no_title_bar
        and running item.focused = True on all the other windows
        
        """
        ...


    @primary.setter
    def primary(self, value : bool):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ItemInspecter:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ItemInspecter):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def unsaved_document(self) -> bool:
        """
        Writable attribute to display a dot next to the title, as if the window
        contains unsaved changes.
        
        """
        ...


    @unsaved_document.setter
    def unsaved_document(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class KeyDownHandler(baseHandler):
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : int = 0, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : KeyDownHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : int = 0, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : KeyDownHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> KeyDownHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def key(self) -> int:
        ...


    @key.setter
    def key(self, value : int):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> KeyDownHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : KeyDownHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class KeyPressHandler(baseHandler):
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : int = 0, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, repeat : bool = True, show : bool = True, tag : KeyPressHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : int = 0, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, repeat : bool = True, show : bool = True, tag : KeyPressHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> KeyPressHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def key(self) -> int:
        ...


    @key.setter
    def key(self, value : int):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def repeat(self) -> bool:
        ...


    @repeat.setter
    def repeat(self, value : bool):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> KeyPressHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : KeyPressHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class KeyReleaseHandler(baseHandler):
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : int = 0, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : KeyReleaseHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, key : int = 0, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : KeyReleaseHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> KeyReleaseHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def key(self) -> int:
        ...


    @key.setter
    def key(self, value : int):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> KeyReleaseHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : KeyReleaseHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Layout(uiItem):
    """
    A layout is a group of elements organized
    together.
    The layout states correspond to the OR
    of all the item states, and the rect size
    corresponds to the minimum rect containing
    all the items. The position of the layout
    is used to initialize the default position
    for the first item.
    For example setting indent will shift all
    the items of the Layout.

    Subclassing Layout:
    For custom layouts, you can use Layout with
    a callback. The callback is called whenever
    the layout should be updated.

    If the automated update detection is not
    sufficient, update_layout() can be called
    to force a recomputation of the layout.

    Currently the update detection detects a change in
    the size of the remaining content area available
    locally within the window, or if the last item has changed.

    The layout item works by changing the positioning
    policy and the target position of its children, and
    thus there is no guarantee that the user set
    positioning and position states of the children are
    preserved.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Layout = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Layout = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        ...


    def __enter__(self) -> Layout:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Layout:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Layout):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ListBox(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, num_items_shown_when_open : int = -1, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedStr = ..., show : bool = True, tag : ListBox = ..., theme : Any = ..., user_data : Any = ..., value : str = "", width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        num_items_shown_when_open: Number of items
            shown when the menu is opened
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, num_items_shown_when_open : int = -1, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedStr = ..., show : bool = True, tag : ListBox = ..., theme : Any = ..., user_data : Any = ..., value : str = "", width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        num_items_shown_when_open: Number of items
            shown when the menu is opened
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ListBox:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def items(self) -> list:
        """
        Writable attribute: List of text values to select
        
        """
        ...


    @items.setter
    def items(self, value : list):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def num_items_shown_when_open(self) -> int:
        """
        Writable attribute: Number of items
        shown when the menu is opened
        
        """
        ...


    @num_items_shown_when_open.setter
    def num_items_shown_when_open(self, value : int):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ListBox:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ListBox):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class LostFocusHandler(baseHandler):
    """
    Handler for when windows or sub-windows lose
    focus.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : LostFocusHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : LostFocusHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> LostFocusHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> LostFocusHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : LostFocusHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class LostHoverHandler(baseHandler):
    """
    Handler that calls the callback the first
    frame when the target item was hovered, but
    is not anymore.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : LostHoverHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : LostHoverHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> LostHoverHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> LostHoverHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : LostHoverHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class LostRenderHandler(baseHandler):
    """
    Handler that only calls the
    callback when the item switches from a
    rendered to non-rendered state. Note
    that when an item is not rendered, subsequent
    frames will not run handlers. Only the first time
    an item is non-rendered will trigger the handlers.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : LostRenderHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : LostRenderHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> LostRenderHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> LostRenderHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : LostRenderHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Menu(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : Menu = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : Menu = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Menu:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Menu:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Menu):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class MenuBar(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : MenuBar = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : MenuBar = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MenuBar:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_region_avail(self) -> tuple:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MenuBar:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MenuBar):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class MenuItem(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], check : bool = False, children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., shortcut : str = "", show : bool = True, tag : MenuItem = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        check: 
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        shortcut: 
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], check : bool = False, children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., shortcut : str = "", show : bool = True, tag : MenuItem = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        check: 
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        shortcut: 
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MenuItem:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def check(self) -> bool:
        """
        Writable attribute:
        
        """
        ...


    @check.setter
    def check(self, value : bool):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def shortcut(self) -> str:
        """
        Writable attribute:
        
        """
        ...


    @shortcut.setter
    def shortcut(self, value : str):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MenuItem:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MenuItem):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class MetricsWindow(Window):
    def __init__(self, context: dearcygui.core.Context, width=0, height=0, context : Context, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, autosize : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem, MenuBar] = ..., collapsed : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], has_close_button : bool = True, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", max_size : tuple = (30000, 30000), menubar : bool = False, min_size : tuple = (100, 100), modal : bool = False, next_sibling : baseItem | None = None, no_background : bool = False, no_bring_to_front_on_focus : bool = False, no_collapse : bool = False, no_focus_on_appearing : bool = False, no_keyboard_inputs : bool = False, no_mouse_inputs : bool = False, no_move : bool = False, no_newline : float = 0.0, no_open_over_existing_popup : bool = True, no_resize : bool = False, no_saved_settings : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, no_title_bar : bool = False, on_close : Any = ..., parent : Viewport | None = None, popup : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, primary : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : MetricsWindow = ..., theme : Any = ..., unsaved_document : bool = False, user_data : Any = ..., value : Any = ...):
        """
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        autosize: Writable attribute to tell the window should
               automatically resize to fit its content
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        collapsed: Writable attribute to collapse (~minimize) or uncollapse the window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        has_close_button: Writable attribute to indicate the window has a close button.
            Has effect only for normal and modal windows.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_size: Writable attribute to indicate the maximum window size
        menubar: Writable attribute to indicate whether the window has a menu bar.
        min_size: Writable attribute to indicate the minimum window size
        modal: Writable attribute to indicate the window is a modal window.
            Modal windows are similar to popup windows, but they have a close
            button and are not closed by clicking outside.
            Clicking has no effect of items outside the modal window until it is closed.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_background: Writable attribute to disable drawing background
            color and outside border
        no_bring_to_front_on_focus: Writable attribute to indicate when the window takes focus (click on it, etc)
            it shouldn't be shown in front of other windows
        no_collapse: Writable attribute to disable user collapsing window by double-clicking on it
        no_focus_on_appearing: Writable attribute to indicate when the windows moves from
            an un-shown to a shown item shouldn't be made automatically
            focused
        no_keyboard_inputs: Writable attribute to disable keyboard manipulation (scroll).
            The window will not take focus of the keyboard.
            Does not affect items inside the window.
        no_mouse_inputs: Writable attribute to disable mouse input event catching of the window.
            Events such as clicked, hovering, etc will be passed to items behind the
            window.
        no_move: Writable attribute the window to be move with interactions
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_open_over_existing_popup: Writable attribute for modal and popup windows to prevent them from
            showing if there is already an existing popup/modal window
        no_resize: Writable attribute to block resizing
        no_saved_settings: Writable attribute to never load/save settings in .ini file
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: Writable attribute to indicate the mouse wheel
               should have no effect on scrolling of this window
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        no_title_bar: Writable attribute to disable the title-bar
        on_close: Callback to call when the window is closed.
            Note closing the window does not destroy or unattach the item.
            Instead it is switched to a show=False state.
        parent: parent of the item in the rendering tree.
        popup: Writable attribute to indicate the window is a popup window.
            Popup windows are centered (unless a pos is set), do not have a
            close button, and are closed when they lose focus (clicking outside the
            window).
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        primary: Indicate if the window is the primary window.
            There is maximum one primary window. The primary window covers the whole
            viewport and can be used to draw on the background.
            It is equivalent to setting:
            no_bring_to_front_on_focus
            no_saved_settings
            no_resize
            no_collapse
            no_title_bar
            and running item.focused = True on all the other windows
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        unsaved_document: Writable attribute to display a dot next to the title, as if the window
            contains unsaved changes.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, autosize : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem, MenuBar] = ..., collapsed : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], has_close_button : bool = True, height : int = 0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", max_size : tuple = (30000, 30000), menubar : bool = False, min_size : tuple = (100, 100), modal : bool = False, next_sibling : baseItem | None = None, no_background : bool = False, no_bring_to_front_on_focus : bool = False, no_collapse : bool = False, no_focus_on_appearing : bool = False, no_keyboard_inputs : bool = False, no_mouse_inputs : bool = False, no_move : bool = False, no_newline : float = 0.0, no_open_over_existing_popup : bool = True, no_resize : bool = False, no_saved_settings : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, no_title_bar : bool = False, on_close : Any = ..., parent : Viewport | None = None, popup : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, primary : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : MetricsWindow = ..., theme : Any = ..., unsaved_document : bool = False, user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        autosize: Writable attribute to tell the window should
               automatically resize to fit its content
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        collapsed: Writable attribute to collapse (~minimize) or uncollapse the window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        has_close_button: Writable attribute to indicate the window has a close button.
            Has effect only for normal and modal windows.
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_size: Writable attribute to indicate the maximum window size
        menubar: Writable attribute to indicate whether the window has a menu bar.
        min_size: Writable attribute to indicate the minimum window size
        modal: Writable attribute to indicate the window is a modal window.
            Modal windows are similar to popup windows, but they have a close
            button and are not closed by clicking outside.
            Clicking has no effect of items outside the modal window until it is closed.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_background: Writable attribute to disable drawing background
            color and outside border
        no_bring_to_front_on_focus: Writable attribute to indicate when the window takes focus (click on it, etc)
            it shouldn't be shown in front of other windows
        no_collapse: Writable attribute to disable user collapsing window by double-clicking on it
        no_focus_on_appearing: Writable attribute to indicate when the windows moves from
            an un-shown to a shown item shouldn't be made automatically
            focused
        no_keyboard_inputs: Writable attribute to disable keyboard manipulation (scroll).
            The window will not take focus of the keyboard.
            Does not affect items inside the window.
        no_mouse_inputs: Writable attribute to disable mouse input event catching of the window.
            Events such as clicked, hovering, etc will be passed to items behind the
            window.
        no_move: Writable attribute the window to be move with interactions
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_open_over_existing_popup: Writable attribute for modal and popup windows to prevent them from
            showing if there is already an existing popup/modal window
        no_resize: Writable attribute to block resizing
        no_saved_settings: Writable attribute to never load/save settings in .ini file
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: Writable attribute to indicate the mouse wheel
               should have no effect on scrolling of this window
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        no_title_bar: Writable attribute to disable the title-bar
        on_close: Callback to call when the window is closed.
            Note closing the window does not destroy or unattach the item.
            Instead it is switched to a show=False state.
        parent: parent of the item in the rendering tree.
        popup: Writable attribute to indicate the window is a popup window.
            Popup windows are centered (unless a pos is set), do not have a
            close button, and are closed when they lose focus (clicking outside the
            window).
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        primary: Indicate if the window is the primary window.
            There is maximum one primary window. The primary window covers the whole
            viewport and can be used to draw on the background.
            It is equivalent to setting:
            no_bring_to_front_on_focus
            no_saved_settings
            no_resize
            no_collapse
            no_title_bar
            and running item.focused = True on all the other windows
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        unsaved_document: Writable attribute to display a dot next to the title, as if the window
            contains unsaved changes.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MetricsWindow:
        ...


    @property
    def always_show_horizontal_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a horizontal scrollbar
        even when the size does not require it (only if horizontal scrollbar
        are enabled)
        
        """
        ...


    @always_show_horizontal_scrollvar.setter
    def always_show_horizontal_scrollvar(self, value : bool):
        ...


    @property
    def always_show_vertical_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a vertical scrollbar
        even when the size does not require it
        
        """
        ...


    @always_show_vertical_scrollvar.setter
    def always_show_vertical_scrollvar(self, value : bool):
        ...


    @property
    def autosize(self) -> bool:
        """Writable attribute to tell the window should
           automatically resize to fit its content
        
        """
        ...


    @autosize.setter
    def autosize(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem, MenuBar]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem, MenuBar]):
        ...


    @property
    def collapsed(self) -> bool:
        """
        Writable attribute to collapse (~minimize) or uncollapse the window
        
        """
        ...


    @collapsed.setter
    def collapsed(self, value : bool):
        ...


    @property
    def content_region_avail(self) -> tuple:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def has_close_button(self) -> bool:
        """
        Writable attribute to indicate the window has a close button.
        Has effect only for normal and modal windows.
        
        """
        ...


    @has_close_button.setter
    def has_close_button(self, value : bool):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def horizontal_scrollbar(self) -> bool:
        """
        Writable attribute to enable having an horizontal scrollbar
        
        """
        ...


    @horizontal_scrollbar.setter
    def horizontal_scrollbar(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def max_size(self) -> tuple:
        """
        Writable attribute to indicate the maximum window size
        
        """
        ...


    @max_size.setter
    def max_size(self, value : tuple):
        ...


    @property
    def menubar(self) -> bool:
        """
        Writable attribute to indicate whether the window has a menu bar.

        There will be menubar if either the user has asked for it,
        or there is a menubar child.
        
        """
        ...


    @menubar.setter
    def menubar(self, value : bool):
        ...


    @property
    def min_size(self) -> tuple:
        """
        Writable attribute to indicate the minimum window size
        
        """
        ...


    @min_size.setter
    def min_size(self, value : tuple):
        ...


    @property
    def modal(self) -> bool:
        """
        Writable attribute to indicate the window is a modal window.
        Modal windows are similar to popup windows, but they have a close
        button and are not closed by clicking outside.
        Clicking has no effect of items outside the modal window until it is closed.
        
        """
        ...


    @modal.setter
    def modal(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_background(self) -> bool:
        """
        Writable attribute to disable drawing background
        color and outside border
        
        """
        ...


    @no_background.setter
    def no_background(self, value : bool):
        ...


    @property
    def no_bring_to_front_on_focus(self) -> bool:
        """
        Writable attribute to indicate when the window takes focus (click on it, etc)
        it shouldn't be shown in front of other windows
        
        """
        ...


    @no_bring_to_front_on_focus.setter
    def no_bring_to_front_on_focus(self, value : bool):
        ...


    @property
    def no_collapse(self) -> bool:
        """Writable attribute to disable user collapsing window by double-clicking on it
        
        """
        ...


    @no_collapse.setter
    def no_collapse(self, value : bool):
        ...


    @property
    def no_focus_on_appearing(self) -> bool:
        """
        Writable attribute to indicate when the windows moves from
        an un-shown to a shown item shouldn't be made automatically
        focused
        
        """
        ...


    @no_focus_on_appearing.setter
    def no_focus_on_appearing(self, value : bool):
        ...


    @property
    def no_keyboard_inputs(self) -> bool:
        """
        Writable attribute to disable keyboard manipulation (scroll).
        The window will not take focus of the keyboard.
        Does not affect items inside the window.
        
        """
        ...


    @no_keyboard_inputs.setter
    def no_keyboard_inputs(self, value : bool):
        ...


    @property
    def no_mouse_inputs(self) -> bool:
        """
        Writable attribute to disable mouse input event catching of the window.
        Events such as clicked, hovering, etc will be passed to items behind the
        window.
        
        """
        ...


    @no_mouse_inputs.setter
    def no_mouse_inputs(self, value : bool):
        ...


    @property
    def no_move(self) -> bool:
        """Writable attribute the window to be move with interactions
        """
        ...


    @no_move.setter
    def no_move(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_open_over_existing_popup(self) -> bool:
        """
        Writable attribute for modal and popup windows to prevent them from
        showing if there is already an existing popup/modal window
        
        """
        ...


    @no_open_over_existing_popup.setter
    def no_open_over_existing_popup(self, value : bool):
        ...


    @property
    def no_resize(self) -> bool:
        """Writable attribute to block resizing
        """
        ...


    @no_resize.setter
    def no_resize(self, value : bool):
        ...


    @property
    def no_saved_settings(self) -> bool:
        """
        Writable attribute to never load/save settings in .ini file
        
        """
        ...


    @no_saved_settings.setter
    def no_saved_settings(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_scroll_with_mouse(self) -> bool:
        """Writable attribute to indicate the mouse wheel
           should have no effect on scrolling of this window
        
        """
        ...


    @no_scroll_with_mouse.setter
    def no_scroll_with_mouse(self, value : bool):
        ...


    @property
    def no_scrollbar(self) -> bool:
        """Writable attribute to indicate the window should have no scrollbar
           Does not disable scrolling via mouse or keyboard
        
        """
        ...


    @no_scrollbar.setter
    def no_scrollbar(self, value : bool):
        ...


    @property
    def no_title_bar(self) -> bool:
        """Writable attribute to disable the title-bar
        """
        ...


    @no_title_bar.setter
    def no_title_bar(self, value : bool):
        ...


    @property
    def on_close(self):
        """
        Callback to call when the window is closed.
        Note closing the window does not destroy or unattach the item.
        Instead it is switched to a show=False state.
        
        """
        ...


    @on_close.setter
    def on_close(self, value):
        ...


    @property
    def parent(self) -> Viewport | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Viewport | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def popup(self) -> bool:
        """
        Writable attribute to indicate the window is a popup window.
        Popup windows are centered (unless a pos is set), do not have a
        close button, and are closed when they lose focus (clicking outside the
        window).
        
        """
        ...


    @popup.setter
    def popup(self, value : bool):
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def primary(self) -> bool:
        """
        Writable attribute: Indicate if the window is the primary window.
        There is maximum one primary window. The primary window covers the whole
        viewport and can be used to draw on the background.
        It is equivalent to setting:
        no_bring_to_front_on_focus
        no_saved_settings
        no_resize
        no_collapse
        no_title_bar
        and running item.focused = True on all the other windows
        
        """
        ...


    @primary.setter
    def primary(self, value : bool):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MetricsWindow:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MetricsWindow):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def unsaved_document(self) -> bool:
        """
        Writable attribute to display a dot next to the title, as if the window
        contains unsaved changes.
        
        """
        ...


    @unsaved_document.setter
    def unsaved_document(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class MouseClickHandler(baseHandler):
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, repeat : bool = False, show : bool = True, tag : MouseClickHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, repeat : bool = False, show : bool = True, tag : MouseClickHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseClickHandler:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def repeat(self) -> bool:
        ...


    @repeat.setter
    def repeat(self, value : bool):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MouseClickHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MouseClickHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseCursorHandler(baseHandler):
    """
    Since the mouse cursor is reset every frame,
    this handler is used to set the cursor automatically
    the frames where this handler is run.
    Typical usage would be in a ConditionalHandler,
    combined with a HoverHandler.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], cursor : MouseCursor = 0, enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseCursorHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        cursor: Change the mouse cursor to one of MouseCursor,
            but only for the frames where this handler
            is run.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], cursor : MouseCursor = 0, enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseCursorHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        cursor: Change the mouse cursor to one of MouseCursor,
            but only for the frames where this handler
            is run.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseCursorHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def cursor(self) -> MouseCursor:
        """
        Change the mouse cursor to one of MouseCursor,
        but only for the frames where this handler
        is run.
        
        """
        ...


    @cursor.setter
    def cursor(self, value : MouseCursor):
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MouseCursorHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MouseCursorHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseDoubleClickHandler(baseHandler):
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseDoubleClickHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseDoubleClickHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseDoubleClickHandler:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MouseDoubleClickHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MouseDoubleClickHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseDownHandler(baseHandler):
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseDownHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseDownHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseDownHandler:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MouseDownHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MouseDownHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseDragHandler(baseHandler):
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseDragHandler = ..., threshold : float = -1.0, user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseDragHandler = ..., threshold : float = -1.0, user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseDragHandler:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MouseDragHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MouseDragHandler):
        ...


    @property
    def threshold(self) -> float:
        ...


    @threshold.setter
    def threshold(self, value : float):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseMoveHandler(baseHandler):
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseMoveHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseMoveHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseMoveHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MouseMoveHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MouseMoveHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseReleaseHandler(baseHandler):
    def __init__(self, context : Context, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseReleaseHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, button : MouseButton = 0, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseReleaseHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseReleaseHandler:
        ...


    @property
    def button(self) -> MouseButton:
        ...


    @button.setter
    def button(self, value : MouseButton):
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MouseReleaseHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MouseReleaseHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class MouseWheelHandler(baseHandler):
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, horizontal : bool = False, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseWheelHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        horizontal: Whether to look at the horizontal wheel
            instead of the vertical wheel.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, horizontal : bool = False, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : MouseWheelHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        horizontal: Whether to look at the horizontal wheel
            instead of the vertical wheel.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> MouseWheelHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Whether to look at the horizontal wheel
        instead of the vertical wheel.

        NOTE: Shift+ vertical wheel => horizontal wheel
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> MouseWheelHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : MouseWheelHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class OpenHandler(baseHandler):
    """
    Handler that triggers the callback when the
    item is in an opened state.
    Here Close/Open refers to being in a
    reduced state when the full content is not
    shown, but could be if the user clicked on
    a specific button. The doesn't mean that
    the object is show or not shown.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : OpenHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : OpenHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> OpenHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> OpenHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : OpenHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class OtherItemHandler(HandlerList):
    """
    Handler that imports the states from a different
    item than the one is attached to, and runs the
    children handlers using the states of the other
    item. The 'target' field in the callbacks will
    still be the current item and not the other item.

    This is useful when you need to do a AND/OR combination
    of the current item state with another item state, or
    when you need to check the state of an item that might be
    not be rendered.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, op : HandlerListOP = 0, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : OtherItemHandler = ..., target : Any = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        op: HandlerListOP that defines which condition
            is required to trigger the callback of this
            handler.
            Default is ALL
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        target: Target item which state will be used
            for children handlers.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : list[baseHandler] = [], enabled : bool = True, next_sibling : baseItem | None = None, op : HandlerListOP = 0, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : OtherItemHandler = ..., target : Any = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        op: HandlerListOP that defines which condition
            is required to trigger the callback of this
            handler.
            Default is ALL
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        target: Target item which state will be used
            for children handlers.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> OtherItemHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> list[baseHandler]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseHandler]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def op(self) -> HandlerListOP:
        """
        HandlerListOP that defines which condition
        is required to trigger the callback of this
        handler.
        Default is ALL
        
        """
        ...


    @op.setter
    def op(self, value : HandlerListOP):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> OtherItemHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : OtherItemHandler):
        ...


    @property
    def target(self):
        """
        Target item which state will be used
        for children handlers.
        
        """
        ...


    @target.setter
    def target(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlaceHolderParent(baseItem):
    def __init__(self, context : Context, children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, tag : PlaceHolderParent = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, tag : PlaceHolderParent = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlaceHolderParent:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> PlaceHolderParent:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlaceHolderParent):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Plot(uiItem):
    """
    Plot. Can have Plot elements as child.

    By default the axes X1 and Y1 are enabled,
    but other can be enabled, up to X3 and Y3.
    For instance:
    my_plot.X2.enabled = True

    By default, the legend and axes have reserved space.
    They can have their own handlers that can react to
    when they are hovered by the mouse or clicked.

    The states of the plot relate to the rendering area (excluding
    the legend, padding and axes). Thus if you want to react
    to mouse event inside the plot area (for example implementing
    clicking an curve), you can do it with using handlers bound
    to the plot (+ some logic in your callbacks). 
    
    """
    def __init__(self, context : Context, X1 : PlotAxisConfig = ..., X2 : PlotAxisConfig = ..., X3 : PlotAxisConfig = ..., Y1 : PlotAxisConfig = ..., Y2 : PlotAxisConfig = ..., Y3 : PlotAxisConfig = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[plotElement] = [], crosshairs : bool = False, enabled : bool = True, equal_aspects : bool = False, fit_button : MouseButton = 0, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", legend_config : PlotLegendConfig = ..., menu_button : MouseButton = 1, next_sibling : baseItem | None = None, no_frame : bool = False, no_inputs : bool = False, no_legend : bool = False, no_menus : bool = False, no_mouse_pos : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_title : bool = False, pan_button : MouseButton = 0, pan_mod : int = 0, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Plot = ..., theme : Any = ..., use_24hour_clock : bool = False, use_ISO8601 : bool = False, use_local_time : bool = False, user_data : Any = ..., value : Any = ..., width : int = 0, zoom_mod : int = 0, zoom_rate : float = 0.10000000149011612):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        crosshairs: Writable attribute to replace the default mouse
            cursor by a crosshair when hovered
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        equal_aspects: Writable attribute to constrain x/y axes
            pairs to have the same units/pixels
        fit_button: Button that must be double-clicked to initiate
            a fit of the axes to the displayed data.
            Default is the left mouse button.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        menu_button: Button that opens context menus
            (if enabled) when clicked.
            Default is the right mouse button.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_frame: Writable attribute to disable the drawing of the
            imgui frame.
        no_inputs: Writable attribute to disable user interactions with
            the plot.
        no_legend: Writable attribute to disable the display of the
            legend
        no_menus: Writable attribute to disable the user interactions
            to open the context menus
        no_mouse_pos: Writable attribute to disable the display of the
            mouse position
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_title: Writable attribute to disable the display of the
            plot title
        pan_button: Button that when held enables to navigate inside the plot
            Default is the left mouse button.
        pan_mod: Modifier combination (shift/ctrl/alt/super) that must be
            pressed for pan_button to have effect.
            Default is no modifier.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        use_24hour_clock: If set, times will be formatted using a 24 hour clock.
            Default is False
        use_ISO8601: If set, dates will be formatted according to ISO 8601
            where applicable (e.g. YYYY-MM-DD, YYYY-MM,
            --MM-DD, etc.)
            Default is False.
        use_local_time: If set, axis labels will be formatted for the system
            timezone when ImPlotAxisFlag_Time is enabled.
            Default is False.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        zoom_mod: Modifier combination (shift/ctrl/alt/super) that
            must be hold for the mouse wheel to trigger a zoom
            of the plot.
            Default is no modifier.
        zoom_rate: Zoom rate for scroll (e.g. 0.1 = 10% plot range every
            scroll click);
            make negative to invert.
            Default is 0.1
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X1 : PlotAxisConfig = ..., X2 : PlotAxisConfig = ..., X3 : PlotAxisConfig = ..., Y1 : PlotAxisConfig = ..., Y2 : PlotAxisConfig = ..., Y3 : PlotAxisConfig = ..., callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[plotElement] = [], crosshairs : bool = False, enabled : bool = True, equal_aspects : bool = False, fit_button : MouseButton = 0, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", legend_config : PlotLegendConfig = ..., menu_button : MouseButton = 1, next_sibling : baseItem | None = None, no_frame : bool = False, no_inputs : bool = False, no_legend : bool = False, no_menus : bool = False, no_mouse_pos : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_title : bool = False, pan_button : MouseButton = 0, pan_mod : int = 0, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Plot = ..., theme : Any = ..., use_24hour_clock : bool = False, use_ISO8601 : bool = False, use_local_time : bool = False, user_data : Any = ..., value : Any = ..., width : int = 0, zoom_mod : int = 0, zoom_rate : float = 0.10000000149011612):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        crosshairs: Writable attribute to replace the default mouse
            cursor by a crosshair when hovered
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        equal_aspects: Writable attribute to constrain x/y axes
            pairs to have the same units/pixels
        fit_button: Button that must be double-clicked to initiate
            a fit of the axes to the displayed data.
            Default is the left mouse button.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        menu_button: Button that opens context menus
            (if enabled) when clicked.
            Default is the right mouse button.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_frame: Writable attribute to disable the drawing of the
            imgui frame.
        no_inputs: Writable attribute to disable user interactions with
            the plot.
        no_legend: Writable attribute to disable the display of the
            legend
        no_menus: Writable attribute to disable the user interactions
            to open the context menus
        no_mouse_pos: Writable attribute to disable the display of the
            mouse position
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_title: Writable attribute to disable the display of the
            plot title
        pan_button: Button that when held enables to navigate inside the plot
            Default is the left mouse button.
        pan_mod: Modifier combination (shift/ctrl/alt/super) that must be
            pressed for pan_button to have effect.
            Default is no modifier.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        use_24hour_clock: If set, times will be formatted using a 24 hour clock.
            Default is False
        use_ISO8601: If set, dates will be formatted according to ISO 8601
            where applicable (e.g. YYYY-MM-DD, YYYY-MM,
            --MM-DD, etc.)
            Default is False.
        use_local_time: If set, axis labels will be formatted for the system
            timezone when ImPlotAxisFlag_Time is enabled.
            Default is False.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        zoom_mod: Modifier combination (shift/ctrl/alt/super) that
            must be hold for the mouse wheel to trigger a zoom
            of the plot.
            Default is no modifier.
        zoom_rate: Zoom rate for scroll (e.g. 0.1 = 10% plot range every
            scroll click);
            make negative to invert.
            Default is 0.1
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Plot:
        ...


    @property
    def X1(self) -> PlotAxisConfig:
        ...


    @X1.setter
    def X1(self, value : PlotAxisConfig):
        ...


    @property
    def X2(self) -> PlotAxisConfig:
        ...


    @X2.setter
    def X2(self, value : PlotAxisConfig):
        ...


    @property
    def X3(self) -> PlotAxisConfig:
        ...


    @X3.setter
    def X3(self, value : PlotAxisConfig):
        ...


    @property
    def Y1(self) -> PlotAxisConfig:
        ...


    @Y1.setter
    def Y1(self, value : PlotAxisConfig):
        ...


    @property
    def Y2(self) -> PlotAxisConfig:
        ...


    @Y2.setter
    def Y2(self, value : PlotAxisConfig):
        ...


    @property
    def Y3(self) -> PlotAxisConfig:
        ...


    @Y3.setter
    def Y3(self, value : PlotAxisConfig):
        ...


    @property
    def axes(self) -> list:
        """
        Helper read-only property to retrieve the 6 axes
        in an array [X1, X2, X3, Y1, Y2, Y3]
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[plotElement]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[plotElement]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def content_pos(self) -> tuple:
        """
        Readable attribute indicating the top left starting
        position of the plot content in viewport coordinates.

        The size of the plot content area is available with
        content_size_avail.
        
        """
        ...


    @property
    def content_region_avail(self) -> tuple:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def crosshairs(self) -> bool:
        """
        Writable attribute to replace the default mouse
        cursor by a crosshair when hovered
        
        """
        ...


    @crosshairs.setter
    def crosshairs(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def equal_aspects(self) -> bool:
        """
        Writable attribute to constrain x/y axes
        pairs to have the same units/pixels
        
        """
        ...


    @equal_aspects.setter
    def equal_aspects(self, value : bool):
        ...


    @property
    def fit_button(self) -> MouseButton:
        """
        Button that must be double-clicked to initiate
        a fit of the axes to the displayed data.
        Default is the left mouse button.
        
        """
        ...


    @fit_button.setter
    def fit_button(self, value : MouseButton):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_config(self) -> PlotLegendConfig:
        ...


    @legend_config.setter
    def legend_config(self, value : PlotLegendConfig):
        ...


    @property
    def menu_button(self) -> MouseButton:
        """
        Button that opens context menus
        (if enabled) when clicked.
        Default is the right mouse button.
        
        """
        ...


    @menu_button.setter
    def menu_button(self, value : MouseButton):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_frame(self) -> bool:
        """
        Writable attribute to disable the drawing of the
        imgui frame.
        
        """
        ...


    @no_frame.setter
    def no_frame(self, value : bool):
        ...


    @property
    def no_inputs(self) -> bool:
        """
        Writable attribute to disable user interactions with
        the plot.
        
        """
        ...


    @no_inputs.setter
    def no_inputs(self, value : bool):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the display of the
        legend
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def no_menus(self) -> bool:
        """
        Writable attribute to disable the user interactions
        to open the context menus
        
        """
        ...


    @no_menus.setter
    def no_menus(self, value : bool):
        ...


    @property
    def no_mouse_pos(self) -> bool:
        """
        Writable attribute to disable the display of the
        mouse position
        
        """
        ...


    @no_mouse_pos.setter
    def no_mouse_pos(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_title(self) -> bool:
        """
        Writable attribute to disable the display of the
        plot title
        
        """
        ...


    @no_title.setter
    def no_title(self, value : bool):
        ...


    @property
    def pan_button(self) -> MouseButton:
        """
        Button that when held enables to navigate inside the plot
        Default is the left mouse button.
        
        """
        ...


    @pan_button.setter
    def pan_button(self, value : MouseButton):
        ...


    @property
    def pan_mod(self) -> int:
        """
        Modifier combination (shift/ctrl/alt/super) that must be
        pressed for pan_button to have effect.
        Default is no modifier.
        
        """
        ...


    @pan_mod.setter
    def pan_mod(self, value : int):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Plot:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Plot):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def use_24hour_clock(self) -> bool:
        """
        If set, times will be formatted using a 24 hour clock.
        Default is False
        
        """
        ...


    @use_24hour_clock.setter
    def use_24hour_clock(self, value : bool):
        ...


    @property
    def use_ISO8601(self) -> bool:
        """
        If set, dates will be formatted according to ISO 8601
        where applicable (e.g. YYYY-MM-DD, YYYY-MM,
        --MM-DD, etc.)
        Default is False.
        
        """
        ...


    @use_ISO8601.setter
    def use_ISO8601(self, value : bool):
        ...


    @property
    def use_local_time(self) -> bool:
        """
        If set, axis labels will be formatted for the system
        timezone when ImPlotAxisFlag_Time is enabled.
        Default is False.
        
        """
        ...


    @use_local_time.setter
    def use_local_time(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


    @property
    def zoom_mod(self) -> int:
        """
        Modifier combination (shift/ctrl/alt/super) that
        must be hold for the mouse wheel to trigger a zoom
        of the plot.
        Default is no modifier.
        
        """
        ...


    @zoom_mod.setter
    def zoom_mod(self, value : int):
        ...


    @property
    def zoom_rate(self) -> float:
        """
        Zoom rate for scroll (e.g. 0.1 = 10% plot range every
        scroll click);
        make negative to invert.
        Default is 0.1
        
        """
        ...


    @zoom_rate.setter
    def zoom_rate(self, value : float):
        ...


class PlotAxisConfig(baseItem):
    def __init__(self, context : Context, auto_fit : bool = False, children : list[baseItem] = [], constraint_max : float = inf, constraint_min : float = -inf, enabled : bool = True, foreground_grid : bool = False, format : str = "", handlers : list = [], invert : bool = False, label : str = "", labels : list = [], labels_coord : list = [], lock_max : bool = False, lock_min : bool = False, max : float = 1.0, min : float = 0.0, next_sibling : baseItem | None = None, no_gridlines : bool = False, no_highlight : bool = False, no_initial_fit : bool = False, no_label : bool = False, no_menus : bool = False, no_side_switch : bool = False, no_tick_labels : bool = False, no_tick_marks : bool = False, opposite : bool = False, pan_stretch : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, restrict_fit_to_range : bool = False, scale : AxisScale = 0, tag : PlotAxisConfig = ..., user_data : Any = ..., zoom_max : float = inf, zoom_min : float = 0.0):
        """

        auto_fit: Writable attribute to force the axis to fit its range
            to the data every frame.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        constraint_max: Constraint on the maximum value
            of max.
        constraint_min: Constraint on the minimum value
            of min.
        enabled: Whether elements using this axis should
            be drawn.
        foreground_grid: Writable attribute to render gridlines on top of
            the data rather than behind.
        format: format string to display axis values
        handlers: bound handlers for the axis.
            Only visible, hovered and clicked handlers are compatible.
        invert: Writable attribute to invert the values of the axis
        label: axis name
        labels: array of strings to display as labels
        labels_coord: coordinate for each label in labels at
            which to display the labels
        lock_max: Writable attribute to lock the axis maximum value
            when panning/zooming
        lock_min: Writable attribute to lock the axis minimum value
            when panning/zooming
        max: Current maximum of the range displayed.
            Do not set max <= min. Set invert to change
            the axis order.
        min: Current minimum of the range displayed.
            Do not set max <= min. Set invert to change
            the axis order.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_gridlines: Writable attribute to not render grid lines
        no_highlight: Writable attribute to not highlight the axis background
            when hovered or held
        no_initial_fit: Writable attribute to disable fitting the extent
            of the axis to the data on the first frame.
        no_label: Writable attribute to not render the axis label
        no_menus: Writable attribute to prevent right-click to
            open context menus.
        no_side_switch: Writable attribute to prevent the user from switching
            the axis by dragging it.
        no_tick_labels: Writable attribute to not render tick labels
        no_tick_marks: Writable attribute to not render tick marks
        opposite: Writable attribute to render ticks and labels on
            the opposite side.
        pan_stretch: Writable attribute that when set, if panning in a locked or
            constrained state, will cause the axis to stretch
            if possible.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        restrict_fit_to_range: Writable attribute to ignore points that are outside
            the visible region of the opposite axis when fitting
            this axis.
        scale: Current AxisScale.
            Default is AxisScale.linear
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        zoom_max: Constraint on the maximum value
            of the zoom
        zoom_min: Constraint on the minimum value
            of the zoom
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, auto_fit : bool = False, children : list[baseItem] = [], constraint_max : float = inf, constraint_min : float = -inf, enabled : bool = True, foreground_grid : bool = False, format : str = "", handlers : list = [], invert : bool = False, label : str = "", labels : list = [], labels_coord : list = [], lock_max : bool = False, lock_min : bool = False, max : float = 1.0, min : float = 0.0, next_sibling : baseItem | None = None, no_gridlines : bool = False, no_highlight : bool = False, no_initial_fit : bool = False, no_label : bool = False, no_menus : bool = False, no_side_switch : bool = False, no_tick_labels : bool = False, no_tick_marks : bool = False, opposite : bool = False, pan_stretch : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, restrict_fit_to_range : bool = False, scale : AxisScale = 0, tag : PlotAxisConfig = ..., user_data : Any = ..., zoom_max : float = inf, zoom_min : float = 0.0):
        """
        auto_fit: Writable attribute to force the axis to fit its range
            to the data every frame.
        children: List of all the children of the item,
            from first rendered, to last rendered.
        constraint_max: Constraint on the maximum value
            of max.
        constraint_min: Constraint on the minimum value
            of min.
        enabled: Whether elements using this axis should
            be drawn.
        foreground_grid: Writable attribute to render gridlines on top of
            the data rather than behind.
        format: format string to display axis values
        handlers: bound handlers for the axis.
            Only visible, hovered and clicked handlers are compatible.
        invert: Writable attribute to invert the values of the axis
        label: axis name
        labels: array of strings to display as labels
        labels_coord: coordinate for each label in labels at
            which to display the labels
        lock_max: Writable attribute to lock the axis maximum value
            when panning/zooming
        lock_min: Writable attribute to lock the axis minimum value
            when panning/zooming
        max: Current maximum of the range displayed.
            Do not set max <= min. Set invert to change
            the axis order.
        min: Current minimum of the range displayed.
            Do not set max <= min. Set invert to change
            the axis order.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_gridlines: Writable attribute to not render grid lines
        no_highlight: Writable attribute to not highlight the axis background
            when hovered or held
        no_initial_fit: Writable attribute to disable fitting the extent
            of the axis to the data on the first frame.
        no_label: Writable attribute to not render the axis label
        no_menus: Writable attribute to prevent right-click to
            open context menus.
        no_side_switch: Writable attribute to prevent the user from switching
            the axis by dragging it.
        no_tick_labels: Writable attribute to not render tick labels
        no_tick_marks: Writable attribute to not render tick marks
        opposite: Writable attribute to render ticks and labels on
            the opposite side.
        pan_stretch: Writable attribute that when set, if panning in a locked or
            constrained state, will cause the axis to stretch
            if possible.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        restrict_fit_to_range: Writable attribute to ignore points that are outside
            the visible region of the opposite axis when fitting
            this axis.
        scale: Current AxisScale.
            Default is AxisScale.linear
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        zoom_max: Constraint on the maximum value
            of the zoom
        zoom_min: Constraint on the minimum value
            of the zoom
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def fit(self):
        """
        Request for a fit of min/max to the data the next time the plot is drawn
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotAxisConfig:
        ...


    @property
    def auto_fit(self) -> bool:
        """
        Writable attribute to force the axis to fit its range
        to the data every frame.
        
        """
        ...


    @auto_fit.setter
    def auto_fit(self, value : bool):
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def constraint_max(self) -> float:
        """
        Constraint on the maximum value
        of max.
        
        """
        ...


    @constraint_max.setter
    def constraint_max(self, value : float):
        ...


    @property
    def constraint_min(self) -> float:
        """
        Constraint on the minimum value
        of min.
        
        """
        ...


    @constraint_min.setter
    def constraint_min(self, value : float):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Whether elements using this axis should
        be drawn.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def foreground_grid(self) -> bool:
        """
        Writable attribute to render gridlines on top of
        the data rather than behind.
        
        """
        ...


    @foreground_grid.setter
    def foreground_grid(self, value : bool):
        ...


    @property
    def format(self) -> str:
        """
        Writable attribute: format string to display axis values
        
        """
        ...


    @format.setter
    def format(self, value : str):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the axis.
        Only visible, hovered and clicked handlers are compatible.
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the axis label area
        
        """
        ...


    @property
    def invert(self) -> bool:
        """
        Writable attribute to invert the values of the axis
        
        """
        ...


    @invert.setter
    def invert(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: axis name
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def labels(self) -> list:
        """
        Writable attribute: array of strings to display as labels
        
        """
        ...


    @labels.setter
    def labels(self, value : list):
        ...


    @property
    def labels_coord(self) -> list:
        """
        Writable attribute: coordinate for each label in labels at
        which to display the labels
        
        """
        ...


    @labels_coord.setter
    def labels_coord(self, value : list):
        ...


    @property
    def lock_max(self) -> bool:
        """
        Writable attribute to lock the axis maximum value
        when panning/zooming
        
        """
        ...


    @lock_max.setter
    def lock_max(self, value : bool):
        ...


    @property
    def lock_min(self) -> bool:
        """
        Writable attribute to lock the axis minimum value
        when panning/zooming
        
        """
        ...


    @lock_min.setter
    def lock_min(self, value : bool):
        ...


    @property
    def max(self) -> float:
        """
        Current maximum of the range displayed.
        Do not set max <= min. Set invert to change
        the axis order.
        
        """
        ...


    @max.setter
    def max(self, value : float):
        ...


    @property
    def min(self) -> float:
        """
        Current minimum of the range displayed.
        Do not set max <= min. Set invert to change
        the axis order.
        
        """
        ...


    @min.setter
    def min(self, value : float):
        ...


    @property
    def mouse_coord(self) -> float:
        """
        Readonly attribute:
        The last estimated mouse position in plot space
        for this axis.
        Beware not to assign the same instance of
        PlotAxisConfig to several axes if you plan on using
        this.
        The mouse position is updated everytime the plot is
        drawn and the axis is enabled.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_gridlines(self) -> bool:
        """
        Writable attribute to not render grid lines
        
        """
        ...


    @no_gridlines.setter
    def no_gridlines(self, value : bool):
        ...


    @property
    def no_highlight(self) -> bool:
        """
        Writable attribute to not highlight the axis background
        when hovered or held
        
        """
        ...


    @no_highlight.setter
    def no_highlight(self, value : bool):
        ...


    @property
    def no_initial_fit(self) -> bool:
        """
        Writable attribute to disable fitting the extent
        of the axis to the data on the first frame.
        
        """
        ...


    @no_initial_fit.setter
    def no_initial_fit(self, value : bool):
        ...


    @property
    def no_label(self) -> bool:
        """
        Writable attribute to not render the axis label
        
        """
        ...


    @no_label.setter
    def no_label(self, value : bool):
        ...


    @property
    def no_menus(self) -> bool:
        """
        Writable attribute to prevent right-click to
        open context menus.
        
        """
        ...


    @no_menus.setter
    def no_menus(self, value : bool):
        ...


    @property
    def no_side_switch(self) -> bool:
        """
        Writable attribute to prevent the user from switching
        the axis by dragging it.
        
        """
        ...


    @no_side_switch.setter
    def no_side_switch(self, value : bool):
        ...


    @property
    def no_tick_labels(self) -> bool:
        """
        Writable attribute to not render tick labels
        
        """
        ...


    @no_tick_labels.setter
    def no_tick_labels(self, value : bool):
        ...


    @property
    def no_tick_marks(self) -> bool:
        """
        Writable attribute to not render tick marks
        
        """
        ...


    @no_tick_marks.setter
    def no_tick_marks(self, value : bool):
        ...


    @property
    def opposite(self) -> bool:
        """
        Writable attribute to render ticks and labels on
        the opposite side.
        
        """
        ...


    @opposite.setter
    def opposite(self, value : bool):
        ...


    @property
    def pan_stretch(self) -> bool:
        """
        Writable attribute that when set, if panning in a locked or
        constrained state, will cause the axis to stretch
        if possible.
        
        """
        ...


    @pan_stretch.setter
    def pan_stretch(self, value : bool):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def restrict_fit_to_range(self) -> bool:
        """
        Writable attribute to ignore points that are outside
        the visible region of the opposite axis when fitting
        this axis.
        
        """
        ...


    @restrict_fit_to_range.setter
    def restrict_fit_to_range(self, value : bool):
        ...


    @property
    def scale(self) -> AxisScale:
        """
        Current AxisScale.
        Default is AxisScale.linear
        
        """
        ...


    @scale.setter
    def scale(self, value : AxisScale):
        ...


    @property
    def tag(self) -> PlotAxisConfig:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotAxisConfig):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def zoom_max(self) -> float:
        """
        Constraint on the maximum value
        of the zoom
        
        """
        ...


    @zoom_max.setter
    def zoom_max(self, value : float):
        ...


    @property
    def zoom_min(self) -> float:
        """
        Constraint on the minimum value
        of the zoom
        
        """
        ...


    @zoom_min.setter
    def zoom_min(self, value : float):
        ...


class PlotBars(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotBars = ..., theme : Any = ..., user_data : Any = ..., weight : float = 1.0):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Bars will be rendered horizontally
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        weight: bar_size. TODO better document
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotBars = ..., theme : Any = ..., user_data : Any = ..., weight : float = 1.0):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Bars will be rendered horizontally
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        weight: bar_size. TODO better document
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotBars:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Bars will be rendered horizontally
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> PlotBars:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotBars):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def weight(self) -> float:
        """
        bar_size. TODO better document
        
        """
        ...


    @weight.setter
    def weight(self, value : float):
        ...


class PlotInfLines(plotElementX):
    """
    Draw vertical (or horizontal) infinite lines at
    the passed coordinates
    
    """
    def __init__(self, context : Context, X : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotInfLines = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Plot horizontal lines rather than plots
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotInfLines = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Plot horizontal lines rather than plots
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotInfLines:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Plot horizontal lines rather than plots
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> PlotInfLines:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotInfLines):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotLegendConfig(baseItem):
    def __init__(self, context : Context, children : list[baseItem] = [], horizontal : bool = False, location : LegendLocation = 5, next_sibling : baseItem | None = None, no_buttons : bool = False, no_highlight_axis : bool = False, no_highlight_item : bool = False, no_menus : bool = False, outside : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, sorted : bool = False, tag : PlotLegendConfig = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        horizontal: Writable attribute to display the legend entries
            horizontally rather than vertically
        location: Position of the legend.
            Default is LegendLocation.northwest
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_buttons: Writable attribute to prevent legend icons
            to function as hide/show buttons
        no_highlight_axis: Writable attribute to disable highlighting axes
            when their legend entry is hovered
            (only relevant if x/y-axis count > 1)
        no_highlight_item: Writable attribute to disable highlighting plot items
            when their legend entry is hovered
        no_menus: Writable attribute to disable right-clicking
            to open context menus.
        outside: Writable attribute to render the legend outside
            of the plot area
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        sorted: Writable attribute to display the legend entries
            in alphabetical order
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[baseItem] = [], horizontal : bool = False, location : LegendLocation = 5, next_sibling : baseItem | None = None, no_buttons : bool = False, no_highlight_axis : bool = False, no_highlight_item : bool = False, no_menus : bool = False, outside : bool = False, parent : baseItem | None = None, previous_sibling : baseItem | None = None, sorted : bool = False, tag : PlotLegendConfig = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        horizontal: Writable attribute to display the legend entries
            horizontally rather than vertically
        location: Position of the legend.
            Default is LegendLocation.northwest
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_buttons: Writable attribute to prevent legend icons
            to function as hide/show buttons
        no_highlight_axis: Writable attribute to disable highlighting axes
            when their legend entry is hovered
            (only relevant if x/y-axis count > 1)
        no_highlight_item: Writable attribute to disable highlighting plot items
            when their legend entry is hovered
        no_menus: Writable attribute to disable right-clicking
            to open context menus.
        outside: Writable attribute to render the legend outside
            of the plot area
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        sorted: Writable attribute to display the legend entries
            in alphabetical order
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotLegendConfig:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def horizontal(self) -> bool:
        """
        Writable attribute to display the legend entries
        horizontally rather than vertically
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def location(self) -> LegendLocation:
        """
        Position of the legend.
        Default is LegendLocation.northwest
        
        """
        ...


    @location.setter
    def location(self, value : LegendLocation):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_buttons(self) -> bool:
        """
        Writable attribute to prevent legend icons
        to function as hide/show buttons
        
        """
        ...


    @no_buttons.setter
    def no_buttons(self, value : bool):
        ...


    @property
    def no_highlight_axis(self) -> bool:
        """
        Writable attribute to disable highlighting axes
        when their legend entry is hovered
        (only relevant if x/y-axis count > 1)
        
        """
        ...


    @no_highlight_axis.setter
    def no_highlight_axis(self, value : bool):
        ...


    @property
    def no_highlight_item(self) -> bool:
        """
        Writable attribute to disable highlighting plot items
        when their legend entry is hovered
        
        """
        ...


    @no_highlight_item.setter
    def no_highlight_item(self, value : bool):
        ...


    @property
    def no_menus(self) -> bool:
        """
        Writable attribute to disable right-clicking
        to open context menus.
        
        """
        ...


    @no_menus.setter
    def no_menus(self, value : bool):
        ...


    @property
    def outside(self) -> bool:
        """
        Writable attribute to render the legend outside
        of the plot area
        
        """
        ...


    @outside.setter
    def outside(self, value : bool):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def sorted(self) -> bool:
        """
        Writable attribute to display the legend entries
        in alphabetical order
        
        """
        ...


    @sorted.setter
    def sorted(self, value : bool):
        ...


    @property
    def tag(self) -> PlotLegendConfig:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotLegendConfig):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotLine(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], loop : bool = False, next_sibling : baseItem | None = None, no_clip : bool = False, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, segments : bool = False, shaded : bool = False, show : bool = True, skip_nan : bool = False, tag : PlotLine = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        loop: Connect the first and last points
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Markers (if displayed) on the edge of a plot will not be clipped.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        segments: Plot segments rather than a full line
        shaded: A filled region between the line and horizontal
            origin will be rendered.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        skip_nan: A NaN data point will be ignored instead of
            being rendered as missing data.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], loop : bool = False, next_sibling : baseItem | None = None, no_clip : bool = False, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, segments : bool = False, shaded : bool = False, show : bool = True, skip_nan : bool = False, tag : PlotLine = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        loop: Connect the first and last points
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Markers (if displayed) on the edge of a plot will not be clipped.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        segments: Plot segments rather than a full line
        shaded: A filled region between the line and horizontal
            origin will be rendered.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        skip_nan: A NaN data point will be ignored instead of
            being rendered as missing data.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotLine:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def loop(self) -> bool:
        """
        Connect the first and last points
        
        """
        ...


    @loop.setter
    def loop(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_clip(self) -> bool:
        """
        Markers (if displayed) on the edge of a plot will not be clipped.
        
        """
        ...


    @no_clip.setter
    def no_clip(self, value : bool):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def segments(self) -> bool:
        """
        Plot segments rather than a full line
        
        """
        ...


    @segments.setter
    def segments(self, value : bool):
        ...


    @property
    def shaded(self) -> bool:
        """
        A filled region between the line and horizontal
        origin will be rendered.
        
        """
        ...


    @shaded.setter
    def shaded(self, value : bool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def skip_nan(self) -> bool:
        """
        A NaN data point will be ignored instead of
        being rendered as missing data.
        
        """
        ...


    @skip_nan.setter
    def skip_nan(self, value : bool):
        ...


    @property
    def tag(self) -> PlotLine:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotLine):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotScatter(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_clip : bool = False, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotScatter = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Markers on the edge of a plot will not be clipped
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_clip : bool = False, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotScatter = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_clip: Markers on the edge of a plot will not be clipped
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotScatter:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_clip(self) -> bool:
        """
        Markers on the edge of a plot will not be clipped
        
        """
        ...


    @no_clip.setter
    def no_clip(self, value : bool):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> PlotScatter:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotScatter):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotShadedLine(plotElementXYY):
    def __init__(self, context : Context, X : ndarray = [0.], Y1 : ndarray = [0.], Y2 : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotShadedLine = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y1 : ndarray = [0.], Y2 : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotShadedLine = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotShadedLine:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y1(self) -> ndarray:
        ...


    @Y1.setter
    def Y1(self, value : ndarray):
        ...


    @property
    def Y2(self) -> ndarray:
        ...


    @Y2.setter
    def Y2(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> PlotShadedLine:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotShadedLine):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotStairs(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, pre_step : bool = False, previous_sibling : baseItem | None = None, shaded : bool = False, show : bool = True, tag : PlotStairs = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        pre_step: The y value is continued constantly to the left
            from every x position, i.e. the interval
            (x[i-1], x[i]] has the value y[i].
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shaded: a filled region between the stairs and horizontal
            origin will be rendered; use PlotShadedLine for
            more advanced cases.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, pre_step : bool = False, previous_sibling : baseItem | None = None, shaded : bool = False, show : bool = True, tag : PlotStairs = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        pre_step: The y value is continued constantly to the left
            from every x position, i.e. the interval
            (x[i-1], x[i]] has the value y[i].
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shaded: a filled region between the stairs and horizontal
            origin will be rendered; use PlotShadedLine for
            more advanced cases.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotStairs:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pre_step(self) -> bool:
        """
        The y value is continued constantly to the left
        from every x position, i.e. the interval
        (x[i-1], x[i]] has the value y[i].
        
        """
        ...


    @pre_step.setter
    def pre_step(self, value : bool):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def shaded(self) -> bool:
        """
        a filled region between the stairs and horizontal
        origin will be rendered; use PlotShadedLine for
        more advanced cases.
        
        """
        ...


    @shaded.setter
    def shaded(self, value : bool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> PlotStairs:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotStairs):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class PlotStems(plotElementXY):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotStems = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Stems will be rendered horizontally
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, horizontal : bool = False, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : PlotStems = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        horizontal: Stems will be rendered horizontally
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> PlotStems:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Stems will be rendered horizontally
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> PlotStems:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : PlotStems):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ProgressBar(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, overlay : str = "", parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedFloat = ..., show : bool = True, tag : ProgressBar = ..., theme : Any = ..., user_data : Any = ..., value : float = 0.0, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        overlay: 
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, overlay : str = "", parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedFloat = ..., show : bool = True, tag : ProgressBar = ..., theme : Any = ..., user_data : Any = ..., value : float = 0.0, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        overlay: 
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ProgressBar:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def overlay(self) -> str:
        """
        Writable attribute:
        
        """
        ...


    @overlay.setter
    def overlay(self, value : str):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedFloat:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedFloat):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ProgressBar:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ProgressBar):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> float:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : float):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class RadioButton(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, horizontal : bool = False, indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedStr = ..., show : bool = True, tag : RadioButton = ..., theme : Any = ..., user_data : Any = ..., value : str = "", width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal: Horizontal vs vertical placement
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, horizontal : bool = False, indent : float = 0.0, items : list = [], label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedStr = ..., show : bool = True, tag : RadioButton = ..., theme : Any = ..., user_data : Any = ..., value : str = "", width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal: Horizontal vs vertical placement
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        items: List of text values to select
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> RadioButton:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def horizontal(self) -> bool:
        """
        Writable attribute: Horizontal vs vertical placement
        
        """
        ...


    @horizontal.setter
    def horizontal(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def items(self) -> list:
        """
        Writable attribute: List of text values to select
        
        """
        ...


    @items.setter
    def items(self, value : list):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> RadioButton:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : RadioButton):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class RenderHandler(baseHandler):
    """
    Handler that calls the callback
    whenever the item is rendered during
    frame rendering. This doesn't mean
    that the item is visible as it can be
    occluded by an item in front of it.
    Usually rendering skips items that
    are outside the window's clipping region,
    or items that are inside a menu that is
    currently closed.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : RenderHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : RenderHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> RenderHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> RenderHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : RenderHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ResizeHandler(baseHandler):
    """
    Handler that triggers the callback
    whenever the item's bounding box changes size.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ResizeHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ResizeHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ResizeHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ResizeHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ResizeHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Selectable(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], disable_popup_close : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, highlighted : bool = False, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, span_columns : bool = False, tag : Selectable = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        disable_popup_close: Clicking this doesn't close parent popup window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        highlighted: highlighted as if hovered
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        on_double_click: call callbacks on double clicks too
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        span_columns: Frame will span all columns of its container table (text will still fit in current column)
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], disable_popup_close : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, highlighted : bool = False, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, span_columns : bool = False, tag : Selectable = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        disable_popup_close: Clicking this doesn't close parent popup window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        highlighted: highlighted as if hovered
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        on_double_click: call callbacks on double clicks too
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        span_columns: Frame will span all columns of its container table (text will still fit in current column)
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Selectable:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def disable_popup_close(self) -> bool:
        """
        Writable attribute: Clicking this doesn't close parent popup window
        
        """
        ...


    @disable_popup_close.setter
    def disable_popup_close(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def highlighted(self) -> bool:
        """
        Writable attribute: highlighted as if hovered
        
        """
        ...


    @highlighted.setter
    def highlighted(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def on_double_click(self) -> bool:
        """
        Writable attribute: call callbacks on double clicks too
        
        """
        ...


    @on_double_click.setter
    def on_double_click(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def span_columns(self) -> bool:
        """
        Writable attribute: Frame will span all columns of its container table (text will still fit in current column)
        
        """
        ...


    @span_columns.setter
    def span_columns(self, value : bool):
        ...


    @property
    def tag(self) -> Selectable:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Selectable):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class Separator(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Separator = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Separator = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Separator:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Separator:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Separator):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class SharedBool(SharedValue):
    def __init__(self, context : Context, value : bool):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        ...


    @property
    def value(self) -> bool:
        ...


    @value.setter
    def value(self, value : bool):
        ...


class SharedColor(SharedValue):
    def __init__(self, context : Context, value : int):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedColor:
        ...


    @property
    def value(self) -> int:
        ...


    @value.setter
    def value(self, value : int):
        ...


class SharedDouble(SharedValue):
    def __init__(self, context : Context, value : float):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedDouble:
        ...


    @property
    def value(self) -> float:
        ...


    @value.setter
    def value(self, value : float):
        ...


class SharedDouble4(SharedValue):
    def __init__(self, context : Context, value : list):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedDouble4:
        ...


    @property
    def value(self) -> list:
        ...


    @value.setter
    def value(self, value : list):
        ...


class SharedFloat(SharedValue):
    def __init__(self, context : Context, value : float):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedFloat:
        ...


    @property
    def value(self) -> float:
        ...


    @value.setter
    def value(self, value : float):
        ...


class SharedFloat4(SharedValue):
    def __init__(self, context : Context, value : list):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedFloat4:
        ...


    @property
    def value(self) -> list:
        ...


    @value.setter
    def value(self, value : list):
        ...


class SharedFloatVect(SharedValue):
    def __init__(self, context : Context, value : Any):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedFloatVect:
        ...


    @property
    def value(self):
        ...


    @value.setter
    def value(self, value):
        ...


class SharedInt(SharedValue):
    def __init__(self, context : Context, value : int):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedInt:
        ...


    @property
    def value(self) -> int:
        ...


    @value.setter
    def value(self, value : int):
        ...


class SharedInt4(SharedValue):
    def __init__(self, context : Context, value : list):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedInt4:
        ...


    @property
    def value(self) -> list:
        ...


    @value.setter
    def value(self, value : list):
        ...


class SharedStr(SharedValue):
    def __init__(self, context : Context, value : str):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedStr:
        ...


    @property
    def value(self) -> str:
        ...


    @value.setter
    def value(self, value : str):
        ...


class SharedValue(object):
    def __init__(self, context : Context, value : Any):
        """
Initialize self.  See help(type(self)) for accurate signature.
        """
        ...


    @property
    def last_frame_change(self) -> int:
        """
        Readable attribute: last frame index when the value
        was changed (different value).
        For non-scalar data (color, point, vector), equals to
        last_frame_update to avoid heavy comparisons.
        
        """
        ...


    @property
    def last_frame_update(self) -> int:
        """
        Readable attribute: last frame index when the value
        was updated (can be identical value).
        
        """
        ...


    @property
    def num_attached(self) -> int:
        """
        Readable attribute: Number of items sharing this value
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        ...


    @property
    def value(self):
        ...


    @value.setter
    def value(self, value):
        ...


class SimplePlot(uiItem):
    def __init__(self, context : Context, autoscale : bool = True, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, histogram : bool = False, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, overlay : bytes = b'', parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, scale_max : float = 0.0, scale_min : float = 0.0, shareable_value : SharedFloatVect = ..., show : bool = True, tag : SimplePlot = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        autoscale: Whether scale_min and scale_max should be deduced
            from the data
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        histogram: Whether the data should be plotted as an histogram
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        overlay: Overlay text
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scale_max: value corresponding to the maximum value of plot scale
        scale_min: value corresponding to the minimum value of plot scale
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, autoscale : bool = True, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, histogram : bool = False, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, overlay : bytes = b'', parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, scale_max : float = 0.0, scale_min : float = 0.0, shareable_value : SharedFloatVect = ..., show : bool = True, tag : SimplePlot = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        autoscale: Whether scale_min and scale_max should be deduced
            from the data
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        histogram: Whether the data should be plotted as an histogram
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        overlay: Overlay text
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        scale_max: value corresponding to the maximum value of plot scale
        scale_min: value corresponding to the minimum value of plot scale
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> SimplePlot:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def autoscale(self) -> bool:
        """
        Writable attribute: Whether scale_min and scale_max should be deduced
        from the data
        
        """
        ...


    @autoscale.setter
    def autoscale(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def histogram(self) -> bool:
        """
        Writable attribute: Whether the data should be plotted as an histogram
        
        """
        ...


    @histogram.setter
    def histogram(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def overlay(self) -> bytes:
        """
        Writable attribute: Overlay text
        
        """
        ...


    @overlay.setter
    def overlay(self, value : bytes):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def scale_max(self) -> float:
        """
        Writable attribute: value corresponding to the maximum value of plot scale
        
        """
        ...


    @scale_max.setter
    def scale_max(self, value : float):
        ...


    @property
    def scale_min(self) -> float:
        """
        Writable attribute: value corresponding to the minimum value of plot scale
        
        """
        ...


    @scale_min.setter
    def scale_min(self, value : float):
        ...


    @property
    def shareable_value(self) -> SharedFloatVect:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedFloatVect):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> SimplePlot:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : SimplePlot):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class Slider(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], clamped : bool = False, drag : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, format : str = "float", handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", logarithmic : bool = False, max_value : float = 100.0, min_value : float = 0.0, next_sibling : baseItem | None = None, no_input : bool = False, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, print_format : str = "%.3f", round_to_format : bool = True, shareable_value : SharedFloat = ..., show : bool = True, size : int = 1, speed : float = 1.0, tag : Slider = ..., theme : Any = ..., user_data : Any = ..., value : float = 0.0, vertical : bool = False, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        clamped: Whether the slider value should be clamped even when keyboard set
        drag: Whether the use a 'drag'
            slider rather than a regular one.
            Incompatible with 'vertical'.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        format: Format of the slider.
            Must be "int", "float" or "double".
            Note that float here means the 32 bits version.
            The python float corresponds to a double.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        logarithmic: Make the slider logarithmic.
            Disables round_to_format if enabled
        max_value: Maximum value the slider
            will be clamped to.
        min_value: Minimum value the slider
            will be clamped to.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: Disable Ctrl+Click and Enter key to
            manually set the value
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        print_format: format string
            for the value -> string conversion
            for display. If round_to_format is
            enabled, the value is converted
            back and thus appears rounded.
        round_to_format: If set (default),
            the value will not have more digits precision
            than the requested format string for display.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Size of the slider.
            Can be 1, 2, 3 or 4.
            When 1 the item's value is held with
            a scalar shared value, else it is held
            with a vector of 4 elements (even for
            size 2 and 3)
        speed: When drag is true,
            this attributes sets the drag speed.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        vertical: Whether the use a vertical
            slider. Only sliders of size 1 and drag False
            are supported.
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], clamped : bool = False, drag : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, format : str = "float", handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", logarithmic : bool = False, max_value : float = 100.0, min_value : float = 0.0, next_sibling : baseItem | None = None, no_input : bool = False, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, print_format : str = "%.3f", round_to_format : bool = True, shareable_value : SharedFloat = ..., show : bool = True, size : int = 1, speed : float = 1.0, tag : Slider = ..., theme : Any = ..., user_data : Any = ..., value : float = 0.0, vertical : bool = False, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        clamped: Whether the slider value should be clamped even when keyboard set
        drag: Whether the use a 'drag'
            slider rather than a regular one.
            Incompatible with 'vertical'.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        format: Format of the slider.
            Must be "int", "float" or "double".
            Note that float here means the 32 bits version.
            The python float corresponds to a double.
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        logarithmic: Make the slider logarithmic.
            Disables round_to_format if enabled
        max_value: Maximum value the slider
            will be clamped to.
        min_value: Minimum value the slider
            will be clamped to.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_input: Disable Ctrl+Click and Enter key to
            manually set the value
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        print_format: format string
            for the value -> string conversion
            for display. If round_to_format is
            enabled, the value is converted
            back and thus appears rounded.
        round_to_format: If set (default),
            the value will not have more digits precision
            than the requested format string for display.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        size: Size of the slider.
            Can be 1, 2, 3 or 4.
            When 1 the item's value is held with
            a scalar shared value, else it is held
            with a vector of 4 elements (even for
            size 2 and 3)
        speed: When drag is true,
            this attributes sets the drag speed.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        vertical: Whether the use a vertical
            slider. Only sliders of size 1 and drag False
            are supported.
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Slider:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clamped(self) -> bool:
        """
        Writable attribute: Whether the slider value should be clamped even when keyboard set
        
        """
        ...


    @clamped.setter
    def clamped(self, value : bool):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def drag(self) -> bool:
        """
        Writable attribute: Whether the use a 'drag'
        slider rather than a regular one.
        Incompatible with 'vertical'.
        
        """
        ...


    @drag.setter
    def drag(self, value : bool):
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def format(self) -> str:
        """
        Writable attribute: Format of the slider.
        Must be "int", "float" or "double".
        Note that float here means the 32 bits version.
        The python float corresponds to a double.
        
        """
        ...


    @format.setter
    def format(self, value : str):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def logarithmic(self) -> bool:
        """
        Writable attribute: Make the slider logarithmic.
        Disables round_to_format if enabled
        
        """
        ...


    @logarithmic.setter
    def logarithmic(self, value : bool):
        ...


    @property
    def max_value(self) -> float:
        """
        Writable attribute: Maximum value the slider
        will be clamped to.
        
        """
        ...


    @max_value.setter
    def max_value(self, value : float):
        ...


    @property
    def min_value(self) -> float:
        """
        Writable attribute: Minimum value the slider
        will be clamped to.
        
        """
        ...


    @min_value.setter
    def min_value(self, value : float):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_input(self) -> bool:
        """
        Writable attribute: Disable Ctrl+Click and Enter key to
        manually set the value
        
        """
        ...


    @no_input.setter
    def no_input(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def print_format(self) -> str:
        """
        Writable attribute: format string
        for the value -> string conversion
        for display. If round_to_format is
        enabled, the value is converted
        back and thus appears rounded.
        
        """
        ...


    @print_format.setter
    def print_format(self, value : str):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def round_to_format(self) -> bool:
        """
        Writable attribute: If set (default),
        the value will not have more digits precision
        than the requested format string for display.
        
        """
        ...


    @round_to_format.setter
    def round_to_format(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedFloat:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedFloat):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def size(self) -> int:
        """
        Writable attribute: Size of the slider.
        Can be 1, 2, 3 or 4.
        When 1 the item's value is held with
        a scalar shared value, else it is held
        with a vector of 4 elements (even for
        size 2 and 3)
        
        """
        ...


    @size.setter
    def size(self, value : int):
        ...


    @property
    def speed(self) -> float:
        """
        Writable attribute: When drag is true,
        this attributes sets the drag speed.
        
        """
        ...


    @speed.setter
    def speed(self, value : float):
        ...


    @property
    def tag(self) -> Slider:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Slider):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> float:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : float):
        ...


    @property
    def vertical(self) -> bool:
        """
        Writable attribute: Whether the use a vertical
        slider. Only sliders of size 1 and drag False
        are supported.
        
        """
        ...


    @vertical.setter
    def vertical(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class Spacer(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Spacer = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Spacer = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Spacer:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Spacer:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Spacer):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class Tab(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], closable : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", leading : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_reorder : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : Tab = ..., theme : Any = ..., trailing : bool = False, user_data : Any = ..., value : bool = False, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closable: Can the tab be closed
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leading: Enforce the tab position to the
            left of the tab bar (after the tab list popup button)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_reorder: Disable reordering this tab or
            having another tab cross over this tab
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: Disable tooltip for the given tab
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        trailing: Enforce the tab position to the
            right of the tab bar (before the scrolling buttons)
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], closable : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", leading : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_reorder : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : Tab = ..., theme : Any = ..., trailing : bool = False, user_data : Any = ..., value : bool = False, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        closable: Can the tab be closed
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leading: Enforce the tab position to the
            left of the tab bar (after the tab list popup button)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_reorder: Disable reordering this tab or
            having another tab cross over this tab
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: Disable tooltip for the given tab
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        trailing: Enforce the tab position to the
            right of the tab bar (before the scrolling buttons)
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Tab:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def closable(self) -> bool:
        """
        Writable attribute: Can the tab be closed
        
        """
        ...


    @closable.setter
    def closable(self, value : bool):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def leading(self) -> bool:
        """
        Writable attribute: Enforce the tab position to the
        left of the tab bar (after the tab list popup button)
        
        """
        ...


    @leading.setter
    def leading(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_reorder(self) -> bool:
        """
        Writable attribute: Disable reordering this tab or
        having another tab cross over this tab
        
        """
        ...


    @no_reorder.setter
    def no_reorder(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: Disable tooltip for the given tab
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Tab:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Tab):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def trailing(self) -> bool:
        """
        Writable attribute: Enforce the tab position to the
        right of the tab bar (before the scrolling buttons)
        
        """
        ...


    @trailing.setter
    def trailing(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class TabBar(uiItem):
    def __init__(self, context : Context, allow_tab_scroll : bool = False, autoselect_new_tabs : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_close_with_middle_mouse_button : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_scrolling_button : bool = False, no_tab_list_popup_button : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, reorderable : bool = False, resize_to_fit : bool = False, selected_overline : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : TabBar = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        allow_tab_scroll: Add scroll buttons when tabs don't fit
        autoselect_new_tabs: Automatically select new
            tabs when they appear
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_close_with_middle_mouse_button: Disable behavior of closing tabs with middle mouse button.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scrolling_button: Disable scrolling buttons
        no_tab_list_popup_button: Disable buttons to open the tab list popup
        no_tooltip: Disable tooltip for all tabs
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        reorderable: Allow manually dragging tabs
            to re-order them + New tabs are appended at the end of list
        resize_to_fit: Resize tabs when they don't fit
        selected_overline: Draw selected overline markers over selected tab
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, allow_tab_scroll : bool = False, autoselect_new_tabs : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_close_with_middle_mouse_button : bool = False, no_newline : float = 0.0, no_scaling : bool = False, no_scrolling_button : bool = False, no_tab_list_popup_button : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, reorderable : bool = False, resize_to_fit : bool = False, selected_overline : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : TabBar = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        allow_tab_scroll: Add scroll buttons when tabs don't fit
        autoselect_new_tabs: Automatically select new
            tabs when they appear
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_close_with_middle_mouse_button: Disable behavior of closing tabs with middle mouse button.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scrolling_button: Disable scrolling buttons
        no_tab_list_popup_button: Disable buttons to open the tab list popup
        no_tooltip: Disable tooltip for all tabs
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        reorderable: Allow manually dragging tabs
            to re-order them + New tabs are appended at the end of list
        resize_to_fit: Resize tabs when they don't fit
        selected_overline: Draw selected overline markers over selected tab
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TabBar:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def allow_tab_scroll(self) -> bool:
        """
        Writable attribute: Add scroll buttons when tabs don't fit
        
        """
        ...


    @allow_tab_scroll.setter
    def allow_tab_scroll(self, value : bool):
        ...


    @property
    def autoselect_new_tabs(self) -> bool:
        """
        Writable attribute: Automatically select new
        tabs when they appear
        
        """
        ...


    @autoselect_new_tabs.setter
    def autoselect_new_tabs(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_close_with_middle_mouse_button(self) -> bool:
        """
        Writable attribute: Disable behavior of closing tabs with middle mouse button.
        
        """
        ...


    @no_close_with_middle_mouse_button.setter
    def no_close_with_middle_mouse_button(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_scrolling_button(self) -> bool:
        """
        Writable attribute: Disable scrolling buttons
        
        """
        ...


    @no_scrolling_button.setter
    def no_scrolling_button(self, value : bool):
        ...


    @property
    def no_tab_list_popup_button(self) -> bool:
        """
        Writable attribute: Disable buttons to open the tab list popup
        
        """
        ...


    @no_tab_list_popup_button.setter
    def no_tab_list_popup_button(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: Disable tooltip for all tabs
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def reorderable(self) -> bool:
        """
        Writable attribute: Allow manually dragging tabs
        to re-order them + New tabs are appended at the end of list
        
        """
        ...


    @reorderable.setter
    def reorderable(self, value : bool):
        ...


    @property
    def resize_to_fit(self) -> bool:
        """
        Writable attribute: Resize tabs when they don't fit
        
        """
        ...


    @resize_to_fit.setter
    def resize_to_fit(self, value : bool):
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def selected_overline(self) -> bool:
        """
        Writable attribute: Draw selected overline markers over selected tab
        
        """
        ...


    @selected_overline.setter
    def selected_overline(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> TabBar:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : TabBar):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class TabButton(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", leading : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_reorder : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : TabButton = ..., theme : Any = ..., trailing : bool = False, user_data : Any = ..., value : bool = False, width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leading: Enforce the tab position to the
            left of the tab bar (after the tab list popup button)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_reorder: Disable reordering this tab or
            having another tab cross over this tab
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: Disable tooltip for the given tab
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        trailing: Enforce the tab position to the
            right of the tab bar (before the scrolling buttons)
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", leading : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_reorder : bool = False, no_scaling : bool = False, no_tooltip : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedBool = ..., show : bool = True, tag : TabButton = ..., theme : Any = ..., trailing : bool = False, user_data : Any = ..., value : bool = False, width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leading: Enforce the tab position to the
            left of the tab bar (after the tab list popup button)
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_reorder: Disable reordering this tab or
            having another tab cross over this tab
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_tooltip: Disable tooltip for the given tab
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        trailing: Enforce the tab position to the
            right of the tab bar (before the scrolling buttons)
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TabButton:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def leading(self) -> bool:
        """
        Writable attribute: Enforce the tab position to the
        left of the tab bar (after the tab list popup button)
        
        """
        ...


    @leading.setter
    def leading(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_reorder(self) -> bool:
        """
        Writable attribute: Disable reordering this tab or
        having another tab cross over this tab
        
        """
        ...


    @no_reorder.setter
    def no_reorder(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_tooltip(self) -> bool:
        """
        Writable attribute: Disable tooltip for the given tab
        
        """
        ...


    @no_tooltip.setter
    def no_tooltip(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> TabButton:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : TabButton):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def trailing(self) -> bool:
        """
        Writable attribute: Enforce the tab position to the
        right of the tab bar (before the scrolling buttons)
        
        """
        ...


    @trailing.setter
    def trailing(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class TemporaryTooltip(Tooltip):
    """
    A tooltip that deletes itself when its
    showing condition is not met anymore.

    The handler passed as argument
    should be a new handler instance that will
    be checked for the condition. It should hold
    True as long as the item should be shown.
    
    """
    def __init__(self, context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], condition_from_handler : Any = ..., delay : float = 0.0, enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, hide_on_activity : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : TemporaryTooltip = ..., target : Any = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_from_handler: When set, the handler referenced in
            this field will be used to replace
            the target hovering check. It will
            apply to target, which must be set.
        delay: Delay in seconds with no motion before showing the tooltip
            -1: Use imgui defaults
            Has no effect if the target is not the previous sibling,
            or if condition_from_handler is set.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hide_on_activity: Hide the tooltip when the mouse moves
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        target: Target item which state will be checked
            to trigger the tooltip.
            Note if the item is after this tooltip
            in the rendering tree, there will be
            a frame delay.
            If no target is set, the previous sibling
            is the target.
            If the target is not the previous sibling,
            delay will have no effect.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], condition_from_handler : Any = ..., delay : float = 0.0, enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, hide_on_activity : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : TemporaryTooltip = ..., target : Any = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_from_handler: When set, the handler referenced in
            this field will be used to replace
            the target hovering check. It will
            apply to target, which must be set.
        delay: Delay in seconds with no motion before showing the tooltip
            -1: Use imgui defaults
            Has no effect if the target is not the previous sibling,
            or if condition_from_handler is set.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hide_on_activity: Hide the tooltip when the mouse moves
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        target: Target item which state will be checked
            to trigger the tooltip.
            Note if the item is after this tooltip
            in the rendering tree, there will be
            a frame delay.
            If no target is set, the previous sibling
            is the target.
            If the target is not the previous sibling,
            delay will have no effect.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TemporaryTooltip:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def condition_from_handler(self):
        """
        When set, the handler referenced in
        this field will be used to replace
        the target hovering check. It will
        apply to target, which must be set.
        
        """
        ...


    @condition_from_handler.setter
    def condition_from_handler(self, value):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def delay(self) -> float:
        """
        Delay in seconds with no motion before showing the tooltip
        -1: Use imgui defaults
        Has no effect if the target is not the previous sibling,
        or if condition_from_handler is set.
        
        """
        ...


    @delay.setter
    def delay(self, value : float):
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hide_on_activity(self) -> float:
        """
        Hide the tooltip when the mouse moves
        
        """
        ...


    @hide_on_activity.setter
    def hide_on_activity(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> TemporaryTooltip:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : TemporaryTooltip):
        ...


    @property
    def target(self):
        """
        Target item which state will be checked
        to trigger the tooltip.
        Note if the item is after this tooltip
        in the rendering tree, there will be
        a frame delay.
        If no target is set, the previous sibling
        is the target.
        If the target is not the previous sibling,
        delay will have no effect.
        
        """
        ...


    @target.setter
    def target(self, value):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class Text(uiItem):
    def __init__(self, context : Context, bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = 0, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedStr = ..., show : bool = True, show_label : bool = False, tag : Text = ..., theme : Any = ..., user_data : Any = ..., value : str = "", width : int = 0, wrap : int = -1):
        """

        bullet: Whether to add a bullet
            before the text
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: text color.
            If set to 0 (default), that is
            full transparent text, use the
            default value given by the style
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        show_label: Whether to display the
            label next to the text stored in value
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        wrap: wrap width in pixels
            -1 for no wrapping
            The width is multiplied by the global scale
            unless the no_scaling option is set.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], color : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float] = 0, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedStr = ..., show : bool = True, show_label : bool = False, tag : Text = ..., theme : Any = ..., user_data : Any = ..., value : str = "", width : int = 0, wrap : int = -1):
        """
        bullet: Whether to add a bullet
            before the text
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        color: text color.
            If set to 0 (default), that is
            full transparent text, use the
            default value given by the style
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        show_label: Whether to display the
            label next to the text stored in value
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        wrap: wrap width in pixels
            -1 for no wrapping
            The width is multiplied by the global scale
            unless the no_scaling option is set.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Text:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def bullet(self) -> bool:
        """
        Writable attribute: Whether to add a bullet
        before the text
        
        """
        ...


    @bullet.setter
    def bullet(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def color(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]:
        """
        Writable attribute: text color.
        If set to 0 (default), that is
        full transparent text, use the
        default value given by the style
        
        """
        ...


    @color.setter
    def color(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedStr:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedStr):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def show_label(self) -> bool:
        """
        Writable attribute: Whether to display the
        label next to the text stored in value
        
        """
        ...


    @show_label.setter
    def show_label(self, value : bool):
        ...


    @property
    def tag(self) -> Text:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Text):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> str:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : str):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


    @property
    def wrap(self) -> int:
        """
        Writable attribute: wrap width in pixels
        -1 for no wrapping
        The width is multiplied by the global scale
        unless the no_scaling option is set.
        
        """
        ...


    @wrap.setter
    def wrap(self, value : int):
        ...


class Texture(baseItem):
    def __init__(self, context : Context, children : list[baseItem] = [], hint_dynamic : bool = False, nearest_neighbor_upsampling : int = 0, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, tag : Texture = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        hint_dynamic: Hint for texture placement that
            the texture will be updated very
            frequently.
        nearest_neighbor_upsampling: Whether to use nearest neighbor interpolation
            instead of bilinear interpolation when upscaling
            the texture. Must be set before set_value.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, *args, children : list[baseItem] = [], hint_dynamic : bool = False, nearest_neighbor_upsampling : int = 0, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, tag : Texture = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        hint_dynamic: Hint for texture placement that
            the texture will be updated very
            frequently.
        nearest_neighbor_upsampling: Whether to use nearest neighbor interpolation
            instead of bilinear interpolation when upscaling
            the texture. Must be set before set_value.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def set_value(self, value):
        """
        Pass an array as texture data.
        The currently native formats are:
        - data type: uint8 or float32.
            Anything else will be converted to float32
            float32 data must be normalized between 0 and 1.
        - number of channels: 1 (R), 2 (RG), 3 (RGB), 4 (RGBA)

        In the case of single channel textures, during rendering, R is
        duplicated on G and B, thus the texture is displayed as gray,
        not red.

        If set_value is called on a texture which already
        has content, the previous allocation will be reused
        if the size, type and number of channels is identical.

        The data is uploaded right away during set_value,
        thus the call is not instantaneous.
        The data can be discarded after set_value.

        If you change the data of a texture, you don't
        need to bind it again to the objects it is
        bound. The objects will automatically take
        the updated texture.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Texture:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def height(self) -> int:
        """
 Height of the current texture content 
        """
        ...


    @property
    def hint_dynamic(self) -> bool:
        """
        Hint for texture placement that
        the texture will be updated very
        frequently.
        
        """
        ...


    @hint_dynamic.setter
    def hint_dynamic(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def nearest_neighbor_upsampling(self) -> int:
        """
        Whether to use nearest neighbor interpolation
        instead of bilinear interpolation when upscaling
        the texture. Must be set before set_value.
        
        """
        ...


    @nearest_neighbor_upsampling.setter
    def nearest_neighbor_upsampling(self, value : int):
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def num_chans(self) -> int:
        """
 Number of channels of the current texture content 
        """
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> Texture:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Texture):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def width(self) -> int:
        """
 Width of the current texture content 
        """
        ...


class ThemeColorImGui(baseTheme):
    """
    Theme color parameters that affect how ImGui
    renders items.
    All colors accept three formats:
    - unsigned (encodes a rgba little-endian)
    - (r, g, b, a) with r, g, b, a as integers.
    - (r, g, b, a) with r, g, b, a as floats.

    When r, g, b, a are floats, they should be normalized
    between 0 and 1, while integers are between 0 and 255.
    If a is missing, it defaults to 255.

    Keyword Arguments:
        Text: Color for text rendering
        TextDisabled: Color for the text of disabled items
        WindowBg: Background of normal windows
        ChildBg:  Background of child windows
        PopupBg: Background of popups, menus, tooltips windows
        Border: Color of borders
        BorderShadow: Color of border shadows
        FrameBg: Background of checkbox, radio button, plot, slider, text input
        FrameBgHovered: Color of FrameBg when the item is hovered
        FrameBgActive: Color of FrameBg when the item is active
        TitleBg: Title bar
        TitleBgActive: Title bar when focused
        TitleBgCollapsed: Title bar when collapsed
        MenuBarBg: Background color of the menu bar
        ScrollbarBg: Background color of the scroll bar
        ScrollbarGrab: Color of the scroll slider
        ScrollbarGrabHovered: Color of the scroll slider when hovered
        ScrollbarGrabActive: Color of the scroll slider when selected
        CheckMark: Checkbox tick and RadioButton circle
        SliderGrab: Color of sliders
        SliderGrabActive: Color of selected sliders
        Button: Color of buttons
        ButtonHovered: Color of buttons when hovered
        ButtonActive: Color of buttons when selected
        Header: Header* colors are used for CollapsingHeader, TreeNode, Selectable, MenuItem
        HeaderHovered: Header color when hovered
        HeaderActive: Header color when clicked
        Separator: Color of separators
        SeparatorHovered: Color of separator when hovered
        SeparatorActive: Color of separator when active
        ResizeGrip: Resize grip in lower-right and lower-left corners of windows.
        ResizeGripHovered: ResizeGrip when hovered
        ResizeGripActive: ResizeGrip when clicked
        TabHovered: Tab background, when hovered
        Tab: Tab background, when tab-bar is focused & tab is unselected
        TabSelected: Tab background, when tab-bar is focused & tab is selected
        TabSelectedOverline: Tab horizontal overline, when tab-bar is focused & tab is selected
        TabDimmed: Tab background, when tab-bar is unfocused & tab is unselected
        TabDimmedSelected: Tab background, when tab-bar is unfocused & tab is selected
        TabDimmedSelectedOverline: ..horizontal overline, when tab-bar is unfocused & tab is selected
        PlotLines: Color of SimplePlot lines
        PlotLinesHovered: Color of SimplePlot lines when hovered
        PlotHistogram: Color of SimplePlot histogram
        PlotHistogramHovered: Color of SimplePlot histogram when hovered
        TableHeaderBg: Table header background
        TableBorderStrong: Table outer and header borders (prefer using Alpha=1.0 here)
        TableBorderLight: Table inner borders (prefer using Alpha=1.0 here)
        TableRowBg: Table row background (even rows)
        TableRowBgAlt: Table row background (odd rows)
        TextLink: Hyperlink color
        TextSelectedBg: Color of the background of selected text
        DragDropTarget: Rectangle highlighting a drop target
        NavHighlight: Gamepad/keyboard: current highlighted item
        NavWindowingHighlight: Highlight window when using CTRL+TAB
        NavWindowingDimBg: Darken/colorize entire screen behind the CTRL+TAB window list, when active
        ModalWindowDimBg: Darken/colorize entire screen behind a modal window, when one is active
    
    """
    def __init__(self, context : Context, Border : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, BorderShadow : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Button : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ButtonActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ButtonHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, CheckMark : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ChildBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, DragDropTarget : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, FrameBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, FrameBgActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, FrameBgHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Header : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, HeaderActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, HeaderHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, MenuBarBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ModalWindowDimBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, NavCursor : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, NavWindowingDimBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, NavWindowingHighlight : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotHistogram : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotHistogramHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotLines : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotLinesHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PopupBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ResizeGrip : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ResizeGripActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ResizeGripHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ScrollbarBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ScrollbarGrab : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ScrollbarGrabActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ScrollbarGrabHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Separator : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, SeparatorActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, SeparatorHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, SliderGrab : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, SliderGrabActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Tab : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabDimmed : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabDimmedSelected : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabDimmedSelectedOverline : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabSelected : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabSelectedOverline : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableBorderLight : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableBorderStrong : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableHeaderBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableRowBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableRowBgAlt : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Text : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TextDisabled : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TextLink : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TextSelectedBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TitleBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TitleBgActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TitleBgCollapsed : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, WindowBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeColorImGui = ..., user_data : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, Border : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, BorderShadow : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Button : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ButtonActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ButtonHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, CheckMark : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ChildBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, DragDropTarget : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, FrameBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, FrameBgActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, FrameBgHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Header : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, HeaderActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, HeaderHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, MenuBarBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ModalWindowDimBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, NavCursor : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, NavWindowingDimBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, NavWindowingHighlight : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotHistogram : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotHistogramHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotLines : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotLinesHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PopupBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ResizeGrip : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ResizeGripActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ResizeGripHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ScrollbarBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ScrollbarGrab : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ScrollbarGrabActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ScrollbarGrabHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Separator : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, SeparatorActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, SeparatorHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, SliderGrab : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, SliderGrabActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Tab : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabDimmed : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabDimmedSelected : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabDimmedSelectedOverline : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabSelected : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TabSelectedOverline : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableBorderLight : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableBorderStrong : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableHeaderBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableRowBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TableRowBgAlt : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Text : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TextDisabled : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TextLink : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TextSelectedBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TitleBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TitleBgActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TitleBgCollapsed : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, WindowBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeColorImGui = ..., user_data : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeColorImGui:
        ...


    @property
    def Border(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Border.setter
    def Border(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def BorderShadow(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @BorderShadow.setter
    def BorderShadow(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Button(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Button.setter
    def Button(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ButtonActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ButtonActive.setter
    def ButtonActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ButtonHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ButtonHovered.setter
    def ButtonHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def CheckMark(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @CheckMark.setter
    def CheckMark(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ChildBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ChildBg.setter
    def ChildBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def DragDropTarget(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @DragDropTarget.setter
    def DragDropTarget(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def FrameBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @FrameBg.setter
    def FrameBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def FrameBgActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @FrameBgActive.setter
    def FrameBgActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def FrameBgHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @FrameBgHovered.setter
    def FrameBgHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Header(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Header.setter
    def Header(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def HeaderActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @HeaderActive.setter
    def HeaderActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def HeaderHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @HeaderHovered.setter
    def HeaderHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def MenuBarBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @MenuBarBg.setter
    def MenuBarBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ModalWindowDimBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ModalWindowDimBg.setter
    def ModalWindowDimBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def NavCursor(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @NavCursor.setter
    def NavCursor(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def NavWindowingDimBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @NavWindowingDimBg.setter
    def NavWindowingDimBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def NavWindowingHighlight(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @NavWindowingHighlight.setter
    def NavWindowingHighlight(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def PlotHistogram(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @PlotHistogram.setter
    def PlotHistogram(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def PlotHistogramHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @PlotHistogramHovered.setter
    def PlotHistogramHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def PlotLines(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @PlotLines.setter
    def PlotLines(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def PlotLinesHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @PlotLinesHovered.setter
    def PlotLinesHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def PopupBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @PopupBg.setter
    def PopupBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ResizeGrip(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ResizeGrip.setter
    def ResizeGrip(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ResizeGripActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ResizeGripActive.setter
    def ResizeGripActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ResizeGripHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ResizeGripHovered.setter
    def ResizeGripHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ScrollbarBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ScrollbarBg.setter
    def ScrollbarBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ScrollbarGrab(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ScrollbarGrab.setter
    def ScrollbarGrab(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ScrollbarGrabActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ScrollbarGrabActive.setter
    def ScrollbarGrabActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ScrollbarGrabHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ScrollbarGrabHovered.setter
    def ScrollbarGrabHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Separator(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Separator.setter
    def Separator(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def SeparatorActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @SeparatorActive.setter
    def SeparatorActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def SeparatorHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @SeparatorHovered.setter
    def SeparatorHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def SliderGrab(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @SliderGrab.setter
    def SliderGrab(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def SliderGrabActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @SliderGrabActive.setter
    def SliderGrabActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Tab(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Tab.setter
    def Tab(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TabDimmed(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TabDimmed.setter
    def TabDimmed(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TabDimmedSelected(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TabDimmedSelected.setter
    def TabDimmedSelected(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TabDimmedSelectedOverline(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TabDimmedSelectedOverline.setter
    def TabDimmedSelectedOverline(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TabHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TabHovered.setter
    def TabHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TabSelected(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TabSelected.setter
    def TabSelected(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TabSelectedOverline(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TabSelectedOverline.setter
    def TabSelectedOverline(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TableBorderLight(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TableBorderLight.setter
    def TableBorderLight(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TableBorderStrong(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TableBorderStrong.setter
    def TableBorderStrong(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TableHeaderBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TableHeaderBg.setter
    def TableHeaderBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TableRowBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TableRowBg.setter
    def TableRowBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TableRowBgAlt(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TableRowBgAlt.setter
    def TableRowBgAlt(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Text(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Text.setter
    def Text(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TextDisabled(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TextDisabled.setter
    def TextDisabled(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TextLink(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TextLink.setter
    def TextLink(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TextSelectedBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TextSelectedBg.setter
    def TextSelectedBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TitleBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TitleBg.setter
    def TitleBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TitleBgActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TitleBgActive.setter
    def TitleBgActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TitleBgCollapsed(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TitleBgCollapsed.setter
    def TitleBgCollapsed(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def WindowBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @WindowBg.setter
    def WindowBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeColorImGui:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeColorImGui):
        ...


    @property
    def user_data(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeColorImNodes(baseTheme):
    def __init__(self, context : Context, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeColorImNodes = ..., user_data : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeColorImNodes = ..., user_data : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeColorImNodes:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeColorImNodes:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeColorImNodes):
        ...


    @property
    def user_data(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeColorImPlot(baseTheme):
    def __init__(self, context : Context, AxisBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisBgActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisBgHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisGrid : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisText : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisTick : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Crosshairs : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ErrorBar : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, FrameBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, InlayText : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, LegendBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, LegendBorder : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, LegendText : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Line : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, MarkerFill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, MarkerOutline : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotBorder : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Selection : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TitleText : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeColorImPlot = ..., user_data : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, AxisBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisBgActive : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisBgHovered : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisGrid : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisText : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, AxisTick : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Crosshairs : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, ErrorBar : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Fill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, FrameBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, InlayText : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, LegendBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, LegendBorder : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, LegendText : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Line : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, MarkerFill : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, MarkerOutline : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotBg : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, PlotBorder : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, Selection : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, TitleText : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeColorImPlot = ..., user_data : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None = None):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeColorImPlot:
        ...


    @property
    def AxisBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @AxisBg.setter
    def AxisBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def AxisBgActive(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @AxisBgActive.setter
    def AxisBgActive(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def AxisBgHovered(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @AxisBgHovered.setter
    def AxisBgHovered(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def AxisGrid(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @AxisGrid.setter
    def AxisGrid(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def AxisText(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @AxisText.setter
    def AxisText(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def AxisTick(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @AxisTick.setter
    def AxisTick(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Crosshairs(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Crosshairs.setter
    def Crosshairs(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def ErrorBar(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @ErrorBar.setter
    def ErrorBar(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Fill(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Fill.setter
    def Fill(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def FrameBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @FrameBg.setter
    def FrameBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def InlayText(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @InlayText.setter
    def InlayText(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def LegendBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @LegendBg.setter
    def LegendBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def LegendBorder(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @LegendBorder.setter
    def LegendBorder(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def LegendText(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @LegendText.setter
    def LegendText(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Line(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Line.setter
    def Line(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def MarkerFill(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @MarkerFill.setter
    def MarkerFill(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def MarkerOutline(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @MarkerOutline.setter
    def MarkerOutline(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def PlotBg(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @PlotBg.setter
    def PlotBg(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def PlotBorder(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @PlotBorder.setter
    def PlotBorder(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def Selection(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @Selection.setter
    def Selection(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def TitleText(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        ...


    @TitleText.setter
    def TitleText(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeColorImPlot:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeColorImPlot):
        ...


    @property
    def user_data(self) -> int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : int | tuple[int, int, int] | tuple[int, int, int, int] | tuple[float, float, float] | tuple[float, float, float, float]| None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeList(baseTheme):
    """
    A set of base theme elements to apply when we render an item.
    Warning: it is bad practice to bind a theme to every item, and
    is not free on CPU. Instead set the theme as high as possible in
    the rendering hierarchy, and only change locally reduced sets
    of theme elements if needed.

    Contains theme styles and colors.
    Can contain a theme list.
    Can be bound to items.

    WARNING: if you bind a theme element to an item,
    and that theme element belongs to a theme list,
    the siblings before the theme element will get
    applied as well.
    
    """
    def __init__(self, context : Context, children : list[baseTheme] = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeList = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[baseTheme] = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeList = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeList:
        ...


    @property
    def children(self) -> list[baseTheme]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseTheme]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeList:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeList):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeListWithCondition(baseTheme):
    """
    A ThemeList but with delayed activation.
    If during rendering of the children the condition
    is met, then the theme gets applied.

    Contains theme styles and colors.
    Can contain a theme list.
    Can be in a theme list
    Can be bound to items.
    Concatenates with previous theme lists with
    conditions during rendering.
    The condition gets checked on the bound item,
    not just the children.

    As the elements in this list get checked everytime
    a item in the child tree is rendered, use this lightly.
    
    """
    def __init__(self, context : Context, children : list[baseTheme] = [], condition_category : ThemeCategories = 0, condition_enabled : ThemeEnablers = 0, enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeListWithCondition = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_category: As long as it is active, the theme list
            waits to be applied that the conditions are met.
            category condition: 0: no condition. other value: see list
        condition_enabled: As long as it is active, the theme list
            waits to be applied that the conditions are met.
            enabled condition: 0: no condition. 1: enabled must be true. 2: enabled must be false
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[baseTheme] = [], condition_category : ThemeCategories = 0, condition_enabled : ThemeEnablers = 0, enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeListWithCondition = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_category: As long as it is active, the theme list
            waits to be applied that the conditions are met.
            category condition: 0: no condition. other value: see list
        condition_enabled: As long as it is active, the theme list
            waits to be applied that the conditions are met.
            enabled condition: 0: no condition. 1: enabled must be true. 2: enabled must be false
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeListWithCondition:
        ...


    @property
    def children(self) -> list[baseTheme]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseTheme]):
        ...


    @property
    def condition_category(self) -> ThemeCategories:
        """
        Writable attribute: As long as it is active, the theme list
        waits to be applied that the conditions are met.
        category condition: 0: no condition. other value: see list
        
        """
        ...


    @condition_category.setter
    def condition_category(self, value : ThemeCategories):
        ...


    @property
    def condition_enabled(self) -> ThemeEnablers:
        """
        Writable attribute: As long as it is active, the theme list
        waits to be applied that the conditions are met.
        enabled condition: 0: no condition. 1: enabled must be true. 2: enabled must be false
        
        """
        ...


    @condition_enabled.setter
    def condition_enabled(self, value : ThemeEnablers):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeListWithCondition:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeListWithCondition):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeStopCondition(baseTheme):
    """
    a Theme that blocks any previous theme
    list with condition from propagating to children
    of the item bound. Does not affect the bound item.

    Does not work inside a ThemeListWithCondition
    
    """
    def __init__(self, context : Context, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeStopCondition = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeStopCondition = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeStopCondition:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeStopCondition:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeStopCondition):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeStyleImGui(baseThemeStyle):
    def __init__(self, context : Context, Alpha : float | None = None, ButtonTextAlign : tuple[float, float] | None = None, CellPadding : tuple[float, float] | None = None, ChildBorderSize : float | None = None, ChildRounding : float | None = None, DisabledAlpha : float | None = None, FrameBorderSize : float | None = None, FramePadding : tuple[float, float] | None = None, FrameRounding : float | None = None, GrabMinSize : float | None = None, GrabRounding : float | None = None, IndentSpacing : float | None = None, ItemInnerSpacing : tuple[float, float] | None = None, ItemSpacing : tuple[float, float] | None = None, PopupBorderSize : float | None = None, PopupRounding : float | None = None, ScrollbarRounding : float | None = None, ScrollbarSize : float | None = None, SelectableTextAlign : tuple[float, float] | None = None, SeparatorTextBorderSize : float | None = None, SeparatorTextPadding : tuple[float, float] | None = None, TabBarBorderSize : float | None = None, TabBarOverlineSize : float | None = None, TabBorderSize : float | None = None, TabRounding : float | None = None, TableAngledHeadersAngle : float | None = None, TableAngledHeadersTextAlign : tuple[float, float] | None = None, WindowBorderSize : float | None = None, WindowMinSize : tuple[float, float] | None = None, WindowPadding : tuple[float, float] | None = None, WindowRounding : float | None = None, WindowTitleAlign : tuple[float, float] | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeStyleImGui = ..., user_data : tuple[float, float] | None = None):
        """

        Alpha: Global alpha applied to everything in Dear ImGui.
        ButtonTextAlign: Alignment of button text when button is larger than text.
        
            The value is a pair of floats. Defaults to (0.5, 0.5), i.e. centered
        CellPadding: Tables: padding between cells.
            The x padding is applied for the whole Table,
            while y can be different for every row.
        ChildBorderSize: Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        ChildRounding: Radius of child window corners rounding. Set to 0.0 to have rectangular child windows.
        DisabledAlpha: Unused currently.
        FrameBorderSize: Thickness of border around frames (most widgets). Generally set to 0.0f or 1.0f. Other values not well tested.
        FramePadding: Padding within a framed rectangle (used by most widgets)
        FrameRounding: Radius of frame corners rounding. Set to 0.0 to have rectangular frame (most widgets).
        GrabMinSize: Minimum width/height of a grab box for slider/scrollbar.
        GrabRounding: Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
        IndentSpacing: Default horizontal spacing for indentations. For instance when entering a tree node.
            A good value is Generally == (FontSize + FramePadding.x*2).
        ItemInnerSpacing: Horizontal and vertical spacing between elements inside of a composed widget.
        ItemSpacing: Horizontal and vertical spacing between widgets/lines.
        PopupBorderSize: Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        PopupRounding: Radius of popup or tooltip window corners rounding. Set to 0.0 to have rectangular popup or tooltip windows.
        ScrollbarRounding: Radius of grab corners rounding for scrollbar.
        ScrollbarSize: Width of the vertical scrollbar, Height of the horizontal scrollbar
        SelectableTextAlign: Alignment of text within the separator in percentages.
        
            The value is a pair of floats. Defaults to (0., 0.5), i.e. left-centered
        SeparatorTextBorderSize: Thickness of border in Separator() text.
        
            The value is a float. Defaults to 3.
        SeparatorTextPadding: Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
        
            The value is a pair of floats. Defaults to (20., 3.).
        TabBarBorderSize: Thickness of tab-bar separator, which takes on the tab active color to denote focus.
        TabBarOverlineSize: Thickness of tab-bar overline, which highlights the selected tab-bar.
        TabBorderSize: Thickness of borders around tabs.
        TabRounding: Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
        TableAngledHeadersAngle: Tables: Angle of angled headers (supported values range from -50 degrees to +50 degrees).
        TableAngledHeadersTextAlign: Tables: Alignment (percentages) of angled headers within the cell
        
            The value is a pair of floats. Defaults to (0.5, 0.), i.e. top-centered
        WindowBorderSize: Thickness of border around windows. Generally set to 0.0 or 1.0f. Other values not well tested.
        WindowMinSize: Minimum window size
        WindowPadding: Padding within a window.
        WindowRounding: Radius of window corners rounding. Set to 0.0 to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
        WindowTitleAlign: Alignment for window title bar text in percentages
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, Alpha : float | None = None, ButtonTextAlign : tuple[float, float] | None = None, CellPadding : tuple[float, float] | None = None, ChildBorderSize : float | None = None, ChildRounding : float | None = None, DisabledAlpha : float | None = None, FrameBorderSize : float | None = None, FramePadding : tuple[float, float] | None = None, FrameRounding : float | None = None, GrabMinSize : float | None = None, GrabRounding : float | None = None, IndentSpacing : float | None = None, ItemInnerSpacing : tuple[float, float] | None = None, ItemSpacing : tuple[float, float] | None = None, PopupBorderSize : float | None = None, PopupRounding : float | None = None, ScrollbarRounding : float | None = None, ScrollbarSize : float | None = None, SelectableTextAlign : tuple[float, float] | None = None, SeparatorTextBorderSize : float | None = None, SeparatorTextPadding : tuple[float, float] | None = None, TabBarBorderSize : float | None = None, TabBarOverlineSize : float | None = None, TabBorderSize : float | None = None, TabRounding : float | None = None, TableAngledHeadersAngle : float | None = None, TableAngledHeadersTextAlign : tuple[float, float] | None = None, WindowBorderSize : float | None = None, WindowMinSize : tuple[float, float] | None = None, WindowPadding : tuple[float, float] | None = None, WindowRounding : float | None = None, WindowTitleAlign : tuple[float, float] | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeStyleImGui = ..., user_data : tuple[float, float] | None = None):
        """
        Alpha: Global alpha applied to everything in Dear ImGui.
        ButtonTextAlign: Alignment of button text when button is larger than text.
        
            The value is a pair of floats. Defaults to (0.5, 0.5), i.e. centered
        CellPadding: Tables: padding between cells.
            The x padding is applied for the whole Table,
            while y can be different for every row.
        ChildBorderSize: Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        ChildRounding: Radius of child window corners rounding. Set to 0.0 to have rectangular child windows.
        DisabledAlpha: Unused currently.
        FrameBorderSize: Thickness of border around frames (most widgets). Generally set to 0.0f or 1.0f. Other values not well tested.
        FramePadding: Padding within a framed rectangle (used by most widgets)
        FrameRounding: Radius of frame corners rounding. Set to 0.0 to have rectangular frame (most widgets).
        GrabMinSize: Minimum width/height of a grab box for slider/scrollbar.
        GrabRounding: Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.
        IndentSpacing: Default horizontal spacing for indentations. For instance when entering a tree node.
            A good value is Generally == (FontSize + FramePadding.x*2).
        ItemInnerSpacing: Horizontal and vertical spacing between elements inside of a composed widget.
        ItemSpacing: Horizontal and vertical spacing between widgets/lines.
        PopupBorderSize: Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.
        PopupRounding: Radius of popup or tooltip window corners rounding. Set to 0.0 to have rectangular popup or tooltip windows.
        ScrollbarRounding: Radius of grab corners rounding for scrollbar.
        ScrollbarSize: Width of the vertical scrollbar, Height of the horizontal scrollbar
        SelectableTextAlign: Alignment of text within the separator in percentages.
        
            The value is a pair of floats. Defaults to (0., 0.5), i.e. left-centered
        SeparatorTextBorderSize: Thickness of border in Separator() text.
        
            The value is a float. Defaults to 3.
        SeparatorTextPadding: Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
        
            The value is a pair of floats. Defaults to (20., 3.).
        TabBarBorderSize: Thickness of tab-bar separator, which takes on the tab active color to denote focus.
        TabBarOverlineSize: Thickness of tab-bar overline, which highlights the selected tab-bar.
        TabBorderSize: Thickness of borders around tabs.
        TabRounding: Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.
        TableAngledHeadersAngle: Tables: Angle of angled headers (supported values range from -50 degrees to +50 degrees).
        TableAngledHeadersTextAlign: Tables: Alignment (percentages) of angled headers within the cell
        
            The value is a pair of floats. Defaults to (0.5, 0.), i.e. top-centered
        WindowBorderSize: Thickness of border around windows. Generally set to 0.0 or 1.0f. Other values not well tested.
        WindowMinSize: Minimum window size
        WindowPadding: Padding within a window.
        WindowRounding: Radius of window corners rounding. Set to 0.0 to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.
        WindowTitleAlign: Alignment for window title bar text in percentages
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeStyleImGui:
        ...


    @property
    def Alpha(self) -> float | None:
        """
        Global alpha applied to everything in Dear ImGui.

        The value is in the range [0, 1]. Defaults to 1.
        
        """
        ...


    @Alpha.setter
    def Alpha(self, value : float | None):
        ...


    @property
    def ButtonTextAlign(self) -> tuple[float, float] | None:
        """
        Alignment of button text when button is larger than text.
    
        The value is a pair of floats. Defaults to (0.5, 0.5), i.e. centered
        
        """
        ...


    @ButtonTextAlign.setter
    def ButtonTextAlign(self, value : tuple[float, float] | None):
        ...


    @property
    def CellPadding(self) -> tuple[float, float] | None:
        """
        Tables: padding between cells.
        The x padding is applied for the whole Table,
        while y can be different for every row.

        The value is a pair of floats. Defaults to (4, 2).
        
        """
        ...


    @CellPadding.setter
    def CellPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def ChildBorderSize(self) -> float | None:
        """
        Thickness of border around child windows. Generally set to 0.0f or 1.0f. Other values not well tested.

        The value is a float. Defaults to 1.
        
        """
        ...


    @ChildBorderSize.setter
    def ChildBorderSize(self, value : float | None):
        ...


    @property
    def ChildRounding(self) -> float | None:
        """
        Radius of child window corners rounding. Set to 0.0 to have rectangular child windows.

        The value is a float. Defaults to 0.
        
        """
        ...


    @ChildRounding.setter
    def ChildRounding(self, value : float | None):
        ...


    @property
    def DisabledAlpha(self) -> float | None:
        """
        Unused currently.

        The value is in the range [0, 1]. Defaults to 0.6
        
        """
        ...


    @DisabledAlpha.setter
    def DisabledAlpha(self, value : float | None):
        ...


    @property
    def FrameBorderSize(self) -> float | None:
        """
        Thickness of border around frames (most widgets). Generally set to 0.0f or 1.0f. Other values not well tested.

        The value is a float. Defaults to 0.
        
        """
        ...


    @FrameBorderSize.setter
    def FrameBorderSize(self, value : float | None):
        ...


    @property
    def FramePadding(self) -> tuple[float, float] | None:
        """
        Padding within a framed rectangle (used by most widgets)

        The value is a pair of floats. Defaults to (4,3).
        
        """
        ...


    @FramePadding.setter
    def FramePadding(self, value : tuple[float, float] | None):
        ...


    @property
    def FrameRounding(self) -> float | None:
        """
        Radius of frame corners rounding. Set to 0.0 to have rectangular frame (most widgets).

        The value is a float. Defaults to 0.
        
        """
        ...


    @FrameRounding.setter
    def FrameRounding(self, value : float | None):
        ...


    @property
    def GrabMinSize(self) -> float | None:
        """
        Minimum width/height of a grab box for slider/scrollbar.

        The value is a float. Defaults to 12.
        
        """
        ...


    @GrabMinSize.setter
    def GrabMinSize(self, value : float | None):
        ...


    @property
    def GrabRounding(self) -> float | None:
        """
        Radius of grabs corners rounding. Set to 0.0f to have rectangular slider grabs.

        The value is a float. Defaults to 0.
        
        """
        ...


    @GrabRounding.setter
    def GrabRounding(self, value : float | None):
        ...


    @property
    def IndentSpacing(self) -> float | None:
        """
        Default horizontal spacing for indentations. For instance when entering a tree node.
        A good value is Generally == (FontSize + FramePadding.x*2).

        The value is a float. Defaults to 21.
        
        """
        ...


    @IndentSpacing.setter
    def IndentSpacing(self, value : float | None):
        ...


    @property
    def ItemInnerSpacing(self) -> tuple[float, float] | None:
        """
        Horizontal and vertical spacing between elements inside of a composed widget.

        The value is a pair of floats. Defaults to (4, 4).
        
        """
        ...


    @ItemInnerSpacing.setter
    def ItemInnerSpacing(self, value : tuple[float, float] | None):
        ...


    @property
    def ItemSpacing(self) -> tuple[float, float] | None:
        """
        Horizontal and vertical spacing between widgets/lines.

        The value is a pair of floats. Defaults to (8, 4).
        
        """
        ...


    @ItemSpacing.setter
    def ItemSpacing(self, value : tuple[float, float] | None):
        ...


    @property
    def PopupBorderSize(self) -> float | None:
        """
        Thickness of border around popup or tooltip windows. Generally set to 0.0f or 1.0f. Other values not well tested.

        The value is a float. Defaults to 1.
        
        """
        ...


    @PopupBorderSize.setter
    def PopupBorderSize(self, value : float | None):
        ...


    @property
    def PopupRounding(self) -> float | None:
        """
        Radius of popup or tooltip window corners rounding. Set to 0.0 to have rectangular popup or tooltip windows.

        The value is a float. Defaults to 0.
        
        """
        ...


    @PopupRounding.setter
    def PopupRounding(self, value : float | None):
        ...


    @property
    def ScrollbarRounding(self) -> float | None:
        """
        Radius of grab corners rounding for scrollbar.

        The value is a float. Defaults to 9.
        
        """
        ...


    @ScrollbarRounding.setter
    def ScrollbarRounding(self, value : float | None):
        ...


    @property
    def ScrollbarSize(self) -> float | None:
        """
        Width of the vertical scrollbar, Height of the horizontal scrollbar

        The value is a float. Defaults to 14.
        
        """
        ...


    @ScrollbarSize.setter
    def ScrollbarSize(self, value : float | None):
        ...


    @property
    def SelectableTextAlign(self) -> tuple[float, float] | None:
        """
        Alignment of text within the separator in percentages.
    
        The value is a pair of floats. Defaults to (0., 0.5), i.e. left-centered
        
        """
        ...


    @SelectableTextAlign.setter
    def SelectableTextAlign(self, value : tuple[float, float] | None):
        ...


    @property
    def SeparatorTextBorderSize(self) -> float | None:
        """
        Thickness of border in Separator() text.
    
        The value is a float. Defaults to 3.
        
        """
        ...


    @SeparatorTextBorderSize.setter
    def SeparatorTextBorderSize(self, value : float | None):
        ...


    @property
    def SeparatorTextPadding(self) -> tuple[float, float] | None:
        """
        Horizontal offset of text from each edge of the separator + spacing on other axis. Generally small values. .y is recommended to be == FramePadding.y.
    
        The value is a pair of floats. Defaults to (20., 3.).
        
        """
        ...


    @SeparatorTextPadding.setter
    def SeparatorTextPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def TabBarBorderSize(self) -> float | None:
        """
        Thickness of tab-bar separator, which takes on the tab active color to denote focus.

        The value is a float. Defaults to 1.
        
        """
        ...


    @TabBarBorderSize.setter
    def TabBarBorderSize(self, value : float | None):
        ...


    @property
    def TabBarOverlineSize(self) -> float | None:
        """
        Thickness of tab-bar overline, which highlights the selected tab-bar.

        The value is a float. Defaults to 2.
        
        """
        ...


    @TabBarOverlineSize.setter
    def TabBarOverlineSize(self, value : float | None):
        ...


    @property
    def TabBorderSize(self) -> float | None:
        """
        Thickness of borders around tabs.

        The value is a float. Defaults to 0.
        
        """
        ...


    @TabBorderSize.setter
    def TabBorderSize(self, value : float | None):
        ...


    @property
    def TabRounding(self) -> float | None:
        """
        Radius of upper corners of a tab. Set to 0.0f to have rectangular tabs.

        The value is a float. Defaults to 4.
        
        """
        ...


    @TabRounding.setter
    def TabRounding(self, value : float | None):
        ...


    @property
    def TableAngledHeadersAngle(self) -> float | None:
        """
        Tables: Angle of angled headers (supported values range from -50 degrees to +50 degrees).

        The value is a float. Defaults to 35.0f * (IM_PI / 180.0f).
        
        """
        ...


    @TableAngledHeadersAngle.setter
    def TableAngledHeadersAngle(self, value : float | None):
        ...


    @property
    def TableAngledHeadersTextAlign(self) -> tuple[float, float] | None:
        """
        Tables: Alignment (percentages) of angled headers within the cell
    
        The value is a pair of floats. Defaults to (0.5, 0.), i.e. top-centered
        
        """
        ...


    @TableAngledHeadersTextAlign.setter
    def TableAngledHeadersTextAlign(self, value : tuple[float, float] | None):
        ...


    @property
    def WindowBorderSize(self) -> float | None:
        """
        Thickness of border around windows. Generally set to 0.0 or 1.0f. Other values not well tested.

        The value is a float. Defaults to 1.
        
        """
        ...


    @WindowBorderSize.setter
    def WindowBorderSize(self, value : float | None):
        ...


    @property
    def WindowMinSize(self) -> tuple[float, float] | None:
        """
        Minimum window size

        The value is a pair of float (dx, dy). Defaults to (32, 32)
        
        """
        ...


    @WindowMinSize.setter
    def WindowMinSize(self, value : tuple[float, float] | None):
        ...


    @property
    def WindowPadding(self) -> tuple[float, float] | None:
        """
        Padding within a window.

        The value is a pair of float (dx, dy). Defaults to (8, 8)
        
        """
        ...


    @WindowPadding.setter
    def WindowPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def WindowRounding(self) -> float | None:
        """
        Radius of window corners rounding. Set to 0.0 to have rectangular windows. Large values tend to lead to variety of artifacts and are not recommended.

        The value is a float. Defaults to 0.
        
        """
        ...


    @WindowRounding.setter
    def WindowRounding(self, value : float | None):
        ...


    @property
    def WindowTitleAlign(self) -> tuple[float, float] | None:
        """
        Alignment for window title bar text in percentages

        The value is a pair of float (dx, dy). Defaults to (0., 0.5), which means left-aligned, vertical centering on the row
        
        """
        ...


    @WindowTitleAlign.setter
    def WindowTitleAlign(self, value : tuple[float, float] | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_rounding(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables rounding (after scaling) to the
        closest integer the parameters. The rounding is only
        applied to parameters which impact item positioning
        in a way that would prevent a pixel perfect result.
        
        """
        ...


    @no_rounding.setter
    def no_rounding(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this theme
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeStyleImGui:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeStyleImGui):
        ...


    @property
    def user_data(self) -> tuple[float, float] | None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : tuple[float, float] | None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeStyleImNodes(baseThemeStyle):
    def __init__(self, context : Context, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeStyleImNodes = ..., user_data : tuple[float, float] | None = None):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeStyleImNodes = ..., user_data : tuple[float, float] | None = None):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeStyleImNodes:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_rounding(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables rounding (after scaling) to the
        closest integer the parameters. The rounding is only
        applied to parameters which impact item positioning
        in a way that would prevent a pixel perfect result.
        
        """
        ...


    @no_rounding.setter
    def no_rounding(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this theme
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeStyleImNodes:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeStyleImNodes):
        ...


    @property
    def user_data(self) -> tuple[float, float] | None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : tuple[float, float] | None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ThemeStyleImPlot(baseThemeStyle):
    def __init__(self, context : Context, AnnotationPadding : tuple[float, float] | None = None, DigitalBitGap : float | None = None, DigitalBitHeight : float | None = None, ErrorBarSize : float | None = None, ErrorBarWeight : float | None = None, FillAlpha : float | None = None, FitPadding : tuple[float, float] | None = None, LabelPadding : tuple[float, float] | None = None, LegendInnerPadding : tuple[float, float] | None = None, LegendPadding : tuple[float, float] | None = None, LegendSpacing : tuple[float, float] | None = None, LineWeight : float | None = None, MajorGridSize : tuple[float, float] | None = None, MajorTickLen : tuple[float, float] | None = None, MajorTickSize : tuple[float, float] | None = None, Marker : float | None = None, MarkerSize : float | None = None, MarkerWeight : float | None = None, MinorAlpha : float | None = None, MinorGridSize : tuple[float, float] | None = None, MinorTickLen : tuple[float, float] | None = None, MinorTickSize : tuple[float, float] | None = None, MousePosPadding : tuple[float, float] | None = None, PlotBorderSize : float | None = None, PlotDefaultSize : tuple[float, float] | None = None, PlotMinSize : tuple[float, float] | None = None, PlotPadding : tuple[float, float] | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeStyleImPlot = ..., user_data : tuple[float, float] | None = None):
        """

        AnnotationPadding: Text padding around annotation labels.
        DigitalBitGap: Digital channels bit padding gap in pixels.
        DigitalBitHeight: Digital channels bit height (at 1) in pixels.
        ErrorBarSize: Error bar whisker width in pixels.
        ErrorBarWeight: Error bar whisker weight in pixels.
        FillAlpha: Alpha modifier applied to all plot item fills.
        FitPadding: Additional fit padding as a percentage of the fit extents (e.g. (0.1,0.1) adds 10% to the fit extents of X and Y).
        LabelPadding: Padding between axes labels, tick labels, and plot edge.
        LegendInnerPadding: Legend inner padding from legend edges.
        LegendPadding: Legend padding from plot edges.
        LegendSpacing: Spacing between legend entries.
        LineWeight: Plot item line weight in pixels.
        MajorGridSize: Line thickness of major grid lines.
        MajorTickLen: Major tick lengths for X and Y axes.
        MajorTickSize: Line thickness of major ticks.
        Marker: Marker specification.
        MarkerSize: Marker size in pixels (roughly the marker's "radius").
        MarkerWeight: Plot outline weight of markers in pixels.
        MinorAlpha: Alpha multiplier applied to minor axis grid lines.
        MinorGridSize: Line thickness of minor grid lines.
        MinorTickLen: Minor tick lengths for X and Y axes.
        MinorTickSize: Line thickness of minor ticks.
        MousePosPadding: Padding between plot edge and interior info text.
        PlotBorderSize: Thickness of border around plot area.
        PlotDefaultSize: Default size used for plots
        PlotMinSize: Minimum size plot frame can be when shrunk.
        PlotPadding: Padding between widget frame and plot area, labels, or outside legends (i.e. main padding).
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, AnnotationPadding : tuple[float, float] | None = None, DigitalBitGap : float | None = None, DigitalBitHeight : float | None = None, ErrorBarSize : float | None = None, ErrorBarWeight : float | None = None, FillAlpha : float | None = None, FitPadding : tuple[float, float] | None = None, LabelPadding : tuple[float, float] | None = None, LegendInnerPadding : tuple[float, float] | None = None, LegendPadding : tuple[float, float] | None = None, LegendSpacing : tuple[float, float] | None = None, LineWeight : float | None = None, MajorGridSize : tuple[float, float] | None = None, MajorTickLen : tuple[float, float] | None = None, MajorTickSize : tuple[float, float] | None = None, Marker : float | None = None, MarkerSize : float | None = None, MarkerWeight : float | None = None, MinorAlpha : float | None = None, MinorGridSize : tuple[float, float] | None = None, MinorTickLen : tuple[float, float] | None = None, MinorTickSize : tuple[float, float] | None = None, MousePosPadding : tuple[float, float] | None = None, PlotBorderSize : float | None = None, PlotDefaultSize : tuple[float, float] | None = None, PlotMinSize : tuple[float, float] | None = None, PlotPadding : tuple[float, float] | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : ThemeStyleImPlot = ..., user_data : tuple[float, float] | None = None):
        """
        AnnotationPadding: Text padding around annotation labels.
        DigitalBitGap: Digital channels bit padding gap in pixels.
        DigitalBitHeight: Digital channels bit height (at 1) in pixels.
        ErrorBarSize: Error bar whisker width in pixels.
        ErrorBarWeight: Error bar whisker weight in pixels.
        FillAlpha: Alpha modifier applied to all plot item fills.
        FitPadding: Additional fit padding as a percentage of the fit extents (e.g. (0.1,0.1) adds 10% to the fit extents of X and Y).
        LabelPadding: Padding between axes labels, tick labels, and plot edge.
        LegendInnerPadding: Legend inner padding from legend edges.
        LegendPadding: Legend padding from plot edges.
        LegendSpacing: Spacing between legend entries.
        LineWeight: Plot item line weight in pixels.
        MajorGridSize: Line thickness of major grid lines.
        MajorTickLen: Major tick lengths for X and Y axes.
        MajorTickSize: Line thickness of major ticks.
        Marker: Marker specification.
        MarkerSize: Marker size in pixels (roughly the marker's "radius").
        MarkerWeight: Plot outline weight of markers in pixels.
        MinorAlpha: Alpha multiplier applied to minor axis grid lines.
        MinorGridSize: Line thickness of minor grid lines.
        MinorTickLen: Minor tick lengths for X and Y axes.
        MinorTickSize: Line thickness of minor ticks.
        MousePosPadding: Padding between plot edge and interior info text.
        PlotBorderSize: Thickness of border around plot area.
        PlotDefaultSize: Default size used for plots
        PlotMinSize: Minimum size plot frame can be when shrunk.
        PlotPadding: Padding between widget frame and plot area, labels, or outside legends (i.e. main padding).
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ThemeStyleImPlot:
        ...


    @property
    def AnnotationPadding(self) -> tuple[float, float] | None:
        """
        Text padding around annotation labels.

        The value is a pair of floats. Defaults to (2, 2).
        
        """
        ...


    @AnnotationPadding.setter
    def AnnotationPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def DigitalBitGap(self) -> float | None:
        """
        Digital channels bit padding gap in pixels.

        The value is a float. Defaults to 4.
        
        """
        ...


    @DigitalBitGap.setter
    def DigitalBitGap(self, value : float | None):
        ...


    @property
    def DigitalBitHeight(self) -> float | None:
        """
        Digital channels bit height (at 1) in pixels.

        The value is a float. Defaults to 8.
        
        """
        ...


    @DigitalBitHeight.setter
    def DigitalBitHeight(self, value : float | None):
        ...


    @property
    def ErrorBarSize(self) -> float | None:
        """
        Error bar whisker width in pixels.

        The value is a float. Defaults to 5.
        
        """
        ...


    @ErrorBarSize.setter
    def ErrorBarSize(self, value : float | None):
        ...


    @property
    def ErrorBarWeight(self) -> float | None:
        """
        Error bar whisker weight in pixels.

        The value is a float. Defaults to 1.5.
        
        """
        ...


    @ErrorBarWeight.setter
    def ErrorBarWeight(self, value : float | None):
        ...


    @property
    def FillAlpha(self) -> float | None:
        """
        Alpha modifier applied to all plot item fills.

        The value is a float. Defaults to 1.
        
        """
        ...


    @FillAlpha.setter
    def FillAlpha(self, value : float | None):
        ...


    @property
    def FitPadding(self) -> tuple[float, float] | None:
        """
        Additional fit padding as a percentage of the fit extents (e.g. (0.1,0.1) adds 10% to the fit extents of X and Y).

        The value is a pair of floats. Defaults to (0, 0).
        
        """
        ...


    @FitPadding.setter
    def FitPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def LabelPadding(self) -> tuple[float, float] | None:
        """
        Padding between axes labels, tick labels, and plot edge.

        The value is a pair of floats. Defaults to (5, 5).
        
        """
        ...


    @LabelPadding.setter
    def LabelPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def LegendInnerPadding(self) -> tuple[float, float] | None:
        """
        Legend inner padding from legend edges.

        The value is a pair of floats. Defaults to (5, 5).
        
        """
        ...


    @LegendInnerPadding.setter
    def LegendInnerPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def LegendPadding(self) -> tuple[float, float] | None:
        """
        Legend padding from plot edges.

        The value is a pair of floats. Defaults to (10, 10).
        
        """
        ...


    @LegendPadding.setter
    def LegendPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def LegendSpacing(self) -> tuple[float, float] | None:
        """
        Spacing between legend entries.

        The value is a pair of floats. Defaults to (5, 0).
        
        """
        ...


    @LegendSpacing.setter
    def LegendSpacing(self, value : tuple[float, float] | None):
        ...


    @property
    def LineWeight(self) -> float | None:
        """
        Plot item line weight in pixels.

        The value is a float. Defaults to 1.
        
        """
        ...


    @LineWeight.setter
    def LineWeight(self, value : float | None):
        ...


    @property
    def MajorGridSize(self) -> tuple[float, float] | None:
        """
        Line thickness of major grid lines.

        The value is a pair of floats. Defaults to (1, 1).
        
        """
        ...


    @MajorGridSize.setter
    def MajorGridSize(self, value : tuple[float, float] | None):
        ...


    @property
    def MajorTickLen(self) -> tuple[float, float] | None:
        """
        Major tick lengths for X and Y axes.

        The value is a pair of floats. Defaults to (10, 10).
        
        """
        ...


    @MajorTickLen.setter
    def MajorTickLen(self, value : tuple[float, float] | None):
        ...


    @property
    def MajorTickSize(self) -> tuple[float, float] | None:
        """
        Line thickness of major ticks.

        The value is a pair of floats. Defaults to (1, 1).
        
        """
        ...


    @MajorTickSize.setter
    def MajorTickSize(self, value : tuple[float, float] | None):
        ...


    @property
    def Marker(self) -> float | None:
        """
        Marker specification.

        The value is an integer. Defaults to 1.
        
        """
        ...


    @Marker.setter
    def Marker(self, value : float | None):
        ...


    @property
    def MarkerSize(self) -> float | None:
        """
        Marker size in pixels (roughly the marker's "radius").

        The value is a float. Defaults to 4.
        
        """
        ...


    @MarkerSize.setter
    def MarkerSize(self, value : float | None):
        ...


    @property
    def MarkerWeight(self) -> float | None:
        """
        Plot outline weight of markers in pixels.

        The value is a float. Defaults to 1.
        
        """
        ...


    @MarkerWeight.setter
    def MarkerWeight(self, value : float | None):
        ...


    @property
    def MinorAlpha(self) -> float | None:
        """
        Alpha multiplier applied to minor axis grid lines.

        The value is a float. Defaults to 0.25.
        
        """
        ...


    @MinorAlpha.setter
    def MinorAlpha(self, value : float | None):
        ...


    @property
    def MinorGridSize(self) -> tuple[float, float] | None:
        """
        Line thickness of minor grid lines.

        The value is a pair of floats. Defaults to (1, 1).
        
        """
        ...


    @MinorGridSize.setter
    def MinorGridSize(self, value : tuple[float, float] | None):
        ...


    @property
    def MinorTickLen(self) -> tuple[float, float] | None:
        """
        Minor tick lengths for X and Y axes.

        The value is a pair of floats. Defaults to (5, 5).
        
        """
        ...


    @MinorTickLen.setter
    def MinorTickLen(self, value : tuple[float, float] | None):
        ...


    @property
    def MinorTickSize(self) -> tuple[float, float] | None:
        """
        Line thickness of minor ticks.

        The value is a pair of floats. Defaults to (1, 1).
        
        """
        ...


    @MinorTickSize.setter
    def MinorTickSize(self, value : tuple[float, float] | None):
        ...


    @property
    def MousePosPadding(self) -> tuple[float, float] | None:
        """
        Padding between plot edge and interior info text.

        The value is a pair of floats. Defaults to (10, 10).
        
        """
        ...


    @MousePosPadding.setter
    def MousePosPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def PlotBorderSize(self) -> float | None:
        """
        Thickness of border around plot area.

        The value is a float. Defaults to 1.
        
        """
        ...


    @PlotBorderSize.setter
    def PlotBorderSize(self, value : float | None):
        ...


    @property
    def PlotDefaultSize(self) -> tuple[float, float] | None:
        """
        Default size used for plots

        The value is a pair of floats. Defaults to (400, 300).
        
        """
        ...


    @PlotDefaultSize.setter
    def PlotDefaultSize(self, value : tuple[float, float] | None):
        ...


    @property
    def PlotMinSize(self) -> tuple[float, float] | None:
        """
        Minimum size plot frame can be when shrunk.

        The value is a pair of floats. Defaults to (200, 150).
        
        """
        ...


    @PlotMinSize.setter
    def PlotMinSize(self, value : tuple[float, float] | None):
        ...


    @property
    def PlotPadding(self) -> tuple[float, float] | None:
        """
        Padding between widget frame and plot area, labels, or outside legends (i.e. main padding).

        The value is a pair of floats. Defaults to (10, 10).
        
        """
        ...


    @PlotPadding.setter
    def PlotPadding(self, value : tuple[float, float] | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_rounding(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables rounding (after scaling) to the
        closest integer the parameters. The rounding is only
        applied to parameters which impact item positioning
        in a way that would prevent a pixel perfect result.
        
        """
        ...


    @no_rounding.setter
    def no_rounding(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this theme
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> ThemeStyleImPlot:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ThemeStyleImPlot):
        ...


    @property
    def user_data(self) -> tuple[float, float] | None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : tuple[float, float] | None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class TimeWatcher(uiItem):
    """
    A placeholder uiItem parent that doesn't draw
    or have any impact on rendering.
    This item calls the callback with times in ns.
    These times can be compared with the times in the metrics
    that can be obtained from the viewport in order to
    precisely figure out the time spent rendering specific items.

    The first time corresponds to the time this item is called
    for rendering

    The second time corresponds to the time after the
    children have finished rendering.

    The third time corresponds to the time when viewport
    started rendering items for this frame. It is a duplicate of
    context.viewport.metrics.last_t_before_rendering. It is
    given to prevent the user from having to keep track of the
    viewport metrics (since the callback might be called
    after or before the viewport updated its metrics for this
    frame or another one).

    The fourth number corresponds to the frame count
    at the the time the callback was issued.

    Note the times relate to CPU time (checking states, preparing
    GPU data, etc), not to GPU rendering time.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : TimeWatcher = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : TimeWatcher = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TimeWatcher:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> TimeWatcher:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : TimeWatcher):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class ToggledCloseHandler(baseHandler):
    """
    Handler that triggers the callback when the
    item switches from an opened state to a closed
    state.
    *Warning*: Does not mean an item is un-shown
    by a user interaction (what we usually mean
    by closing a window).
    Here Close/Open refers to being in a
    reduced state when the full content is not
    shown, but could be if the user clicked on
    a specific button. The doesn't mean that
    the object is show or not shown.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ToggledCloseHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ToggledCloseHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ToggledCloseHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ToggledCloseHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ToggledCloseHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class ToggledOpenHandler(baseHandler):
    """
    Handler that triggers the callback when the
    item switches from an closed state to a opened
    state. Here Close/Open refers to being in a
    reduced state when the full content is not
    shown, but could be if the user clicked on
    a specific button. The doesn't mean that
    the object is show or not shown.
    
    """
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ToggledOpenHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ToggledOpenHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ToggledOpenHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ToggledOpenHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ToggledOpenHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Tooltip(uiItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], condition_from_handler : Any = ..., delay : float = 0.0, enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, hide_on_activity : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Tooltip = ..., target : Any = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_from_handler: When set, the handler referenced in
            this field will be used to replace
            the target hovering check. It will
            apply to target, which must be set.
        delay: Delay in seconds with no motion before showing the tooltip
            -1: Use imgui defaults
            Has no effect if the target is not the previous sibling,
            or if condition_from_handler is set.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hide_on_activity: Hide the tooltip when the mouse moves
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        target: Target item which state will be checked
            to trigger the tooltip.
            Note if the item is after this tooltip
            in the rendering tree, there will be
            a frame delay.
            If no target is set, the previous sibling
            is the target.
            If the target is not the previous sibling,
            delay will have no effect.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], condition_from_handler : Any = ..., delay : float = 0.0, enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, hide_on_activity : float = 0.0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : Tooltip = ..., target : Any = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        condition_from_handler: When set, the handler referenced in
            this field will be used to replace
            the target hovering check. It will
            apply to target, which must be set.
        delay: Delay in seconds with no motion before showing the tooltip
            -1: Use imgui defaults
            Has no effect if the target is not the previous sibling,
            or if condition_from_handler is set.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        hide_on_activity: Hide the tooltip when the mouse moves
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        target: Target item which state will be checked
            to trigger the tooltip.
            Note if the item is after this tooltip
            in the rendering tree, there will be
            a frame delay.
            If no target is set, the previous sibling
            is the target.
            If the target is not the previous sibling,
            delay will have no effect.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Tooltip:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def condition_from_handler(self):
        """
        When set, the handler referenced in
        this field will be used to replace
        the target hovering check. It will
        apply to target, which must be set.
        
        """
        ...


    @condition_from_handler.setter
    def condition_from_handler(self, value):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def delay(self) -> float:
        """
        Delay in seconds with no motion before showing the tooltip
        -1: Use imgui defaults
        Has no effect if the target is not the previous sibling,
        or if condition_from_handler is set.
        
        """
        ...


    @delay.setter
    def delay(self, value : float):
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hide_on_activity(self) -> float:
        """
        Hide the tooltip when the mouse moves
        
        """
        ...


    @hide_on_activity.setter
    def hide_on_activity(self, value : float):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Tooltip:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Tooltip):
        ...


    @property
    def target(self):
        """
        Target item which state will be checked
        to trigger the tooltip.
        Note if the item is after this tooltip
        in the rendering tree, there will be
        a frame delay.
        If no target is set, the previous sibling
        is the target.
        If the target is not the previous sibling,
        delay will have no effect.
        
        """
        ...


    @target.setter
    def target(self, value):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class TreeNode(uiItem):
    def __init__(self, context : Context, bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], default_open : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", leaf : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, open_on_arrow : bool = False, open_on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, selectable : bool = False, shareable_value : SharedBool = ..., show : bool = True, span_full_width : bool = False, span_text_width : bool = False, tag : TreeNode = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """

        bullet: Display a bullet instead of arrow.
            IMPORTANT: node can still be marked open/close if
            you don't set the _Leaf flag!
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        default_open: Default node to be open
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leaf: No collapsing, no arrow (use as a convenience for leaf nodes).
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        open_on_arrow: Only open when clicking on the arrow part.
            If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
            single-click arrow or double-click all box to open.
        open_on_double_click: Need double-click to open node
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        selectable: Draw the TreeNode as selected when opened
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        span_full_width: Extend hit box to the left-most
            and right-most edges (cover the indent area).
        span_text_width: Narrow hit box + narrow hovering
            highlight, will only cover the label text.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, bullet : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], default_open : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", leaf : bool = False, next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, open_on_arrow : bool = False, open_on_double_click : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, selectable : bool = False, shareable_value : SharedBool = ..., show : bool = True, span_full_width : bool = False, span_text_width : bool = False, tag : TreeNode = ..., theme : Any = ..., user_data : Any = ..., value : bool = False, width : int = 0):
        """
        bullet: Display a bullet instead of arrow.
            IMPORTANT: node can still be marked open/close if
            you don't set the _Leaf flag!
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        default_open: Default node to be open
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        leaf: No collapsing, no arrow (use as a convenience for leaf nodes).
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        open_on_arrow: Only open when clicking on the arrow part.
            If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
            single-click arrow or double-click all box to open.
        open_on_double_click: Need double-click to open node
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        selectable: Draw the TreeNode as selected when opened
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        span_full_width: Extend hit box to the left-most
            and right-most edges (cover the indent area).
        span_text_width: Narrow hit box + narrow hovering
            highlight, will only cover the label text.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> TreeNode:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def bullet(self) -> bool:
        """
        Writable attribute: Display a bullet instead of arrow.
        IMPORTANT: node can still be marked open/close if
        you don't set the _Leaf flag!
        
        """
        ...


    @bullet.setter
    def bullet(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def default_open(self) -> bool:
        """
        Writable attribute: Default node to be open
        
        """
        ...


    @default_open.setter
    def default_open(self, value : bool):
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def leaf(self) -> bool:
        """
        Writable attribute: No collapsing, no arrow (use as a convenience for leaf nodes).
        
        """
        ...


    @leaf.setter
    def leaf(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def open_on_arrow(self) -> bool:
        """
        Writable attribute:  Only open when clicking on the arrow part.
        If ImGuiTreeNodeFlags_OpenOnDoubleClick is also set,
        single-click arrow or double-click all box to open.
        
        """
        ...


    @open_on_arrow.setter
    def open_on_arrow(self, value : bool):
        ...


    @property
    def open_on_double_click(self) -> bool:
        """
        Writable attribute: Need double-click to open node
        
        """
        ...


    @open_on_double_click.setter
    def open_on_double_click(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def selectable(self) -> bool:
        """
        Writable attribute: Draw the TreeNode as selected when opened
        
        """
        ...


    @selectable.setter
    def selectable(self, value : bool):
        ...


    @property
    def shareable_value(self) -> SharedBool:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedBool):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def span_full_width(self) -> bool:
        """
        Writable attribute: Extend hit box to the left-most
        and right-most edges (cover the indent area).
        
        """
        ...


    @span_full_width.setter
    def span_full_width(self, value : bool):
        ...


    @property
    def span_text_width(self) -> bool:
        """
        Writable attribute: Narrow hit box + narrow hovering
        highlight, will only cover the label text.
        
        """
        ...


    @span_text_width.setter
    def span_text_width(self, value : bool):
        ...


    @property
    def tag(self) -> TreeNode:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : TreeNode):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self) -> bool:
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value : bool):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class VerticalLayout(Layout):
    """
    Same as HorizontalLayout but vertically
    
    """
    def __init__(self, context : Context, alignment_mode : Alignment = 0, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), positions : list = [], previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : VerticalLayout = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        alignment_mode: Vertical alignment mode of the items.
            TOP: items are appended from the top
            BOTTOM: items are appended from the BOTTOM
            CENTER: items are centered
            JUSTIFIED: spacing is organized such
            that items start at the TOP and end
            at the BOTTOM.
            MANUAL: items are positionned at the requested
            positions
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the y position starting
            from the top left of this item at which to
            place the children items.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, alignment_mode : Alignment = 0, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem] = [], enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), positions : list = [], previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : VerticalLayout = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        alignment_mode: Vertical alignment mode of the items.
            TOP: items are appended from the top
            BOTTOM: items are appended from the BOTTOM
            CENTER: items are centered
            JUSTIFIED: spacing is organized such
            that items start at the TOP and end
            at the BOTTOM.
            MANUAL: items are positionned at the requested
            positions
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        positions: When in MANUAL mode, the y position starting
            from the top left of this item at which to
            place the children items.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def update_layout(self):
        ...


    def __enter__(self) -> VerticalLayout:
        ...


    @property
    def activated(self) -> bool:
        """
        Readonly attribute: has the item just turned active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def active(self) -> bool:
        """
        Readonly attribute: is the item active.
        For example for a button, it is when pressed. For tabs
        it is when selected, etc.
        
        """
        ...


    @property
    def alignment_mode(self) -> Alignment:
        """
        Vertical alignment mode of the items.
        TOP: items are appended from the top
        BOTTOM: items are appended from the BOTTOM
        CENTER: items are centered
        JUSTIFIED: spacing is organized such
        that items start at the TOP and end
        at the BOTTOM.
        MANUAL: items are positionned at the requested
        positions

        FOR TOP/BOTTOM/CENTER, ItemSpacing's style can
        be used to control spacing between the items.
        Default is TOP.
        
        """
        ...


    @alignment_mode.setter
    def alignment_mode(self, value : Alignment):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def clicked(self) -> tuple:
        """
        Readonly attribute: has the item just been clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def deactivated(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def deactivated_after_edited(self) -> bool:
        """
        Readonly attribute: has the item just turned un-active after having
        been edited.
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def double_clicked(self) -> list:
        """
        Readonly attribute: has the item just been double-clicked.
        The returned value is a tuple of len 5 containing the individual test
        mouse buttons (up to 5 buttons)
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def edited(self) -> bool:
        """
        Readonly attribute: has the item just been edited ?
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def positions(self) -> list:
        """
        When in MANUAL mode, the y position starting
        from the top left of this item at which to
        place the children items.

        If the positions are between 0 and 1, they are
        interpreted as percentages relative to the
        size of the Layout height.
        If the positions are negatives, they are interpreted
        as in reference to the bottom of the layout rather
        than the top. Items are still top aligned to
        the target position though.

        Setting this field sets the alignment mode to
        MANUAL.
        
        """
        ...


    @positions.setter
    def positions(self, value : list):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> VerticalLayout:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : VerticalLayout):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def toggled(self) -> bool:
        """
        Has a menu/bar trigger been hit for the item
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class Viewport(baseItem):
    """
    The viewport corresponds to the main item containing
    all the visuals. It is decorated by the operating system,
    and can be minimized/maximized/made fullscreen.

    Rendering starts from the viewports and recursively
    every item renders itself and its children.
    
    """
    def __init__(self, context : Context, always_on_top : bool = False, children : list[Window, ViewportDrawList, MenuBar] = [], clear_color : tuple = (0.0, 0.0, 0.0, 1.0), close_callback : Any = ..., cursor : MouseCursor = 0, decorated : bool = True, disable_close : bool = False, font : Font = None, fullscreen : bool = False, handlers : list = ..., height : int = 800, large_icon : str = "b''", max_height : int = 10000, max_width : int = 10000, maximized : Any = ..., min_height : int = 250, min_width : int = 250, minimized : Any = ..., next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, resizable : bool = True, resize_callback : Any = ..., scale : float = 1.0, small_icon : str = "b''", tag : Viewport = ..., theme : Any = ..., title : str = "b'Dear CyGui'", user_data : Any = ..., vsync : bool = True, wait_for_input : bool = False, width : int = 1280, x_pos : int = 100, y_pos : int = 100):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        close_callback: Callback to be issued when the viewport is closed.
        cursor: Change the mouse cursor to one of MouseCursor.
            The mouse cursor is reset every frame.
        font: global font
        handlers: bound handler (or handlerList)
            for the viewport.
            Only Key and Mouse handlers are compatible.
            Handlers that check item states won't work.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resize_callback: Callback to be issued when the viewport is resized.
        scale: Multiplicative scale that, multiplied by
            the value of dpi, is used to scale
            automatically all items.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: global theme
        user_data: User data of any type.
        wait_for_input: When the app doesn't need to be
            refreshed, one can save power comsumption by not
            rendering. wait_for_input will pause rendering until
            a mouse or keyboard event is received.
            wake() can also be used to restart rendering
            for one frame.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_on_top : bool = False, children : list[Window, ViewportDrawList, MenuBar] = [], clear_color : tuple = (0.0, 0.0, 0.0, 1.0), close_callback : Any = ..., cursor : MouseCursor = 0, decorated : bool = True, disable_close : bool = False, font : Font = None, fullscreen : bool = False, handlers : list = ..., height : int = 800, large_icon : str = "b''", max_height : int = 10000, max_width : int = 10000, maximized : Any = ..., min_height : int = 250, min_width : int = 250, minimized : Any = ..., next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, resizable : bool = True, resize_callback : Any = ..., scale : float = 1.0, small_icon : str = "b''", tag : Viewport = ..., theme : Any = ..., title : str = "b'Dear CyGui'", user_data : Any = ..., vsync : bool = True, wait_for_input : bool = False, width : int = 1280, x_pos : int = 100, y_pos : int = 100):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        close_callback: Callback to be issued when the viewport is closed.
        cursor: Change the mouse cursor to one of MouseCursor.
            The mouse cursor is reset every frame.
        font: global font
        handlers: bound handler (or handlerList)
            for the viewport.
            Only Key and Mouse handlers are compatible.
            Handlers that check item states won't work.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resize_callback: Callback to be issued when the viewport is resized.
        scale: Multiplicative scale that, multiplied by
            the value of dpi, is used to scale
            automatically all items.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: global theme
        user_data: User data of any type.
        wait_for_input: When the app doesn't need to be
            refreshed, one can save power comsumption by not
            rendering. wait_for_input will pause rendering until
            a mouse or keyboard event is received.
            wake() can also be used to restart rendering
            for one frame.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def initialize(self, minimized=False, maximized=False, always_on_top : bool = False, children : list[Window, ViewportDrawList, MenuBar] = [], clear_color : tuple = (0.0, 0.0, 0.0, 1.0), close_callback : Any = ..., cursor : MouseCursor = 0, decorated : bool = True, disable_close : bool = False, font : Font = None, fullscreen : bool = False, handlers : list = ..., height : int = 800, large_icon : str = "b''", max_height : int = 10000, max_width : int = 10000, min_height : int = 250, min_width : int = 250, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, resizable : bool = True, resize_callback : Any = ..., scale : float = 1.0, small_icon : str = "b''", tag : Viewport = ..., theme : Any = ..., title : str = "b'Dear CyGui'", user_data : Any = ..., vsync : bool = True, wait_for_input : bool = False, width : int = 1280, x_pos : int = 100, y_pos : int = 100):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        close_callback: Callback to be issued when the viewport is closed.
        cursor: Change the mouse cursor to one of MouseCursor.
            The mouse cursor is reset every frame.
        font: global font
        handlers: bound handler (or handlerList)
            for the viewport.
            Only Key and Mouse handlers are compatible.
            Handlers that check item states won't work.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        resize_callback: Callback to be issued when the viewport is resized.
        scale: Multiplicative scale that, multiplied by
            the value of dpi, is used to scale
            automatically all items.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: global theme
        user_data: User data of any type.
        wait_for_input: When the app doesn't need to be
            refreshed, one can save power comsumption by not
            rendering. wait_for_input will pause rendering until
            a mouse or keyboard event is received.
            wake() can also be used to restart rendering
            for one frame.
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def render_frame(self, can_skip_presenting=False):
        """
        Render one frame.

        Rendering occurs in several separated steps:
        . Mouse/Keyboard events are processed. it's there
          that wait_for_input has an effect.
        . The viewport item, and then all the rendering tree are
          walked through to query their state and prepare the rendering
          commands using ImGui, ImPlot and ImNodes
        . The rendering commands are submitted to the GPU.
        . The submission is passed to the operating system to handle the
          window update. It's usually at this step that the system will
          apply vsync by making the application wait if it rendered faster
          than the screen refresh rate.

        can_skip_presenting: rendering will occur (handlers checked, etc),
            but the backend might decide, if this flag is set, to not
            submit the rendering commands to the GPU and refresh the
            window. Can be used to avoid using the GPU in response
            to a simple mouse motion.
            Fast checks are used to determine if presenting should occur
            or not. Thus set this only if you haven't updated any content
            on the screen.
            Note wake() will automatically force a redraw the next frame.

        Returns True if the frame was presented to the screen,
            False else (can_skip_presenting)
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def wake(self):
        """
        In case rendering is waiting for an input (waitForInputs),
        generate a fake input to force rendering.

        This is useful if you have updated the content asynchronously
        and want to show the update
        
        """
        ...


    def __enter__(self) -> Viewport:
        ...


    @property
    def always_on_top(self) -> bool:
        ...


    @always_on_top.setter
    def always_on_top(self, value : bool):
        ...


    @property
    def children(self) -> list[Window, ViewportDrawList, MenuBar]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[Window, ViewportDrawList, MenuBar]):
        ...


    @property
    def clear_color(self) -> tuple:
        ...


    @clear_color.setter
    def clear_color(self, value : tuple):
        ...


    @property
    def close_callback(self):
        """
        Callback to be issued when the viewport is closed.
        
        """
        ...


    @close_callback.setter
    def close_callback(self, value):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def cursor(self) -> MouseCursor:
        """
        Change the mouse cursor to one of MouseCursor.
        The mouse cursor is reset every frame.
        
        """
        ...


    @cursor.setter
    def cursor(self, value : MouseCursor):
        ...


    @property
    def decorated(self) -> bool:
        ...


    @decorated.setter
    def decorated(self, value : bool):
        ...


    @property
    def disable_close(self) -> bool:
        ...


    @disable_close.setter
    def disable_close(self, value : bool):
        ...


    @property
    def dpi(self) -> float:
        """
        Requested scaling (DPI) from the OS for
        this window. The value is valid after
        initialize() and might change over time,
        for instance if the window is moved to another
        monitor.

        The DPI is used to scale all items automatically.
        From the developper point of view, everything behaves
        as if the DPI is 1. This behaviour can be disabled
        using the related scaling settings.
        
        """
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: global font
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def fullscreen(self) -> bool:
        ...


    @fullscreen.setter
    def fullscreen(self, value : bool):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handler (or handlerList)
        for the viewport.
        Only Key and Mouse handlers are compatible.
        Handlers that check item states won't work.
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def large_icon(self) -> str:
        ...


    @large_icon.setter
    def large_icon(self, value : str):
        ...


    @property
    def max_height(self) -> int:
        ...


    @max_height.setter
    def max_height(self, value : int):
        ...


    @property
    def max_width(self) -> int:
        ...


    @max_width.setter
    def max_width(self, value : int):
        ...


    @property
    def maximized(self):
        ...


    @maximized.setter
    def maximized(self, value):
        ...


    @property
    def metrics(self) -> dict:
        ...


    @property
    def min_height(self) -> int:
        ...


    @min_height.setter
    def min_height(self, value : int):
        ...


    @property
    def min_width(self) -> int:
        ...


    @min_width.setter
    def min_width(self, value : int):
        ...


    @property
    def minimized(self):
        ...


    @minimized.setter
    def minimized(self, value):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def resizable(self) -> bool:
        ...


    @resizable.setter
    def resizable(self, value : bool):
        ...


    @property
    def resize_callback(self):
        """
        Callback to be issued when the viewport is resized.

        The data returned is a tuple containing:
        . The width in pixels
        . The height in pixels
        . The width according to the OS (OS dependent)
        . The height according to the OS (OS dependent)
        
        """
        ...


    @resize_callback.setter
    def resize_callback(self, value):
        ...


    @property
    def scale(self) -> float:
        """
        Multiplicative scale that, multiplied by
        the value of dpi, is used to scale
        automatically all items.

        Defaults to 1.
        
        """
        ...


    @scale.setter
    def scale(self, value : float):
        ...


    @property
    def shown(self) -> bool:
        """
        Whether the viewport window has been created by the
        operating system.
        
        """
        ...


    @property
    def small_icon(self) -> str:
        ...


    @small_icon.setter
    def small_icon(self, value : str):
        ...


    @property
    def tag(self) -> Viewport:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Viewport):
        ...


    @property
    def theme(self):
        """
        Writable attribute: global theme
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def title(self) -> str:
        ...


    @title.setter
    def title(self, value : str):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def vsync(self) -> bool:
        ...


    @vsync.setter
    def vsync(self, value : bool):
        ...


    @property
    def wait_for_input(self) -> bool:
        """
        Writable attribute: When the app doesn't need to be
        refreshed, one can save power comsumption by not
        rendering. wait_for_input will pause rendering until
        a mouse or keyboard event is received.
        wake() can also be used to restart rendering
        for one frame.
        
        """
        ...


    @wait_for_input.setter
    def wait_for_input(self, value : bool):
        ...


    @property
    def width(self) -> int:
        ...


    @width.setter
    def width(self, value : int):
        ...


    @property
    def x_pos(self) -> int:
        ...


    @x_pos.setter
    def x_pos(self, value : int):
        ...


    @property
    def y_pos(self) -> int:
        ...


    @y_pos.setter
    def y_pos(self, value : int):
        ...


class ViewportDrawList(baseItem):
    def __init__(self, context : Context, children : list[drawingItem] = [], front : bool = True, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ViewportDrawList = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[drawingItem] = [], front : bool = True, next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : ViewportDrawList = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> ViewportDrawList:
        ...


    @property
    def children(self) -> list[drawingItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[drawingItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def front(self) -> bool:
        ...


    @front.setter
    def front(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> ViewportDrawList:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : ViewportDrawList):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class Window(uiItem):
    def __init__(self, context : Context, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, autosize : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem, MenuBar] = [], collapsed : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], has_close_button : bool = True, height : int = 0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", max_size : tuple = (30000, 30000), menubar : bool = False, min_size : tuple = (100, 100), modal : bool = False, next_sibling : baseItem | None = None, no_background : bool = False, no_bring_to_front_on_focus : bool = False, no_collapse : bool = False, no_focus_on_appearing : bool = False, no_keyboard_inputs : bool = False, no_mouse_inputs : bool = False, no_move : bool = False, no_newline : float = 0.0, no_open_over_existing_popup : bool = True, no_resize : bool = False, no_saved_settings : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, no_title_bar : bool = False, on_close : Any = ..., parent : Viewport | None = None, popup : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, primary : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : Window = ..., theme : Any = ..., unsaved_document : bool = False, user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        autosize: Writable attribute to tell the window should
               automatically resize to fit its content
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        collapsed: Writable attribute to collapse (~minimize) or uncollapse the window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        has_close_button: Writable attribute to indicate the window has a close button.
            Has effect only for normal and modal windows.
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_size: Writable attribute to indicate the maximum window size
        menubar: Writable attribute to indicate whether the window has a menu bar.
        min_size: Writable attribute to indicate the minimum window size
        modal: Writable attribute to indicate the window is a modal window.
            Modal windows are similar to popup windows, but they have a close
            button and are not closed by clicking outside.
            Clicking has no effect of items outside the modal window until it is closed.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_background: Writable attribute to disable drawing background
            color and outside border
        no_bring_to_front_on_focus: Writable attribute to indicate when the window takes focus (click on it, etc)
            it shouldn't be shown in front of other windows
        no_collapse: Writable attribute to disable user collapsing window by double-clicking on it
        no_focus_on_appearing: Writable attribute to indicate when the windows moves from
            an un-shown to a shown item shouldn't be made automatically
            focused
        no_keyboard_inputs: Writable attribute to disable keyboard manipulation (scroll).
            The window will not take focus of the keyboard.
            Does not affect items inside the window.
        no_mouse_inputs: Writable attribute to disable mouse input event catching of the window.
            Events such as clicked, hovering, etc will be passed to items behind the
            window.
        no_move: Writable attribute the window to be move with interactions
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_open_over_existing_popup: Writable attribute for modal and popup windows to prevent them from
            showing if there is already an existing popup/modal window
        no_resize: Writable attribute to block resizing
        no_saved_settings: Writable attribute to never load/save settings in .ini file
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: Writable attribute to indicate the mouse wheel
               should have no effect on scrolling of this window
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        no_title_bar: Writable attribute to disable the title-bar
        on_close: Callback to call when the window is closed.
            Note closing the window does not destroy or unattach the item.
            Instead it is switched to a show=False state.
        parent: parent of the item in the rendering tree.
        popup: Writable attribute to indicate the window is a popup window.
            Popup windows are centered (unless a pos is set), do not have a
            close button, and are closed when they lose focus (clicking outside the
            window).
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        primary: Indicate if the window is the primary window.
            There is maximum one primary window. The primary window covers the whole
            viewport and can be used to draw on the background.
            It is equivalent to setting:
            no_bring_to_front_on_focus
            no_saved_settings
            no_resize
            no_collapse
            no_title_bar
            and running item.focused = True on all the other windows
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        unsaved_document: Writable attribute to display a dot next to the title, as if the window
            contains unsaved changes.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, always_show_horizontal_scrollvar : bool = False, always_show_vertical_scrollvar : bool = False, autosize : bool = False, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : list[uiItem, MenuBar] = [], collapsed : bool = False, enabled : bool = True, focused : bool = False, font : Font = None, handlers : list = [], has_close_button : bool = True, height : int = 0, horizontal_scrollbar : bool = False, indent : float = 0.0, label : str = "", max_size : tuple = (30000, 30000), menubar : bool = False, min_size : tuple = (100, 100), modal : bool = False, next_sibling : baseItem | None = None, no_background : bool = False, no_bring_to_front_on_focus : bool = False, no_collapse : bool = False, no_focus_on_appearing : bool = False, no_keyboard_inputs : bool = False, no_mouse_inputs : bool = False, no_move : bool = False, no_newline : float = 0.0, no_open_over_existing_popup : bool = True, no_resize : bool = False, no_saved_settings : bool = False, no_scaling : bool = False, no_scroll_with_mouse : bool = False, no_scrollbar : bool = False, no_title_bar : bool = False, on_close : Any = ..., parent : Viewport | None = None, popup : bool = False, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, primary : bool = False, shareable_value : SharedValue = ..., show : bool = True, tag : Window = ..., theme : Any = ..., unsaved_document : bool = False, user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        always_show_horizontal_scrollvar: Writable attribute to tell to always show a horizontal scrollbar
            even when the size does not require it (only if horizontal scrollbar
            are enabled)
        always_show_vertical_scrollvar: Writable attribute to tell to always show a vertical scrollbar
            even when the size does not require it
        autosize: Writable attribute to tell the window should
               automatically resize to fit its content
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        collapsed: Writable attribute to collapse (~minimize) or uncollapse the window
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        focused: Is the item focused ?
            For windows it means the window is at the top,
            while for items it could mean the keyboard inputs are redirected to it.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        has_close_button: Writable attribute to indicate the window has a close button.
            Has effect only for normal and modal windows.
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        horizontal_scrollbar: Writable attribute to enable having an horizontal scrollbar
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        max_size: Writable attribute to indicate the maximum window size
        menubar: Writable attribute to indicate whether the window has a menu bar.
        min_size: Writable attribute to indicate the minimum window size
        modal: Writable attribute to indicate the window is a modal window.
            Modal windows are similar to popup windows, but they have a close
            button and are not closed by clicking outside.
            Clicking has no effect of items outside the modal window until it is closed.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_background: Writable attribute to disable drawing background
            color and outside border
        no_bring_to_front_on_focus: Writable attribute to indicate when the window takes focus (click on it, etc)
            it shouldn't be shown in front of other windows
        no_collapse: Writable attribute to disable user collapsing window by double-clicking on it
        no_focus_on_appearing: Writable attribute to indicate when the windows moves from
            an un-shown to a shown item shouldn't be made automatically
            focused
        no_keyboard_inputs: Writable attribute to disable keyboard manipulation (scroll).
            The window will not take focus of the keyboard.
            Does not affect items inside the window.
        no_mouse_inputs: Writable attribute to disable mouse input event catching of the window.
            Events such as clicked, hovering, etc will be passed to items behind the
            window.
        no_move: Writable attribute the window to be move with interactions
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_open_over_existing_popup: Writable attribute for modal and popup windows to prevent them from
            showing if there is already an existing popup/modal window
        no_resize: Writable attribute to block resizing
        no_saved_settings: Writable attribute to never load/save settings in .ini file
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        no_scroll_with_mouse: Writable attribute to indicate the mouse wheel
               should have no effect on scrolling of this window
        no_scrollbar: Writable attribute to indicate the window should have no scrollbar
               Does not disable scrolling via mouse or keyboard
        no_title_bar: Writable attribute to disable the title-bar
        on_close: Callback to call when the window is closed.
            Note closing the window does not destroy or unattach the item.
            Instead it is switched to a show=False state.
        parent: parent of the item in the rendering tree.
        popup: Writable attribute to indicate the window is a popup window.
            Popup windows are centered (unless a pos is set), do not have a
            close button, and are closed when they lose focus (clicking outside the
            window).
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        primary: Indicate if the window is the primary window.
            There is maximum one primary window. The primary window covers the whole
            viewport and can be used to draw on the background.
            It is equivalent to setting:
            no_bring_to_front_on_focus
            no_saved_settings
            no_resize
            no_collapse
            no_title_bar
            and running item.focused = True on all the other windows
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        unsaved_document: Writable attribute to display a dot next to the title, as if the window
            contains unsaved changes.
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> Window:
        ...


    @property
    def always_show_horizontal_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a horizontal scrollbar
        even when the size does not require it (only if horizontal scrollbar
        are enabled)
        
        """
        ...


    @always_show_horizontal_scrollvar.setter
    def always_show_horizontal_scrollvar(self, value : bool):
        ...


    @property
    def always_show_vertical_scrollvar(self) -> bool:
        """
        Writable attribute to tell to always show a vertical scrollbar
        even when the size does not require it
        
        """
        ...


    @always_show_vertical_scrollvar.setter
    def always_show_vertical_scrollvar(self, value : bool):
        ...


    @property
    def autosize(self) -> bool:
        """Writable attribute to tell the window should
           automatically resize to fit its content
        
        """
        ...


    @autosize.setter
    def autosize(self, value : bool):
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> list[uiItem, MenuBar]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem, MenuBar]):
        ...


    @property
    def collapsed(self) -> bool:
        """
        Writable attribute to collapse (~minimize) or uncollapse the window
        
        """
        ...


    @collapsed.setter
    def collapsed(self, value : bool):
        ...


    @property
    def content_region_avail(self) -> tuple:
        """
        Readonly attribute: For windows, child windows,
        table cells, etc: Available region.

        Only defined for elements that contain other items.
        Corresponds to the size inside the item to display
        other items (regions not shown which can
        be scrolled are not accounted). Basically the item size
        minus the margins and borders.
        
        """
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def focused(self) -> bool:
        """
        Writable attribute: Is the item focused ?
        For windows it means the window is at the top,
        while for items it could mean the keyboard inputs are redirected to it.
        
        """
        ...


    @focused.setter
    def focused(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def has_close_button(self) -> bool:
        """
        Writable attribute to indicate the window has a close button.
        Has effect only for normal and modal windows.
        
        """
        ...


    @has_close_button.setter
    def has_close_button(self, value : bool):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def horizontal_scrollbar(self) -> bool:
        """
        Writable attribute to enable having an horizontal scrollbar
        
        """
        ...


    @horizontal_scrollbar.setter
    def horizontal_scrollbar(self, value : bool):
        ...


    @property
    def hovered(self) -> bool:
        """
        Readonly attribute: Is the mouse inside the region of the item.
        Only one element is hovered at a time, thus
        subitems/subwindows take priority over their parent.
        
        """
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def max_size(self) -> tuple:
        """
        Writable attribute to indicate the maximum window size
        
        """
        ...


    @max_size.setter
    def max_size(self, value : tuple):
        ...


    @property
    def menubar(self) -> bool:
        """
        Writable attribute to indicate whether the window has a menu bar.

        There will be menubar if either the user has asked for it,
        or there is a menubar child.
        
        """
        ...


    @menubar.setter
    def menubar(self, value : bool):
        ...


    @property
    def min_size(self) -> tuple:
        """
        Writable attribute to indicate the minimum window size
        
        """
        ...


    @min_size.setter
    def min_size(self, value : tuple):
        ...


    @property
    def modal(self) -> bool:
        """
        Writable attribute to indicate the window is a modal window.
        Modal windows are similar to popup windows, but they have a close
        button and are not closed by clicking outside.
        Clicking has no effect of items outside the modal window until it is closed.
        
        """
        ...


    @modal.setter
    def modal(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_background(self) -> bool:
        """
        Writable attribute to disable drawing background
        color and outside border
        
        """
        ...


    @no_background.setter
    def no_background(self, value : bool):
        ...


    @property
    def no_bring_to_front_on_focus(self) -> bool:
        """
        Writable attribute to indicate when the window takes focus (click on it, etc)
        it shouldn't be shown in front of other windows
        
        """
        ...


    @no_bring_to_front_on_focus.setter
    def no_bring_to_front_on_focus(self, value : bool):
        ...


    @property
    def no_collapse(self) -> bool:
        """Writable attribute to disable user collapsing window by double-clicking on it
        
        """
        ...


    @no_collapse.setter
    def no_collapse(self, value : bool):
        ...


    @property
    def no_focus_on_appearing(self) -> bool:
        """
        Writable attribute to indicate when the windows moves from
        an un-shown to a shown item shouldn't be made automatically
        focused
        
        """
        ...


    @no_focus_on_appearing.setter
    def no_focus_on_appearing(self, value : bool):
        ...


    @property
    def no_keyboard_inputs(self) -> bool:
        """
        Writable attribute to disable keyboard manipulation (scroll).
        The window will not take focus of the keyboard.
        Does not affect items inside the window.
        
        """
        ...


    @no_keyboard_inputs.setter
    def no_keyboard_inputs(self, value : bool):
        ...


    @property
    def no_mouse_inputs(self) -> bool:
        """
        Writable attribute to disable mouse input event catching of the window.
        Events such as clicked, hovering, etc will be passed to items behind the
        window.
        
        """
        ...


    @no_mouse_inputs.setter
    def no_mouse_inputs(self, value : bool):
        ...


    @property
    def no_move(self) -> bool:
        """Writable attribute the window to be move with interactions
        """
        ...


    @no_move.setter
    def no_move(self, value : bool):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_open_over_existing_popup(self) -> bool:
        """
        Writable attribute for modal and popup windows to prevent them from
        showing if there is already an existing popup/modal window
        
        """
        ...


    @no_open_over_existing_popup.setter
    def no_open_over_existing_popup(self, value : bool):
        ...


    @property
    def no_resize(self) -> bool:
        """Writable attribute to block resizing
        """
        ...


    @no_resize.setter
    def no_resize(self, value : bool):
        ...


    @property
    def no_saved_settings(self) -> bool:
        """
        Writable attribute to never load/save settings in .ini file
        
        """
        ...


    @no_saved_settings.setter
    def no_saved_settings(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def no_scroll_with_mouse(self) -> bool:
        """Writable attribute to indicate the mouse wheel
           should have no effect on scrolling of this window
        
        """
        ...


    @no_scroll_with_mouse.setter
    def no_scroll_with_mouse(self, value : bool):
        ...


    @property
    def no_scrollbar(self) -> bool:
        """Writable attribute to indicate the window should have no scrollbar
           Does not disable scrolling via mouse or keyboard
        
        """
        ...


    @no_scrollbar.setter
    def no_scrollbar(self, value : bool):
        ...


    @property
    def no_title_bar(self) -> bool:
        """Writable attribute to disable the title-bar
        """
        ...


    @no_title_bar.setter
    def no_title_bar(self, value : bool):
        ...


    @property
    def on_close(self):
        """
        Callback to call when the window is closed.
        Note closing the window does not destroy or unattach the item.
        Instead it is switched to a show=False state.
        
        """
        ...


    @on_close.setter
    def on_close(self, value):
        ...


    @property
    def parent(self) -> Viewport | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Viewport | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def popup(self) -> bool:
        """
        Writable attribute to indicate the window is a popup window.
        Popup windows are centered (unless a pos is set), do not have a
        close button, and are closed when they lose focus (clicking outside the
        window).
        
        """
        ...


    @popup.setter
    def popup(self, value : bool):
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def primary(self) -> bool:
        """
        Writable attribute: Indicate if the window is the primary window.
        There is maximum one primary window. The primary window covers the whole
        viewport and can be used to draw on the background.
        It is equivalent to setting:
        no_bring_to_front_on_focus
        no_saved_settings
        no_resize
        no_collapse
        no_title_bar
        and running item.focused = True on all the other windows
        
        """
        ...


    @primary.setter
    def primary(self, value : bool):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> Window:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : Window):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def unsaved_document(self) -> bool:
        """
        Writable attribute to display a dot next to the title, as if the window
        contains unsaved changes.
        
        """
        ...


    @unsaved_document.setter
    def unsaved_document(self, value : bool):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...


class baseHandler(baseItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : baseHandler = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseTheme | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : baseHandler = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseHandler:
        ...


    @property
    def callback(self) -> DCGCallable | None:
        ...


    @callback.setter
    def callback(self, value : DCGCallable | None):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseTheme | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseTheme | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> baseHandler:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : baseHandler):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class baseItem(object):
    """
    Base class for all items (except shared values)

    To be rendered, an item must be in the child tree
    of the viewport (context.viewport).

    The parent of an item can be set with various ways:
    1) Using the parent attribute. item.parent = target_item
    2) Passing (parent=target_item) during item creation
    3) If the context manager is not empty ('with' on an item),
       and no parent is set (parent = None passed or nothing),
       the last item in 'with' is taken as parent. The context
       manager can be managed directly with context.push_next_parent()
       and context.pop_next_parent()
    4) if you set the previous_sibling or next_sibling attribute,
       the item will be inserted respectively after and before the
       respective items in the parent item children list. For legacy
       support, the 'before=target_item' attribute can be used during item creation,
       and is equivalent to item.next_sibling = target_item

    parent, previous_sibling and next_sibling are baseItem attributes
    and can be read at any time.
    It is possible to get the list of children of an item as well
    with the 'children' attribute: item.children.

    For ease of use, the items can be named for easy retrieval.
    The tag attribute is a user string that can be set at any
    moment and can be passed for parent/previous_sibling/next_sibling.
    The item associated with a tag can be retrieved with context[tag].
    Note that having a tag doesn't mean the item is referenced by the context.
    If an item is not in the subtree of the viewport, and is not referenced,
    it might get deleted.

    During rendering the children of each item are rendered in
    order from the first one to the last one.
    When an item is attached to a parent, it is by default inserted
    last, unless previous_sibling or next_sibling is used.

    previous_sibling and next_sibling enable to insert an item
    between elements.

    When parent, previous_sibling or next_sibling are set, the item
    is detached from any parent or sibling it had previously.

    An item can be manually detached from a parent
    by setting parent = None.

    Most items have restrictions for the parents and children it can
    have. In addition some items can have several children lists
    of incompatible types. These children list will be concatenated
    when reading item.children. In a given list are items of a similar
    type.

    Finally some items cannot be children of any item in the rendering
    tree. One such item is PlaceHolderParent, which can be parent
    of any item which can have a parent. PlaceHolderParent cannot
    be inserted in the rendering tree, but can be used to store items
    before their insertion in the rendering tree.
    Other such items are textures, themes, colormaps and fonts. Those
    items cannot be made children of items of the rendering tree, but
    can be bound to them. For example item.theme = theme_item will
    bind theme_item to item. It is possible to bind such an item to
    several items, and as long as one item reference them, they will
    not be deleted by the garbage collector.
    
    """
    def __init__(self, context : Context, children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, tag : baseItem = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : list[baseItem] = [], next_sibling : baseItem | None = None, parent : baseItem | None = None, previous_sibling : baseItem | None = None, tag : baseItem = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseItem:
        ...


    @property
    def children(self) -> list[baseItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[baseItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> baseItem:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : baseItem):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class baseTheme(baseItem):
    """
    Base theme element. Contains a set of theme elements
    to apply for a given category (color, style)/(imgui/implot/imnode)
    
    """
    def __init__(self, context : Context, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : baseTheme = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : baseTheme = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseTheme:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> baseTheme:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : baseTheme):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class baseThemeStyle(baseTheme):
    def __init__(self, context : Context, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : baseThemeStyle = ..., user_data : tuple[float, float] | None = None):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], enabled : bool = True, next_sibling : baseItem | None = None, no_rounding : bool = True, no_scaling : bool = False, parent : baseHandler | None = None, previous_sibling : baseItem | None = None, tag : baseThemeStyle = ..., user_data : tuple[float, float] | None = None):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_rounding: boolean. Defaults to False.
            If set, disables rounding (after scaling) to the
            closest integer the parameters. The rounding is only
            applied to parameters which impact item positioning
            in a way that would prevent a pixel perfect result.
        no_scaling: boolean. Defaults to False.
            If set, disables the automated scaling to the dpi
            scale value for this theme
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> baseThemeStyle:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_rounding(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables rounding (after scaling) to the
        closest integer the parameters. The rounding is only
        applied to parameters which impact item positioning
        in a way that would prevent a pixel perfect result.
        
        """
        ...


    @no_rounding.setter
    def no_rounding(self, value : bool):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        If set, disables the automated scaling to the dpi
        scale value for this theme
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> baseHandler | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : baseHandler | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def tag(self) -> baseThemeStyle:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : baseThemeStyle):
        ...


    @property
    def user_data(self) -> tuple[float, float] | None:
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value : tuple[float, float] | None):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class drawingItem(baseItem):
    """
    A simple item with no UI state,
    that inherit from the drawing area of its
    parent
    
    """
    def __init__(self, context : Context, children : None  = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : drawingItem = ..., user_data : Any = ...):
        """

        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, children : None  = [], next_sibling : baseItem | None = None, parent : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : drawingItem = ..., user_data : Any = ...):
        """
        children: List of all the children of the item,
            from first rendered, to last rendered.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> drawingItem:
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : DrawInWindow | DrawInPlot | ViewportDrawList | drawingItem | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> drawingItem:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : drawingItem):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElement(baseItem):
    """
    Base class for plot children.
    
    """
    def __init__(self, context : Context, axes : tuple = (0, 3), children : None  = [], label : str = "", next_sibling : baseItem | None = None, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElement = ..., theme : Any = ..., user_data : Any = ...):
        """

        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        label: label assigned to the element
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, axes : tuple = (0, 3), children : None  = [], label : str = "", next_sibling : baseItem | None = None, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElement = ..., theme : Any = ..., user_data : Any = ...):
        """
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        label: label assigned to the element
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElement:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> plotElement:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : plotElement):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElementWithLegend(plotElement):
    """
    Base class for plot children with a legend.

    Children of plot elements are rendered on a legend
    popup entry that gets shown on a right click (by default).
    
    """
    def __init__(self, context : Context, axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElementWithLegend = ..., theme : Any = ..., user_data : Any = ...):
        """

        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElementWithLegend = ..., theme : Any = ..., user_data : Any = ...):
        """
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElementWithLegend:
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> plotElementWithLegend:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : plotElementWithLegend):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElementX(plotElementWithLegend):
    def __init__(self, context : Context, X : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElementX = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElementX = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElementX:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> plotElementX:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : plotElementX):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElementXY(plotElementWithLegend):
    def __init__(self, context : Context, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElementXY = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElementXY = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElementXY:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y(self) -> ndarray:
        ...


    @Y.setter
    def Y(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> plotElementXY:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : plotElementXY):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class plotElementXYY(plotElementWithLegend):
    def __init__(self, context : Context, X : ndarray = [0.], Y1 : ndarray = [0.], Y2 : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElementXYY = ..., theme : Any = ..., user_data : Any = ...):
        """

        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, X : ndarray = [0.], Y1 : ndarray = [0.], Y2 : ndarray = [0.], axes : tuple = (0, 3), children : list[uiItem] = [], enabled : bool = True, font : Font = None, ignore_fit : bool = False, label : str = "", legend_button : MouseButton = 1, legend_handlers : list = [], next_sibling : baseItem | None = None, no_legend : bool = False, parent : Plot | None = None, previous_sibling : baseItem | None = None, show : bool = True, tag : plotElementXYY = ..., theme : Any = ..., user_data : Any = ...):
        """
        X: Values on the X axis.
        axes: (X axis, Y axis)
            used for this plot element.
            Default is (X1, Y1)
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: show/hide
            the item while still having a toggable
            entry in the menu.
        font: font used for the text rendered
            of this item and its subitems
        ignore_fit: Writable attribute to make this element
            be ignored during plot fits
        label: label assigned to the element
        legend_button: Button that opens the legend entry for
            this element.
            Default is the right mouse button.
        legend_handlers: bound handlers for the legend.
            Only visible (set for the plot) and hovered (set 
            for the legend) handlers are compatible.
            To detect if the plot element is hovered, check
            the hovered state of the plot.
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_legend: Writable attribute to disable the legend for this plot
            element
        parent: parent of the item in the rendering tree.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: theme for the legend and plot
        user_data: User data of any type.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> plotElementXYY:
        ...


    @property
    def X(self) -> ndarray:
        """Values on the X axis.

        By default, will try to use the passed array
        directly for its internal backing (no copy).
        Supported types for no copy are np.int32,
        np.float32, np.float64.
        
        """
        ...


    @X.setter
    def X(self, value : ndarray):
        ...


    @property
    def Y1(self) -> ndarray:
        ...


    @Y1.setter
    def Y1(self, value : ndarray):
        ...


    @property
    def Y2(self) -> ndarray:
        ...


    @Y2.setter
    def Y2(self, value : ndarray):
        ...


    @property
    def axes(self) -> tuple:
        """
        Writable attribute: (X axis, Y axis)
        used for this plot element.
        Default is (X1, Y1)
        
        """
        ...


    @axes.setter
    def axes(self, value : tuple):
        ...


    @property
    def children(self) -> list[uiItem]:
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : list[uiItem]):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: show/hide
        the item while still having a toggable
        entry in the menu.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def ignore_fit(self) -> bool:
        """
        Writable attribute to make this element
        be ignored during plot fits
        
        """
        ...


    @ignore_fit.setter
    def ignore_fit(self, value : bool):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the element
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def legend_button(self) -> MouseButton:
        """
        Button that opens the legend entry for
        this element.
        Default is the right mouse button.
        
        """
        ...


    @legend_button.setter
    def legend_button(self, value : MouseButton):
        ...


    @property
    def legend_handlers(self) -> list:
        """
        Writable attribute: bound handlers for the legend.
        Only visible (set for the plot) and hovered (set 
        for the legend) handlers are compatible.
        To detect if the plot element is hovered, check
        the hovered state of the plot.
        
        """
        ...


    @legend_handlers.setter
    def legend_handlers(self, value : list):
        ...


    @property
    def legend_hovered(self) -> bool:
        """
        Readonly attribute: Is the legend of this
        item hovered.
        
        """
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_legend(self) -> bool:
        """
        Writable attribute to disable the legend for this plot
        element
        
        """
        ...


    @no_legend.setter
    def no_legend(self, value : bool):
        ...


    @property
    def parent(self) -> Plot | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : Plot | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> plotElementXYY:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : plotElementXYY):
        ...


    @property
    def theme(self):
        """
        Writable attribute: theme for the legend and plot
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


class uiItem(baseItem):
    def __init__(self, context : Context, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : uiItem = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """

        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def attach_before(self, target):
        """
        Same as item.next_sibling = target,
        but target must not be None
        
        """
        ...


    def attach_to_parent(self, target):
        """
        Same as item.parent = target, but
        target must not be None
        
        """
        ...


    def configure(self, callback : DCGCallable | None = None, callbacks : list[DCGCallable] = [], children : None  = [], enabled : bool = True, font : Font = None, handlers : list = [], height : int = 0, indent : float = 0.0, label : str = "", next_sibling : baseItem | None = None, no_newline : float = 0.0, no_scaling : bool = False, parent : uiItem | plotElement | None = None, pos_policy : list = ..., pos_to_default : tuple = (0, 0), pos_to_parent : tuple = (0, 0), pos_to_viewport : tuple = (0, 0), pos_to_window : tuple = (0, 0), previous_sibling : baseItem | None = None, shareable_value : SharedValue = ..., show : bool = True, tag : uiItem = ..., theme : Any = ..., user_data : Any = ..., value : Any = ..., width : int = 0):
        """
        callback: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        callbacks: callback object or list of callback objects
            which is called when the value of the item is changed.
            If read, always returns a list of callbacks. This enables
            to do item.callbacks += [new_callback]
        children: List of all the children of the item,
            from first rendered, to last rendered.
        enabled: Should the object be displayed as enabled ?
            the enabled state can be used to prevent edition of editable fields,
            or to use a specific disabled element theme.
            Note a disabled item is still rendered. Use show=False to hide
            an object.
            A disabled item does not react to hovering or clicking.
        font: font used for the text rendered
            of this item and its subitems
        handlers: bound handlers for the item.
            If read returns a list of handlers. Accept
            a handler or a list of handlers as input.
            This enables to do item.handlers += [new_handler].
        height: Requested height of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        indent: Shifts horizontally the DEFAULT
            position of the item by the requested amount of pixels.
        label: label assigned to the item.
            Used for text fields, window titles, etc
        next_sibling: child of the parent of the item that
            is rendered just after this item.
        no_newline: Disables moving the
            cursor (DEFAULT position) by one line
            after this item.
        no_scaling: boolean. Defaults to False.
            By default, the requested width and
            height are multiplied internally by the global
            scale which is defined by the dpi and the
            viewport/window scale.
            If set, disables this automated scaling.
        parent: parent of the item in the rendering tree.
        pos_policy: Positioning policy
        pos_to_default: Relative position to the item's default position.
        pos_to_parent: Relative position to the parent's position, or to
            its starting inner content area if any.
        pos_to_viewport: Current screen-space position of the top left
            of the item's rectangle. Basically the coordinate relative
            to the top left of the viewport.
        pos_to_window: Relative position to the window's starting inner
            content area.
        previous_sibling: child of the parent of the item that
            is rendered just before this item.
        shareable_value: Same as the value field, but rather than a copy of the internal value
            of the object, return a python object that holds a value field that
            is in sync with the internal value of the object. This python object
            can be passed to other items using an internal value of the same
            type to share it.
        show: Should the object be drawn/shown ?
            In case show is set to False, this disables any
            callback (for example the close callback won't be called
            if a window is hidden with show = False).
            In the case of items that can be closed,
            show is set to False automatically on close.
        tag: tag is an optional string that uniquely
            defines the object.
        theme: bound theme for the item
        user_data: User data of any type.
        value: main internal value for the object.
            For buttons, it is set when pressed; For text it is the
            text itself; For selectable whether it is selected, etc.
            Reading the value attribute returns a copy, while writing
            to the value attribute will edit the field of the value.
            In case the value is shared among items, setting the value
            attribute will change it for all the sharing items.
            To share a value attribute among objects, one should use
            the shareable_value attribute
        width: Requested width of the item.
            When it is written, it is set to a 'requested value' that is not
            entirely guaranteed to be enforced.
            Specific values:
                . 0 is meant to define the default size. For some items,
                  such as windows, it triggers a fit to the content size.
                  For other items, there is a default size deduced from the
                  style policy. And for some items (such as child windows),
                  it triggers a fit to the full size available within the
                  parent window.
                . > 0 values is meant as a hint for rect_size.
                . < 0 values to be interpreted as 'take remaining space
                  of the parent's content region from the current position,
                  and subtract this value'. For example -1 will stretch to the
                  remaining area minus one pixel.
        """
        ...


    def delete_item(self):
        """
        When an item is not referenced anywhere, it might
        not get deleted immediately, due to circular references.
        The Python garbage collector will eventually catch
        the circular references, but to speedup the process,
        delete_item will recursively detach the item
        and all elements in its subtree, as well as bound
        items. As a result, items with no more references
        will be freed immediately.
        
        """
        ...


    def detach_item(self):
        """
        Same as item.parent = None

        The item states (if any) are updated
        to indicate it is not rendered anymore,
        and the information propagated to the
        children.
        
        """
        ...


    def lock_mutex(self, wait=False):
        """
        Lock the internal item mutex.
        **Know what you are doing**
        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)
        This is useful if you want to edit several attributes
        in several commands of an item or its subtree,
        and prevent rendering or other threads from accessing
        the item until you have finished.
        If you plan on moving the item position in the rendering
        tree, to avoid deadlock you must hold the mutex of a
        parent of all the items involved in the motion (a common
        parent of the source and target parent). This mutex has to
        be locked before you lock any mutex of your child item
        if this item is already in the rendering tree (to avoid
        deadlock with the rendering thread).
        If you are unsure and plans to move an item already
        in the rendering tree, it is thus best to lock the viewport
        mutex first.

        Input argument:
        . wait (default = False): if locking the mutex fails (mutex
          held by another thread), wait it is released

        Returns: True if the mutex is held, False else.

        The mutex is a recursive mutex, thus you can lock it several
        times in the same thread. Each lock has to be matched to an unlock.
        
        """
        ...


    def unlock_mutex(self):
        """
        Unlock a previously held mutex on this object by this thread.
        Returns True on success, False if no lock was held by this thread.
        
        """
        ...


    def __enter__(self) -> uiItem:
        ...


    @property
    def callbacks(self) -> list[DCGCallable]:
        """
        Writable attribute: callback object or list of callback objects
        which is called when the value of the item is changed.
        If read, always returns a list of callbacks. This enables
        to do item.callbacks += [new_callback]
        
        """
        ...


    @callbacks.setter
    def callbacks(self, value : list[DCGCallable]):
        ...


    @property
    def children(self) -> None :
        """
        Writable attribute: List of all the children of the item,
        from first rendered, to last rendered.

        When written to, an error is raised if the children already
        have other parents. This error is meant to prevent programming
        mistakes, as users might not realize the children were
        unattached from their former parents.
        
        """
        ...


    @children.setter
    def children(self, value : None ):
        ...


    @property
    def context(self) -> Context:
        """
        Read-only attribute: Context in which the item resides
        
        """
        ...


    @property
    def enabled(self) -> bool:
        """
        Writable attribute: Should the object be displayed as enabled ?
        the enabled state can be used to prevent edition of editable fields,
        or to use a specific disabled element theme.
        Note a disabled item is still rendered. Use show=False to hide
        an object.
        A disabled item does not react to hovering or clicking.
        
        """
        ...


    @enabled.setter
    def enabled(self, value : bool):
        ...


    @property
    def font(self) -> Font:
        """
        Writable attribute: font used for the text rendered
        of this item and its subitems
        
        """
        ...


    @font.setter
    def font(self, value : Font):
        ...


    @property
    def handlers(self) -> list:
        """
        Writable attribute: bound handlers for the item.
        If read returns a list of handlers. Accept
        a handler or a list of handlers as input.
        This enables to do item.handlers += [new_handler].
        
        """
        ...


    @handlers.setter
    def handlers(self, value : list):
        ...


    @property
    def height(self) -> int:
        """
        Writable attribute: Requested height of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real height may change if the object is resizable.
        In this case, the height may be changed back by setting again the value
        of this field.
        
        """
        ...


    @height.setter
    def height(self, value : int):
        ...


    @property
    def indent(self) -> float:
        """
        Writable attribute: Shifts horizontally the DEFAULT
        position of the item by the requested amount of pixels.

        A value < 0 indicates an indentation of the default size
        according to the style policy.
        
        """
        ...


    @indent.setter
    def indent(self, value : float):
        ...


    @property
    def label(self) -> str:
        """
        Writable attribute: label assigned to the item.
        Used for text fields, window titles, etc
        
        """
        ...


    @label.setter
    def label(self, value : str):
        ...


    @property
    def mutex(self) -> wrap_mutex:
        """
        Context manager instance for the item mutex

        Locking the mutex will prevent:
        . Other threads from reading/writing
          attributes or calling methods with this item,
          editing the children/parent of the item
        . Any rendering of this item and its children.
          If the viewport attemps to render this item,
          it will be blocked until the mutex is released.
          (if the rendering thread is holding the mutex,
           no blocking occurs)

        In general, you don't need to use any mutex in your code,
        unless you are writing a library and cannot make assumptions
        on what the users will do, or if you know your code manipulates
        the same objects with multiple threads.

        All attribute accesses are mutex protected.

        If you want to subclass and add attributes, you
        can use this mutex to protect your new attributes.
        Be careful not to hold the mutex if your thread
        intends to access the attributes of a parent item.
        In case of doubt use parents_mutex instead.
        
        """
        ...


    @property
    def next_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just after this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just before the target item.
        In case of failure, the item remains in a detached state.
        
        """
        ...


    @next_sibling.setter
    def next_sibling(self, value : baseItem | None):
        ...


    @property
    def no_newline(self) -> float:
        """
        Writable attribute: Disables moving the
        cursor (DEFAULT position) by one line
        after this item.

        Might be modified by the layout
        
        """
        ...


    @no_newline.setter
    def no_newline(self, value : float):
        ...


    @property
    def no_scaling(self) -> bool:
        """
        boolean. Defaults to False.
        By default, the requested width and
        height are multiplied internally by the global
        scale which is defined by the dpi and the
        viewport/window scale.
        If set, disables this automated scaling.
        
        """
        ...


    @no_scaling.setter
    def no_scaling(self, value : bool):
        ...


    @property
    def parent(self) -> uiItem | plotElement | None:
        """
        Writable attribute: parent of the item in the rendering tree.

        Rendering starts from the viewport. Then recursively each child
        is rendered from the first to the last, and each child renders
        their subtree.

        Only an item inserted in the rendering tree is rendered.
        An item that is not in the rendering tree can have children.
        Thus it is possible to build and configure various items, and
        attach them to the tree in a second phase.

        The children hold a reference to their parent, and the parent
        holds a reference to its children. Thus to be release memory
        held by an item, two options are possible:
        . Remove the item from the tree, remove all your references.
          If the item has children or siblings, the item will not be
          released until Python's garbage collection detects a
          circular reference.
        . Use delete_item to remove the item from the tree, and remove
          all the internal references inside the item structure and
          the item's children, thus allowing them to be removed from
          memory as soon as the user doesn't hold a reference on them.

        Note the viewport is referenced by the context.

        If you set this attribute, the item will be inserted at the last
        position of the children of the parent (regardless whether this
        item is already a child of the parent).
        If you set None, the item will be removed from its parent's children
        list.
        
        """
        ...


    @parent.setter
    def parent(self, value : uiItem | plotElement | None):
        ...


    @property
    def parents_mutex(self) -> wrap_this_and_parents_mutex:
        """Context manager instance for the item mutex and all its parents
        
        Similar to mutex but locks not only this item, but also all
        its current parents.
        If you want to access parent fields, or if you are unsure,
        lock this mutex rather than self.mutex.
        This mutex will lock the item and all its parent in a safe
        way that does not deadlock.
        
        """
        ...


    @property
    def pos_policy(self) -> list:
        """
        Writable attribute: Positioning policy

        Changing the policy enables the user to
        change the position of the item relative to
        its default position.

        - DEFAULT: The item is drawn at the position
          given by ImGUI's cursor position, which by
          default is incremented vertically after each item is
          rendered.
        - REL_DEFAULT: The item is drawn at the same position
          as default, but after adding as offset the value
          contained in the pos_to_default field.
        - REL_PARENT: The item is rendered at the position
          contained in the pos_to_parent's field,
          which is respective to the top left of the content
          area of the parent.
        - REL_WINDOW: The item is rendered at the position
          contained in the pos_to_window's field,
          which is respective to the top left of the containing
          window or child window content area.
        - REL_VIEWPORT: The item is rendered in viewport
          coordinates, at the position pos_to_viewport.

        Items rendered with the DEFAULT or REL_DEFAULT policy do
        increment the cursor position, while REL_PARENT, REL_WINDOW
        and REL_VIEWPORT do not.

        Each axis has it's own positioning policy.
        pos_policy = DEFAULT will update both policies, why
        pos_policy = (None, DEFAULT) will only update the vertical
        axis policy.

        Regardless of the policy, all position fields are updated
        when the item is rendered. Only the position corresponding to
        the positioning policy can be expected to remain fixed, with no
        strong guarantees.

        Since some items react dynamically to the size of their contents,
        while items react dynamically to the size of their parent, a few
        frames may be needed for positions to stabilize.
        
        """
        ...


    @pos_policy.setter
    def pos_policy(self, value : list):
        ...


    @property
    def pos_to_default(self) -> tuple:
        """
        Writable attribute:
        Relative position to the item's default position.

        User set attribute to offset the object relative to
        the position it would be drawn by default given the other
        items drawn. The position corresponds to the top left of
        the item's rectangle.

        User writing this attribute automatically switches the 
        positioning policy to relative to the default position.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_default.setter
    def pos_to_default(self, value : tuple):
        ...


    @property
    def pos_to_parent(self) -> tuple:
        """
        Writable attribute:
        Relative position to the parent's position, or to
        its starting inner content area if any.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        parent.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_parent.setter
    def pos_to_parent(self, value : tuple):
        ...


    @property
    def pos_to_viewport(self) -> tuple:
        """
        Writable attribute:
        Current screen-space position of the top left
        of the item's rectangle. Basically the coordinate relative
        to the top left of the viewport.

        User writing this attribute automatically switches
        the positioning mode to REL_VIEWPORT position.

        Note that item is still clipped from the parent's clipping
        region, and thus the item will not be visible if placed
        outside.

        Setting None to one of component will ignore the update
        of this component.
        For example item.pos_to_viewport = (x, None) will only
        set the horizontal component of the pos_to_viewport position,
        and update the positioning policy for this component
        only.
        
        """
        ...


    @pos_to_viewport.setter
    def pos_to_viewport(self, value : tuple):
        ...


    @property
    def pos_to_window(self) -> tuple:
        """
        Writable attribute:
        Relative position to the window's starting inner
        content area.

        The position corresponds to the top left of the item's
        rectangle

        User writing this attribute automatically switches
        the positioning policy to relative position to the
        window.

        Note that the position may place the item outside the
        parent's content region, in which case the item is not
        visible.

        Setting None to one of component will ignore the update
        of this component.
        
        """
        ...


    @pos_to_window.setter
    def pos_to_window(self, value : tuple):
        ...


    @property
    def previous_sibling(self) -> baseItem | None:
        """
        Writable attribute: child of the parent of the item that
        is rendered just before this item.

        It is not possible to have siblings if you have no parent,
        thus if you intend to attach together items outside the
        rendering tree, there must be a toplevel parent item.

        If you write to this attribute, the item will be moved
        to be inserted just after the target item.
        In case of failure, the item remains in a detached state.

        Note that a parent can have several child queues, and thus
        child elements are not guaranteed to be siblings of each other.
        
        """
        ...


    @previous_sibling.setter
    def previous_sibling(self, value : baseItem | None):
        ...


    @property
    def rect_size(self) -> tuple:
        """
        Readonly attribute: actual (width, height) of the element,
        including margins.

        The space taken by the item corresponds to a rectangle
        of size rect_size with top left coordinate
        the position given by the position fields.

        Not the rect_size refers to the size within the parent
        window. If a popup menu is opened, it is not included.
        
        """
        ...


    @property
    def resized(self) -> bool:
        """
        Readonly attribute: has the item size just changed
        If True, the attribute is reset the next frame. It's better to rely
        on handlers to catch this event.
        
        """
        ...


    @property
    def shareable_value(self) -> SharedValue:
        """
        Same as the value field, but rather than a copy of the internal value
        of the object, return a python object that holds a value field that
        is in sync with the internal value of the object. This python object
        can be passed to other items using an internal value of the same
        type to share it.
        
        """
        ...


    @shareable_value.setter
    def shareable_value(self, value : SharedValue):
        ...


    @property
    def show(self) -> bool:
        """
        Writable attribute: Should the object be drawn/shown ?
        In case show is set to False, this disables any
        callback (for example the close callback won't be called
        if a window is hidden with show = False).
        In the case of items that can be closed,
        show is set to False automatically on close.
        
        """
        ...


    @show.setter
    def show(self, value : bool):
        ...


    @property
    def tag(self) -> uiItem:
        """
        Writable attribute: tag is an optional string that uniquely
        defines the object.

        If set (else it is set to None), tag can be used to access
        the object by name for parent=,
        previous_sibling=, next_sibling= arguments.

        The tag can be set at any time, but it must be unique.
        
        """
        ...


    @tag.setter
    def tag(self, value : uiItem):
        ...


    @property
    def theme(self):
        """
        Writable attribute: bound theme for the item
        
        """
        ...


    @theme.setter
    def theme(self, value):
        ...


    @property
    def user_data(self):
        """
        User data of any type.
        
        """
        ...


    @user_data.setter
    def user_data(self, value):
        ...


    @property
    def uuid(self) -> int:
        """
        Readonly attribute: uuid is an unique identifier created
        by the context for the item.
        uuid can be used to access the object by name for parent=,
        previous_sibling=, next_sibling= arguments, but it is
        preferred to pass the objects directly. 
        
        """
        ...


    @property
    def value(self):
        """
        Writable attribute: main internal value for the object.
        For buttons, it is set when pressed; For text it is the
        text itself; For selectable whether it is selected, etc.
        Reading the value attribute returns a copy, while writing
        to the value attribute will edit the field of the value.
        In case the value is shared among items, setting the value
        attribute will change it for all the sharing items.
        To share a value attribute among objects, one should use
        the shareable_value attribute
        
        """
        ...


    @value.setter
    def value(self, value):
        ...


    @property
    def visible(self) -> bool:
        """
        True if the item was rendered (inside the rendering region + show = True
        for the item and its ancestors). Note when an item is not visible,
        rendering is skipped (as well as running their handlers, etc).
        
        """
        ...


    @property
    def width(self) -> int:
        """
        Writable attribute: Requested width of the item.
        When it is written, it is set to a 'requested value' that is not
        entirely guaranteed to be enforced.
        Specific values:
            . 0 is meant to define the default size. For some items,
              such as windows, it triggers a fit to the content size.
              For other items, there is a default size deduced from the
              style policy. And for some items (such as child windows),
              it triggers a fit to the full size available within the
              parent window.
            . > 0 values is meant as a hint for rect_size.
            . < 0 values to be interpreted as 'take remaining space
              of the parent's content region from the current position,
              and subtract this value'. For example -1 will stretch to the
              remaining area minus one pixel.

        Note that for some items, the actual rect_size of the element cannot
        be changed to the requested values (for example Text). In that case, the
        item is not resized, but it behaves as if it has the requested size in terms
        of impact on the layout (default position of other items).

        In addition the real width may change if the object is resizable.
        In this case, the width may be changed back by setting again the value
        of this field.
        
        """
        ...


    @width.setter
    def width(self, value : int):
        ...

